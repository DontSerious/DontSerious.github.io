<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>cp5 优化程序性能 - Tomato&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Tomato&#039;s Blog"><meta name="msapplication-TileImage" content="static/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Tomato&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="优化编译器的能力和局限性  一种有用的策略是只重写程序，使其达到编译器可以生成高效代码的程度。 减少读取指针的次数来优化程序 如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这样会限制编译器的优化策略 内联函数替换  程序优化实例  12345&amp;#x2F;* Create abstract data type for vector *&amp;#x2F;typedef struct &amp;amp;#123;	l"><meta property="og:type" content="article"><meta property="og:title" content="cp5 优化程序性能"><meta property="og:url" content="https://tomatoblog.netlify.app/Study/csapp/cp5/"><meta property="og:site_name" content="Tomato&#039;s Blog"><meta property="og:description" content="优化编译器的能力和局限性  一种有用的策略是只重写程序，使其达到编译器可以生成高效代码的程度。 减少读取指针的次数来优化程序 如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这样会限制编译器的优化策略 内联函数替换  程序优化实例  12345&amp;#x2F;* Create abstract data type for vector *&amp;#x2F;typedef struct &amp;amp;#123;	l"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.3.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.8.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.17.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.19.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.21.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.23.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.26.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.28.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/reg%20spilling.png"><meta property="article:published_time" content="2023-06-24T02:26:28.000Z"><meta property="article:modified_time" content="2023-07-25T03:19:10.000Z"><meta property="article:author" content="TOMATO"><meta property="article:tag" content="csapp"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.3.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomatoblog.netlify.app/Study/csapp/cp5/"},"headline":"cp5 优化程序性能","image":["https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.3.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.8.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.17.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.19.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.21.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.23.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.26.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/f5.28.png","https://tomatoblog.netlify.app/static/CSAPP/cp5/reg%20spilling.png"],"datePublished":"2023-06-24T02:26:28.000Z","dateModified":"2023-07-25T03:19:10.000Z","author":{"@type":"Person","name":"TOMATO"},"publisher":{"@type":"Organization","name":"Tomato's Blog","logo":{"@type":"ImageObject","url":{"light":"static/avatar.jpg","dark":"static/avatar.jpg"}}},"description":"优化编译器的能力和局限性  一种有用的策略是只重写程序，使其达到编译器可以生成高效代码的程度。 减少读取指针的次数来优化程序 如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这样会限制编译器的优化策略 内联函数替换  程序优化实例  12345&#x2F;* Create abstract data type for vector *&#x2F;typedef struct &amp;#123;\tl"}</script><link rel="canonical" href="https://tomatoblog.netlify.app/Study/csapp/cp5/"><link rel="icon" href="/static/avatar.jpg"><link rel="stylesheet" href="/css/font/fontawesome/css/all.min.css"><link rel="stylesheet" href="/js/imaegoo/highlight.js/11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="/js/imaegoo/lightgallery/1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="/js/imaegoo/justifiedGallery/3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="/js/imaegoo/pace-js/1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 7.1.1"></head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"><img class="logo-img-dark" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives/">时间轴</a><a class="navbar-item" href="/categories/">分类</a><a class="navbar-item" href="/tags/">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-06-24T02:26:28.000Z" title="6/24/2023, 2:26:28 AM">2023-06-24</time>发表</span><span class="level-item"><time datetime="2023-07-25T03:19:10.000Z" title="7/25/2023, 3:19:10 AM">2023-07-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a></span><span class="level-item">13 分钟读完 (大约1891个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">cp5 优化程序性能</h1><div class="content"><h1 id="优化编译器的能力和局限性">优化编译器的能力和局限性</h1><ol><li>一种有用的策略是只重写程序，使其达到编译器可以生成高效代码的程度。</li><li>减少读取指针的次数来优化程序</li><li>如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这样会限制编译器的优化策略</li><li>内联函数替换</li></ol><h1 id="程序优化实例">程序优化实例</h1><p><img src="../../../static/CSAPP/cp5/f5.3.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Create abstract data type for vector */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	long len;</span><br><span class="line">	data_t *data;</span><br><span class="line">&#125; vec_rec, *vec_ptr;</span><br></pre></td></tr></table></figure><p>向量的抽象数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* Create vector of specified length */</span><br><span class="line">vec_ptr new_vec(long len)</span><br><span class="line">&#123;</span><br><span class="line">	/* Allocate header structure */</span><br><span class="line">	vec_ptr result = (vec_ptr) malloc(sizeof(vec_rec));</span><br><span class="line">	data_t *data = NULL;</span><br><span class="line">	if (!result)</span><br><span class="line">		return NULL; /* Couldn&#x27;t allocate storage */</span><br><span class="line">	result-&gt;len = len;</span><br><span class="line">	/* Allocate array */</span><br><span class="line">	if (len &gt; 0) &#123;</span><br><span class="line">		data = (data_t *)calloc(len, sizeof(data_t));</span><br><span class="line">		if (!data) &#123;</span><br><span class="line">			free((void *) result);</span><br><span class="line">			return NULL; /* Couldn&#x27;t allocate storage */</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/* Data will either be NULL or allocated array */</span><br><span class="line">	result-&gt;data = data;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Retrieve vector element and store at dest.</span><br><span class="line">* Return 0 (out of bounds) or 1 (successful)</span><br><span class="line">*/</span><br><span class="line">int get_vec_element(vec_ptr v, long index, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	if (index &lt; 0 | | index &gt;= v-&gt;len)</span><br><span class="line">		return 0;</span><br><span class="line">	*dest = v-&gt;data [index];</span><br><span class="line">	return 1 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Return length of vector */</span><br><span class="line">long vec_length(vec_ptr v)</span><br><span class="line">&#123;</span><br><span class="line">	return v-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向量抽象数据类型的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Implementation with maximum use of data abstraction */</span><br><span class="line">void combinel(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line"></span><br><span class="line">	*dest = IDENT;</span><br><span class="line">	for (i = 0; i &lt; vec_length(v); i++) &#123;</span><br><span class="line">		data_t val;</span><br><span class="line">		get_vec_element(v, i, &amp;val);</span><br><span class="line">		*dest = *dest OP val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并运算的初始实现</p><p>求和声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define IDENT 0</span><br><span class="line">#define OP +</span><br></pre></td></tr></table></figure><p>乘积声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define IDENT 1</span><br><span class="line">#define OP *</span><br></pre></td></tr></table></figure><h2 id="消除循环的低效率">消除循环的低效率</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Move call to vec_length out of loop */</span><br><span class="line">void combine2(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line">	long length = vec_length(v);</span><br><span class="line"></span><br><span class="line">	*dest = IDENT;</span><br><span class="line">	for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		data_t val;</span><br><span class="line">		get_vec_element(v, i, &amp;val);</span><br><span class="line">		*dest = *dest OP val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次调用 vec_length 方法来获取长度实现循环会降低效率</p><h2 id="低效率极端例子">低效率极端例子</h2><p>识别要执行多次，但是计算结果不会改变的计算，可以将计算移动到代码前面不会被多次求值的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* Convert string to lowercase: slow */</span><br><span class="line">void lower1(char *s)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; strlen(s); i++)</span><br><span class="line">		if (s[i] &gt;= `A&#x27; &amp;&amp; s[i] &lt;= `Z&#x27;)</span><br><span class="line">			s[i] -= (`A&#x27; - `a&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Convert string to lowercase: faster */</span><br><span class="line">void lower2(char *s)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line">	long len = strlen(s);</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; len; i++)</span><br><span class="line">		if (s[i] &gt;= `A&#x27; &amp;&amp; s[i] &lt;= `Z&#x27;)</span><br><span class="line">			s[i] -= (`A&#x27; - `a&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Sample implementation of library function strlen */</span><br><span class="line">/* Compute length of string */</span><br><span class="line">size_t strlen(const char *s)</span><br><span class="line">&#123;</span><br><span class="line">	long length = 0;</span><br><span class="line">	while (*s != `\0&#x27;) &#123;</span><br><span class="line">			s++;</span><br><span class="line">			length++;</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../static/CSAPP/cp5/f5.8.png" alt=""></p><h2 id="减少过程调用">减少过程调用</h2><ul><li>combine 2 的代码每次循环都会调用 get_vec_element 来获取下一个向量元素。</li><li>对每个向量引用，这个函数都要把向量索引 i 与循环边界作比较，这会造成低效率</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data_t *get_vec_start(vec_ptr v)</span><br><span class="line">&#123;</span><br><span class="line">	return v-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Direct access to vector data */</span><br><span class="line">void combine3(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line">	long length = vec_length(v);</span><br><span class="line">	data_t *data = get_vec_start(v); </span><br><span class="line"></span><br><span class="line">	*dest = IDENT;</span><br><span class="line">	for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		*dest = *dest OP data[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这并没有立刻得到明显的提升，显然还有其他瓶颈</p><h2 id="消除不必要的内存引用">消除不必要的内存引用</h2><p>分析 combine3 循环代码生成的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Inner loop of combine3. data_t = double, OP = *</span><br><span class="line">dest in %rbx, data+i in %rdx, data+length in %rax</span><br><span class="line">. L17:				              loop:</span><br><span class="line">   vmovsd (%rbx), %xmm0		        Read product from dest</span><br><span class="line">   vmulsd (%rdx), %xmm0, %xmm0	    Multiply product by data[i]</span><br><span class="line">   vmovsd %xmm0, (%rbx)		        Store product at dest</span><br><span class="line">   addq $8, %rdx		            Increment data+i</span><br><span class="line">   cmpq %rax, %rdx		            Compare to data+length</span><br><span class="line">   jne .L17			                If !=, goto loop</span><br></pre></td></tr></table></figure><ul><li>它将代码改变为：在寄存器 %rdx 中维护一个指向第 i 个数据元素的指针，在注释中显示为 data+i。</li><li>该指针在每次迭代中增加8。通过将该指针与存储在寄存器 %rax 中的指针进行比较来检测循环终止。</li><li>每次迭代都会从内存中读取和写入累积的值。这种读写是浪费的，因为每次迭代开始时从 dest 读取的值应该只是前一次迭代结束时写入的值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inner loop of combine4. data_t = double, OP = *</span><br><span class="line">acc in %xmm0, data+i in %rdx, data+length in %rax</span><br><span class="line">.L25:				loop:</span><br><span class="line">  vmulsd (%rdx), %xmm0, %xmm0	  Multiply acc by data[i]</span><br><span class="line">  addq $8, %rdx			  Increment data+i</span><br><span class="line">  cmpq %rax, %rdx		  Compare to data+length</span><br><span class="line">  jne .L25			  If !=, goto loop</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1	/* Accumulate result in local variable */</span><br><span class="line">2	void combine4(vec_ptr v, data_t *dest)</span><br><span class="line">3	&#123;</span><br><span class="line">4		long i;</span><br><span class="line">5		long length = vec_length(v);</span><br><span class="line">6		data_t *data = get_vec_start(v);</span><br><span class="line">7		data_t acc = IDENT;</span><br><span class="line">8	</span><br><span class="line">9		for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">10			acc = acc OP data[i];</span><br><span class="line">11		&#125;</span><br><span class="line">12		*dest = acc;</span><br><span class="line">13	&#125;</span><br></pre></td></tr></table></figure><ul><li>我们引入了一个临时变量 acc，用于在循环中累积计算出的值，只有在循环完成后，结果才存储在 dest 中。</li><li>如上面的汇编代码所示，编译器现在可以使用寄存器%xmm0来保存累积值。</li><li>与 combine3中的循环相比，我们将每次迭代的内存操作从两次读一次写减少到只需要一次读。</li></ul><h2 id="循环展开">循环展开</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 2 x 1 loop unrolling */</span><br><span class="line">void combine5(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line">	long length = vec_length(v);</span><br><span class="line">	long limit = length-1;</span><br><span class="line">	data_t *data = get_vec_start(v);</span><br><span class="line">	data_t acc = IDENT; 9</span><br><span class="line">	/* Combine 2 elements at a time */</span><br><span class="line">	for (i = 0; i &lt; limit; i+=2) &#123;</span><br><span class="line">		acc = (acc OP data[i]) OP data[i+1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Finish any remaining elements */</span><br><span class="line">	for (;i &lt; length; i++) &#123;</span><br><span class="line">		acc = acc OP data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	*dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确保第一次循环不会超出数组的界限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	Inner loop of combine5. data_t = double, OP = *</span><br><span class="line">	i in %rdx, data %rax, limit in %rbx, acc in %xmm0</span><br><span class="line">1	.L35:					                  loop:</span><br><span class="line">2	  vmulsd (%rax,%rdx,8), %xmm0, %xmm0	    Multiply acc by data[i]</span><br><span class="line">3	  vmulsd 8(%rax,%rdx,8), %xmm0, %xmm0	    Multiply acc by data[i+1]</span><br><span class="line">4	  addq $2, %rdx				                Increment i by 2</span><br><span class="line">5	  cmpq %rdx, %rbp			                Compare to limit:i</span><br><span class="line">6	  jg .L35				                    If &gt;, goto loop</span><br></pre></td></tr></table></figure><p><img src="../../../static/CSAPP/cp5/f5.17.png" alt=""></p><ul><li>整数加法的一个周期的延迟称为限制性能的因素</li></ul><p><img src="../../../static/CSAPP/cp5/f5.19.png" alt=""></p><h2 id="提高并行性">提高并行性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 2 x 2 loop unrolling */</span><br><span class="line">void combine6(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line">	long length = vec_length(v);</span><br><span class="line">	long limit = length-1;</span><br><span class="line">	data_t *data = get_vec_start(v);</span><br><span class="line">	data_t acc0 = IDENT;</span><br><span class="line">	data_t acc1 = IDENT;</span><br><span class="line"></span><br><span class="line">	/* Combine 2 elements at a time */</span><br><span class="line">	for (i = 0; i &lt; limit; i+=2) &#123;</span><br><span class="line">		acc0 = acc0 OP data[i];</span><br><span class="line">		acc1 = acc1 OP data[i+1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Finish any remaining elements */</span><br><span class="line">	for (;i &lt; length; i++) &#123;</span><br><span class="line">		acc0 = acc0 OP data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	*dest = acc0 OP acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 x 2 循环展开</li><li>打破了由延迟界限设下的限制。处理器不再需要延迟一个加法或乘法操作以待前一个操作完成</li></ul><p><img src="../../../static/CSAPP/cp5/f5.21.png" alt=""></p><p><img src="../../../static/CSAPP/cp5/f5.23.png" alt=""></p><h2 id="重新结合变换">重新结合变换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 2 x 1a loop unrolling */</span><br><span class="line">void combine7(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">	long i;</span><br><span class="line">	long length = vec_length(v);</span><br><span class="line">	long limit = length-1;</span><br><span class="line">	data_t *data = get_vec_start(v);</span><br><span class="line">	data_t acc = IDENT; 9</span><br><span class="line">	/* Combine 2 elements at a time */</span><br><span class="line">	for (i = 0; i &lt; limit; i+=2) &#123;</span><br><span class="line">		acc = acc OP (data[i] OP data[i+1]);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	/* Finish any remaining elements */</span><br><span class="line">	for (;i &lt; length; i++) &#123;</span><br><span class="line">		acc = acc OP data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	*dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与 combine 5 不同的之处于第 11 行</li><li>性能提升很大，几乎与 combine6 相同</li><li>修改之后，每次迭代内的第一个乘法都不需要等待前一次迭代的累计值就可以执行</li></ul><p><img src="../../../static/CSAPP/cp5/f5.26.png" alt=""></p><p><img src="../../../static/CSAPP/cp5/f5.28.png" alt=""></p><h1 id="限制因素">限制因素</h1><h2 id="寄存器溢出">寄存器溢出</h2><p><img src="../../../static/CSAPP/cp5/reg%20spilling.png" alt=""></p><ul><li>循环并行的好处受到汇编代码描述计算的能力限制。</li><li>如果并行度超过可用寄存器的数量，编译器会诉诸溢出。</li><li>上图可以发现，循环展开并没有改善，有些甚至还变差了</li></ul><h2 id="分支预测">分支预测</h2><p>分支预测失败的惩罚是很严重的，所以我们需要控制编写程序的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */</span><br><span class="line">void minmax1(long a[], long b[], long n) &#123;</span><br><span class="line">	long i;</span><br><span class="line">	for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (a[i] &gt; b[i]) &#123;</span><br><span class="line">			long t = a[i];</span><br><span class="line">			a[i] = b[i];</span><br><span class="line">			b[i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令式风格代码⬆</p><ul><li>CPE 大约为 13.5，但对于可预测的数据，CPE 仅为 2.5~3.5，预测错误惩罚约为 20 个周期</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */</span><br><span class="line">void minmax2(long a[], long b[], long n) &#123;</span><br><span class="line">	long i;</span><br><span class="line">	for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		long min = a[i] &lt; b[i] ? a[i] : b[i];</span><br><span class="line">		long max = a[i] &lt; b[i] ? b[i] : a[i];</span><br><span class="line">		a[i] = min;</span><br><span class="line">		b[i] = max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能式风格代码⬆</p><ul><li>无论数据是可预测还是不可预测，CPE 都大约为 4.0</li><li>这样写可以引导产生条件传送代码，提高性能</li></ul></div><div class="article-licensing box"><div class="licensing-title"><p>cp5 优化程序性能</p><p><a href="https://tomatoblog.netlify.app/Study/csapp/cp5/">https://tomatoblog.netlify.app/Study/csapp/cp5/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TOMATO</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-06-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-07-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/csapp/">csapp</a></div></article></div><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Study/csapp/cp6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">cp6 存储器层次结构</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Study/csapp/cp4/"><span class="level-item">cp4 处理器体系结构</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div></div><style>.column.column-left,.column.column-right{display:none}</style><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/static/avatar.jpg" alt="ToMaTo"></figure><p class="title is-size-4 is-block" style="line-height:inherit">ToMaTo</p><p class="is-size-6 is-block">Back-end Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>GuangZhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">59</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/dontSerious/" target="_blank" rel="noopener" id="widget-follow">Github</a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">2024年04月</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">2024年03月</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">2024年02月</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">2023年12月</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">2023年11月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">2023年10月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">2023年09月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">2023年08月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">2023年06月</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">2023年05月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">2023年04月</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">2023年03月</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">2023年02月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-04-28T10:24:18.000Z">2024-04-28</time></p><p class="title"><a href="/FrontEnd/Flutter/">flutter 笔记</a></p><p class="categories"><a href="/categories/FrontEnd/">FrontEnd</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T06:43:15.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/go/">go面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T02:10:11.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/datastruct/">数据结构和算法面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T02:10:11.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/distributed/">分布式面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-16T07:28:10.000Z">2024-03-16</time></p><p class="title"><a href="/BackEnd/sql/index/">SQL 索引</a></p><p class="categories"><a href="/categories/BackEnd/">BackEnd</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#优化编译器的能力和局限性"><span class="level-left"><span class="level-item">1</span><span class="level-item">优化编译器的能力和局限性</span></span></a></li><li><a class="level is-mobile" href="#程序优化实例"><span class="level-left"><span class="level-item">2</span><span class="level-item">程序优化实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#消除循环的低效率"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">消除循环的低效率</span></span></a></li><li><a class="level is-mobile" href="#低效率极端例子"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">低效率极端例子</span></span></a></li><li><a class="level is-mobile" href="#减少过程调用"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">减少过程调用</span></span></a></li><li><a class="level is-mobile" href="#消除不必要的内存引用"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">消除不必要的内存引用</span></span></a></li><li><a class="level is-mobile" href="#循环展开"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">循环展开</span></span></a></li><li><a class="level is-mobile" href="#提高并行性"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">提高并行性</span></span></a></li><li><a class="level is-mobile" href="#重新结合变换"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">重新结合变换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#限制因素"><span class="level-left"><span class="level-item">3</span><span class="level-item">限制因素</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#寄存器溢出"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">寄存器溢出</span></span></a></li><li><a class="level is-mobile" href="#分支预测"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">分支预测</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/BackEnd/"><span class="level-start"><span class="level-item">BackEnd</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/"><span class="level-start"><span class="level-item">Interview</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Memo/"><span class="level-start"><span class="level-item">Memo</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Study/"><span class="level-start"><span class="level-item">Study</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/Tutorial/"><span class="level-start"><span class="level-item">Tutorial</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Flutter/"><span class="tag">Flutter</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT6-S081/"><span class="tag">MIT6.S081</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue-js/"><span class="tag">Vue.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bookNote/"><span class="tag">bookNote</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/career/"><span class="tag">career</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cs/"><span class="tag">cs</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/csapp/"><span class="tag">csapp</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/curriculum/"><span class="tag">curriculum</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dataStruct/"><span class="tag">dataStruct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/datastruct/"><span class="tag">datastruct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/distributed/"><span class="tag">distributed</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/live/"><span class="tag">live</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/log/"><span class="tag">log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memo/"><span class="tag">memo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/network/"><span class="tag">network</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidian/"><span class="tag">obsidian</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/project/"><span class="tag">project</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psychology/"><span class="tag">psychology</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/simpleBank/"><span class="tag">simpleBank</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql/"><span class="tag">sql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tools/"><span class="tag">tools</span><span class="tag">10</span></a></div></div></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"><img class="logo-img-dark" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 TOMATO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/deed.zh"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="/js/imaegoo/jquery/3.3.1/dist/jquery.min.js"></script><script src="/js/imaegoo/moment/2.22.2/min/moment-with-locales.min.js"></script><script src="/js/imaegoo/clipboard/2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "此网站使用 Cookie，以启用评论系统和分析功能。",
          dismiss: "知道了",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="/js/imaegoo/lightgallery/1.10.0/dist/js/lightgallery.min.js" defer></script><script src="/js/imaegoo/justifiedGallery/3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>