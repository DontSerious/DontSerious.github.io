<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>cp3 程序的机器级表示 - Tomato&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Tomato&#039;s Blog"><meta name="msapplication-TileImage" content="static/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Tomato&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="名词  ISA：Instruction Set Architecture(指令集架构)的缩写，也叫指令集体系结构。它定义了机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 PC：程序计数器，在x86-64中称为%rip，表示下一条要执行的指令在内存中的地址。 scalar data types：标量数据类型，是计算机科学中的一个术语。标量是指一种基本的数据类型，它"><meta property="og:type" content="article"><meta property="og:title" content="cp3 程序的机器级表示"><meta property="og:url" content="https://tomatoblog.netlify.app/Study/csapp/cp3/"><meta property="og:site_name" content="Tomato&#039;s Blog"><meta property="og:description" content="名词  ISA：Instruction Set Architecture(指令集架构)的缩写，也叫指令集体系结构。它定义了机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 PC：程序计数器，在x86-64中称为%rip，表示下一条要执行的指令在内存中的地址。 scalar data types：标量数据类型，是计算机科学中的一个术语。标量是指一种基本的数据类型，它"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.3.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.14set.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.15jmp.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.18cmov.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.25stack%20frame.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.27.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.28passing%20arguments.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.30stack%20frame.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.36row-major.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/struct.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/union.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/align1.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/align2.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/align3.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.40echo.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.45Media%20registers.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.46Floating-point%20movement%20instructions.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.47Two-operand%20floating-point%20conversion%20operations.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.48Three-operand%20floating-point%20conversion%20operations.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.49Scalar%20floating-point%20arithmetic%20operations.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.50Bitwise%20operations.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.11.6.png"><meta property="og:image" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.11.6condition%20codes.png"><meta property="article:published_time" content="2023-04-09T06:54:13.000Z"><meta property="article:modified_time" content="2023-05-19T03:12:54.000Z"><meta property="article:author" content="TOMATO"><meta property="article:tag" content="csapp"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.3.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomatoblog.netlify.app/Study/csapp/cp3/"},"headline":"cp3 程序的机器级表示","image":["https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.3.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.14set.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.15jmp.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.18cmov.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.25stack%20frame.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.27.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.28passing%20arguments.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.30stack%20frame.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.36row-major.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/struct.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/union.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/align1.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/align2.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/align3.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.40echo.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.45Media%20registers.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.46Floating-point%20movement%20instructions.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.47Two-operand%20floating-point%20conversion%20operations.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.48Three-operand%20floating-point%20conversion%20operations.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.49Scalar%20floating-point%20arithmetic%20operations.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.50Bitwise%20operations.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.11.6.png","https://tomatoblog.netlify.app/static/CSAPP/cp3/f3.11.6condition%20codes.png"],"datePublished":"2023-04-09T06:54:13.000Z","dateModified":"2023-05-19T03:12:54.000Z","author":{"@type":"Person","name":"TOMATO"},"publisher":{"@type":"Organization","name":"Tomato's Blog","logo":{"@type":"ImageObject","url":{"light":"static/avatar.jpg","dark":"static/avatar.jpg"}}},"description":"名词  ISA：Instruction Set Architecture(指令集架构)的缩写，也叫指令集体系结构。它定义了机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 PC：程序计数器，在x86-64中称为%rip，表示下一条要执行的指令在内存中的地址。 scalar data types：标量数据类型，是计算机科学中的一个术语。标量是指一种基本的数据类型，它"}</script><link rel="canonical" href="https://tomatoblog.netlify.app/Study/csapp/cp3/"><link rel="icon" href="/static/avatar.jpg"><link rel="stylesheet" href="/css/font/fontawesome/css/all.min.css"><link rel="stylesheet" href="/js/imaegoo/highlight.js/11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="/js/imaegoo/lightgallery/1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="/js/imaegoo/justifiedGallery/3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="/js/imaegoo/pace-js/1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 7.1.1"></head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"><img class="logo-img-dark" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives/">时间轴</a><a class="navbar-item" href="/categories/">分类</a><a class="navbar-item" href="/tags/">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-04-09T06:54:13.000Z" title="4/9/2023, 6:54:13 AM">2023-04-09</time>发表</span><span class="level-item"><time datetime="2023-05-19T03:12:54.000Z" title="5/19/2023, 3:12:54 AM">2023-05-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a></span><span class="level-item">1 小时读完 (大约7108个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">cp3 程序的机器级表示</h1><div class="content"><h1 id="名词">名词</h1><ul><li>ISA：Instruction Set Architecture(指令集架构)的缩写，也叫指令集体系结构。它定义了机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li><li>PC：程序计数器，在x86-64中称为<code>%rip</code>，表示下一条要执行的指令在内存中的地址。</li><li>scalar data types：标量数据类型，是计算机科学中的一个术语。标量是指一种基本的数据类型，它表示单个值，并且不可拆分为更小的部分。标量数据类型在程序设计中非常常见，包括整数、浮点数、字符和布尔型等。</li><li>vector：向量，表示一种被用于向量数据计算或是多媒体处理等运算的指令集或硬件加速器。这些指令集和硬件加速器通常用于执行一些对于大规模数据和向量的加速运算，如矩阵乘法、卷积等。</li></ul><h1 id="gcc">gcc</h1><h2 id="参数">参数</h2><h3 id="优化等级">优化等级</h3><p><code>-Og</code>：告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级</p><ul><li>使用较高的优化级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系难以理解。</li><li>实际上，从得到的程序的性能考虑，较高级别的优化被认为是较好的选择<ul><li>例如，以选项 <code>-O1</code> 或 <code>-O2</code> 指定</li></ul></li></ul><h3 id="汇编代码">汇编代码</h3><p>C预处理器扩展源代码，插入所有用<code>#include</code>命令指定的文件，并扩展所有用<code>#define</code>声明指定的宏。</p><p><code>-S</code>：能看到C语言编译器产生的汇编代码。</p><ul><li>生成 <code>*.s</code> 汇编文件，但是不做其他进一步的工作。</li></ul><h3 id="目标代码">目标代码</h3><p>汇编器将 <code>*.s</code> 文件的汇编代码转换为二进制的目标代码文件。并生成目标代码文件 <code>*.o</code>。</p><ul><li>包含所有指令的二进制表示，但还没填入全局的地址</li></ul><p><code>-c</code>：GCC会编译并汇编该代码，生成 <code>*.o</code> 文件</p><ul><li>它是二进制格式的，无法直接查看</li></ul><h3 id="可执行代码">可执行代码</h3><p><code>-o</code>：链接器将目标代码文件 <code>*.o</code> 与实现库函数的代码合并，并产生最终的可执行代码文件。</p><ul><li>文件名由 <code>-o 文件名</code> 指定</li></ul><h3 id="反汇编器">反汇编器</h3><p><code>objdump -d 文件名</code>：根据机器代码产生一种类似于汇编代码的格式。针对<code>*.o</code>文件。</p><h1 id="数据格式">数据格式</h1><table><thead><tr><th style="text-align:center">C declaration</th><th style="text-align:center">Intel data type</th><th style="text-align:center">Assembly-code</th><th style="text-align:center">suffix	Size (bytes)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">Byte</td><td style="text-align:center">b</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Word</td><td style="text-align:center">w</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">Double word</td><td style="text-align:center">l</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Quad word</td><td style="text-align:center">q</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">char *</td><td style="text-align:center">Quad word</td><td style="text-align:center">q</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Single precision</td><td style="text-align:center">s</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double precision</td><td style="text-align:center">l</td><td style="text-align:center">8</td></tr></tbody></table><h1 id="访问信息">访问信息</h1><ol><li>最初的8086中有 8 个 16 位的寄存器，即下表中 %ax ~ %sp</li><li>IA32中寄存器扩展为32位，标号有 %eax ~ %esp</li><li>X86-64中寄存器扩展成64位，编号有 %rax ~ %rsp，还增加了 8 个寄存器</li></ol><table><thead><tr><th style="text-align:center">63 ~ 31</th><th style="text-align:center">31 ~ 15</th><th style="text-align:center">15 ~ 7</th><th style="text-align:center">7 ~ 0</th><th style="text-align:center">usage</th></tr></thead><tbody><tr><td style="text-align:center">%rax</td><td style="text-align:center">%eax</td><td style="text-align:center">%ax</td><td style="text-align:center">%al</td><td style="text-align:center">return value</td></tr><tr><td style="text-align:center">%rbx</td><td style="text-align:center">%ebx</td><td style="text-align:center">%bx</td><td style="text-align:center">%bl</td><td style="text-align:center">Callee saved</td></tr><tr><td style="text-align:center">%rcx</td><td style="text-align:center">%ecx</td><td style="text-align:center">%cx</td><td style="text-align:center">%cl</td><td style="text-align:center">4th argument</td></tr><tr><td style="text-align:center">%rdx</td><td style="text-align:center">%edx</td><td style="text-align:center">%dx</td><td style="text-align:center">%dl</td><td style="text-align:center">3rd argument</td></tr><tr><td style="text-align:center">%rsi</td><td style="text-align:center">%esi</td><td style="text-align:center">%si</td><td style="text-align:center">%sil</td><td style="text-align:center">2nd argument</td></tr><tr><td style="text-align:center">%rdi</td><td style="text-align:center">%edi</td><td style="text-align:center">%di</td><td style="text-align:center">%dil</td><td style="text-align:center">1st argument</td></tr><tr><td style="text-align:center">%rbp</td><td style="text-align:center">%ebp</td><td style="text-align:center">%bp</td><td style="text-align:center">%bpl</td><td style="text-align:center">Callee saved</td></tr><tr><td style="text-align:center">%rsp</td><td style="text-align:center">%esp</td><td style="text-align:center">%sp</td><td style="text-align:center">%spl</td><td style="text-align:center">Stack pointer</td></tr><tr><td style="text-align:center">%r8</td><td style="text-align:center">%r8d</td><td style="text-align:center">%r8w</td><td style="text-align:center">%r8b</td><td style="text-align:center">5th argument</td></tr><tr><td style="text-align:center">%r9</td><td style="text-align:center">%r9d</td><td style="text-align:center">%r9w</td><td style="text-align:center">%r9b</td><td style="text-align:center">6th argument</td></tr><tr><td style="text-align:center">%r10</td><td style="text-align:center">%r10d</td><td style="text-align:center">%r10w</td><td style="text-align:center">%r10b</td><td style="text-align:center">Callee saved</td></tr><tr><td style="text-align:center">%r11</td><td style="text-align:center">%r11d</td><td style="text-align:center">%r11w</td><td style="text-align:center">%r11b</td><td style="text-align:center">Callee saved</td></tr><tr><td style="text-align:center">%r12</td><td style="text-align:center">%r12d</td><td style="text-align:center">%r12w</td><td style="text-align:center">%r12b</td><td style="text-align:center">Callee saved</td></tr><tr><td style="text-align:center">%r13</td><td style="text-align:center">%r13d</td><td style="text-align:center">%r13w</td><td style="text-align:center">%r13b</td><td style="text-align:center">Callee saved</td></tr><tr><td style="text-align:center">%r14</td><td style="text-align:center">%r14d</td><td style="text-align:center">%r14w</td><td style="text-align:center">%r14b</td><td style="text-align:center">Callee saved</td></tr><tr><td style="text-align:center">%r15</td><td style="text-align:center">%r15d</td><td style="text-align:center">%r15w</td><td style="text-align:center">%r15b</td><td style="text-align:center">Callee saved</td></tr></tbody></table><ul><li>字节级操作可以访问最低的字节</li><li>16位操作可以访问最低的两个字节</li><li>32位操作可以访问最低的四个字节</li><li>64位操作可以访问整个寄存器</li></ul><h2 id="操作数指示符">操作数指示符</h2><p><img src="../../../static/CSAPP/cp3/f3.3.png" alt=""></p><ul><li>立即数(immediate): 在ATT格式的汇编代码中，立即数的书写方式是 <code>$</code> 后面跟一个用标准 C 表示法表示的整数，例如<code>$-577</code>、<code>$0x1F</code>。</li><li>寄存器(register): ra 表示任意寄存器a，用引用 R[ra] 来代表它的值</li><li>内存引用：根据地址访问内存位置。用符号 Mb[Addr] 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。通常省略 b</li><li>最下面的表示是最常用的形式</li></ul><h2 id="数据传送指令">数据传送指令</h2><ul><li>S：源操作数（source operand）</li><li>D：目标操作数（destination operand）</li><li>I：立即数操作数（immediate operand）</li><li>R：寄存器操作数（register operand）</li></ul><h3 id="简单的数据传送指令">简单的数据传送指令</h3><ul><li>根据源操作数选择指令</li><li>使用到操作数格式寻址时，必须为64位寄存器</li><li>两个操作数不能都为内存地址，进行mov其中一个必须为寄存器</li><li>不能以立即数作为目标操作数</li></ul><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Effect</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">mov S, D</td><td style="text-align:center">D ← S</td><td style="text-align:center">Move</td></tr><tr><td style="text-align:center">movb</td><td style="text-align:center"></td><td style="text-align:center">Move byte</td></tr><tr><td style="text-align:center">movw</td><td style="text-align:center"></td><td style="text-align:center">Move word</td></tr><tr><td style="text-align:center">movl</td><td style="text-align:center"></td><td style="text-align:center">Move double word</td></tr><tr><td style="text-align:center">movq</td><td style="text-align:center"></td><td style="text-align:center">Move quad word</td></tr><tr><td style="text-align:center">movabsq I, R</td><td style="text-align:center">R ← I</td><td style="text-align:center">Move absolute quad word</td></tr></tbody></table><ul><li>movl 指令以寄存器作为目标时，会把该寄存器的高位4字节设置为0<ul><li>x86-64采用的惯例，即任何为寄存器生成32位值的指令都会将该寄存器的高位部分设置为0</li></ul></li></ul><h3 id="零扩展数据传送指令">零扩展数据传送指令</h3><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Effect</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">movz S,R</td><td style="text-align:center">R ← ZeroExtend(S)</td><td style="text-align:center">Move with zero extension</td></tr><tr><td style="text-align:center">movzbw</td><td style="text-align:center"></td><td style="text-align:center">Move zero-extended byte to word</td></tr><tr><td style="text-align:center">movzbl</td><td style="text-align:center"></td><td style="text-align:center">Move zero-extended byte to double word</td></tr><tr><td style="text-align:center">movzwl</td><td style="text-align:center"></td><td style="text-align:center">Move zero-extended word to double word</td></tr><tr><td style="text-align:center">movzbq</td><td style="text-align:center"></td><td style="text-align:center">Move zero-extended byte to quad word</td></tr><tr><td style="text-align:center">movzwq</td><td style="text-align:center"></td><td style="text-align:center">Move zero-extended word to quad word</td></tr></tbody></table><ul><li>以寄存器或内存为源，以寄存器作为目的</li><li>MOVZ 类指令把目的中的剩余的字节填充为0</li></ul><h3 id="符号扩展数据传送指令">符号扩展数据传送指令</h3><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Effect</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">movs S,R</td><td style="text-align:center">R ← SignExtend(S)</td><td style="text-align:center">Move with sign extension</td></tr><tr><td style="text-align:center">movsbw</td><td style="text-align:center"></td><td style="text-align:center">Move sign-extended byte to word</td></tr><tr><td style="text-align:center">movsbl</td><td style="text-align:center"></td><td style="text-align:center">Move sign-extended byte to double word</td></tr><tr><td style="text-align:center">movswl</td><td style="text-align:center"></td><td style="text-align:center">Move sign-extended word to double word</td></tr><tr><td style="text-align:center">movsbq</td><td style="text-align:center"></td><td style="text-align:center">Move sign-extended byte to quad word</td></tr><tr><td style="text-align:center">movswq</td><td style="text-align:center"></td><td style="text-align:center">Move sign-extended word to quad word</td></tr><tr><td style="text-align:center">movslq</td><td style="text-align:center"></td><td style="text-align:center">Move sign-extended double word to quad word</td></tr><tr><td style="text-align:center">cltq</td><td style="text-align:center">%rax ← SignExtend(%eax)</td><td style="text-align:center">Sign-extend %eax to %rax</td></tr></tbody></table><ul><li>以寄存器或内存为源，以寄存器作为目的</li><li>cltq 指令它没有操作数，总是以 %eax 为源，以 %rax 为符号扩展结果的目的。它的效果和 <code>movslq %eax, %rax</code> 完全一致</li><li>MOVZ 类指令通过符号扩展来填充，把源操作的最高位进行复制</li></ul><h2 id="压入和弹出栈数据">压入和弹出栈数据</h2><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Effect</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">pushq S</td><td style="text-align:center">R[%rsp] ← R[%rsp] –8;<br>M[R[%rsp]] ← S</td><td style="text-align:center">Push quad word</td></tr><tr><td style="text-align:center">popq D</td><td style="text-align:center">D ← M[R[%rsp]];<br>R[%rsp] ← R[%rsp] + 8</td><td style="text-align:center">Pop quad word</td></tr></tbody></table><p>pushq 等价</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8,%rsp</span><br><span class="line">movq %rbp,(%rsp)</span><br></pre></td></tr></table></figure><p>popq 等价</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp),%rax</span><br><span class="line">addq $8,$rsp</span><br></pre></td></tr></table></figure><ul><li>虽然等价，但是 pushq 和 popq 的指令编码仅为一个字节，而上面两条指令一共需要八个字节</li><li>栈和程序代码以及其它形式的程序数据都放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内任何位置</li></ul><h1 id="算数和逻辑操作">算数和逻辑操作</h1><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Effect</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">leaq S, D</td><td style="text-align:center">D ← &amp;S</td><td style="text-align:center">Load effective address</td></tr><tr><td style="text-align:center">inc D</td><td style="text-align:center">D ← D + 1</td><td style="text-align:center">Increment</td></tr><tr><td style="text-align:center">dec D</td><td style="text-align:center">D ← D - 1</td><td style="text-align:center">Decrement</td></tr><tr><td style="text-align:center">neg D</td><td style="text-align:center">D ← -D</td><td style="text-align:center">Negate</td></tr><tr><td style="text-align:center">not D</td><td style="text-align:center">D ← ~D</td><td style="text-align:center">Complement</td></tr><tr><td style="text-align:center">add S, D</td><td style="text-align:center">D ← D + S</td><td style="text-align:center">Add</td></tr><tr><td style="text-align:center">sub S, D</td><td style="text-align:center">D ← D - S</td><td style="text-align:center">Subtract</td></tr><tr><td style="text-align:center">imul S, D</td><td style="text-align:center">D ← D * S</td><td style="text-align:center">Multiply</td></tr><tr><td style="text-align:center">xor S, D</td><td style="text-align:center">D ← D ^ S</td><td style="text-align:center">Exclusive-or</td></tr><tr><td style="text-align:center">or S, D</td><td style="text-align:center">D ← D | S</td><td style="text-align:center">Or</td></tr><tr><td style="text-align:center">and S, D</td><td style="text-align:center">D ← D &amp; S</td><td style="text-align:center">And</td></tr><tr><td style="text-align:center">sal k, D</td><td style="text-align:center">D ← D &lt;&lt; k</td><td style="text-align:center">Left shift</td></tr><tr><td style="text-align:center">shl k, D</td><td style="text-align:center">D ← D &lt;&lt; k</td><td style="text-align:center">Left shift (same as sal)</td></tr><tr><td style="text-align:center">sar k, D</td><td style="text-align:center">D ← D &gt;&gt;A k</td><td style="text-align:center">Arithmetic right shift</td></tr><tr><td style="text-align:center">shr k, D</td><td style="text-align:center">D ← D &gt;&gt;L k</td><td style="text-align:center">Logical right shift</td></tr></tbody></table><ul><li>加载有效地址(leaq)指令通常用来执行简单的算术操作</li><li>ATT格式的汇编代码中操作数的顺序与一般的直觉相反</li></ul><h2 id="加载有效地址-leaq">加载有效地址(leaq)</h2><ul><li>实际上是movq指令的变形，指令形式是从内存读数据到寄存器，但实际上根本没有引用内存</li><li>该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数</li><li>它可以简洁的描述普通的算术操作<ul><li>如果寄存器 %rdx 的值为 x，那么指令 <code>leaq 7(%rdx, %rdx, 4)</code>，%rax 将设置寄存器 %rax 的值为 <code>5x + 7</code></li></ul></li><li>目的数必须为一个寄存器</li></ul><p>例如：</p><p>c程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时，算术运算将以三条 leaq 指令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  // long scale(long x, long y, long z)</span><br><span class="line">  // x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">scale:</span><br><span class="line">  leaq	(%rdi,%rsi,4), %rax		// x + 4*y</span><br><span class="line">  leaq	(%rdx,%rdx,2), %rdx		// z + 2*z = 3*z</span><br><span class="line">  leaq	(%rax,%rdx,4), %rax		// (x+4*y) + 4*(3*z) = x + 4*y + 12*z</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><ul><li>它能执行加法和有限形式的乘法</li></ul><h2 id="二元操作">二元操作</h2><ul><li>源操作数是第一个，目的操作数是第二个<ul><li><code>subq %rax,%rdx</code> 可以解读为：从%rdx中减去%rax</li></ul></li><li>第一个操作数可以是立即数、寄存器或是内存位置</li><li>第二个操作数可以是寄存器或是内存地址。<ul><li>当第二个数位内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存</li></ul></li></ul><h2 id="移位操作-SA">移位操作 SA</h2><p><code>SAL 移位量, 移位的数</code></p><ul><li>移位量可以是一个立即数，或者放在单字节寄存器 %cl 中(能且只能放在这个特定寄存器)</li><li>当寄存器 %cl 的十六进制值为 0xFF 时，salb 会移 7 位，salw 会移 15 位，sall 会移 31 位，salq 会移 63 位</li><li>左移指令有两个名字：SAL 和 SHL<ul><li>两者效果一致，都是将右边填上0</li></ul></li><li>右移指令不同<ul><li>SAR执行算术移位(填上符号位)</li><li>SHR执行逻辑以为(填上0)</li></ul></li></ul><h2 id="xorq-rdx-rdx">xorq %rdx,%rdx</h2><ul><li>这个指令用来将寄存器设置为0</li><li>最直接的方法是 movq $0,%rdx</li><li>xorq版本只需要三个字节，movq版本则需要七个字节</li></ul><h2 id="特殊的算术操作">特殊的算术操作</h2><ul><li>x86-64 指令集对 128 位(16 字节)数的操作提供有限的支持。</li><li>延续字(2字节)、双字(4字节)和四字(8字节)的命名惯例，Intel 把16字节的数称为八字(oct word)。</li></ul><table><thead><tr><th style="text-align:center">Instruction</th><th style="text-align:center">Effect</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">imulq S</td><td style="text-align:center">R[%rdx]:R[%rax] ← S × R[%rax]</td><td style="text-align:center">Signed full multiply</td></tr><tr><td style="text-align:center">mulq S</td><td style="text-align:center">R[%rdx]:R[%rax] ← S × R[%rax]</td><td style="text-align:center">Unsigned full multiply</td></tr><tr><td style="text-align:center">cqto</td><td style="text-align:center">R[%rdx]:R[%rax] ← SignExtend(R[%rax])</td><td style="text-align:center">Convert to oct word</td></tr><tr><td style="text-align:center">idivq S</td><td style="text-align:center">R[%rdx] ← R[%rdx]:R[%rax] mod S;<br>R[%rax] ← R[%rdx]:R[%rax] ÷ S</td><td style="text-align:center">Signed divide</td></tr><tr><td style="text-align:center">divq S</td><td style="text-align:center">R[%rdx] ← R[%rdx]:R[%rax] mod S;<br>R[%rax] ← R[%rdx]:R[%rax] ÷ S</td><td style="text-align:center">Unsigned divide</td></tr></tbody></table><h1 id="控制">控制</h1><h2 id="条件码">条件码</h2><ul><li>cf: 进位标志：最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。<ul><li>(unsigned) t &lt; (unsigned) a</li><li>Unsigned overflow</li></ul></li><li>zf: 零标志：最近的操作得出的结果为 0，如果两个操作数相等，零标志设置为 1<ul><li>(t == 0)</li><li>Zero</li></ul></li><li>sf: 符号标志：最近的操作得到的结果为负数<ul><li>(t &lt; 0)</li><li>Negative</li></ul></li><li>of: 溢出标志：最近的操作导致一个补码溢出–正溢出或负溢出<ul><li>(a &lt; 0 == b &lt; 0) &amp;&amp; (t &lt; 0 ! = a &lt; 0)</li><li>Signed overflow</li></ul></li></ul><h2 id="访问条件码">访问条件码</h2><p>条件码通常不会直接读取，常见使用方式：</p><ol><li>可以根据条件码的某种组合，将一个字节设置为 0 或 1</li><li>可以条件跳转到程序的某个其他的部分</li><li>可以有条件地传送数据</li></ol><p><img src="../../../static/CSAPP/cp3/f3.14set.png" alt=""></p><h2 id="跳转指令">跳转指令</h2><p><img src="../../../static/CSAPP/cp3/f3.15jmp.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  movq	%rdi, %rax</span><br><span class="line">  jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">  sarq	%rax</span><br><span class="line">.L2:</span><br><span class="line">  testq	%rax, %rax</span><br><span class="line">  jg	.L3</span><br><span class="line">  rep; ret</span><br></pre></td></tr></table></figure><p>汇编器产生的“. o”格式的反汇编版本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:	48 89 f8	mov	%rdi,%rax</span><br><span class="line">3:	eb 03		jmp	8 &lt;loop+0x8&gt;</span><br><span class="line">5:	48 d1 f8	sar	%rax</span><br><span class="line">8:	48 85 c0	test	%rax,%rax</span><br><span class="line">b:	7f f8		jg	5 &lt;loop+0x5&gt;</span><br><span class="line">d:	f3 c3		repz retq</span><br></pre></td></tr></table></figure><p>链接后的程序反汇编版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4004d0: 48 89 f8	mov %rdi,%rax</span><br><span class="line">4004d3: eb 03		jmp 4004d8 &lt;loop+0x8&gt;</span><br><span class="line">4004d5: 48 d1 f8	sar %rax</span><br><span class="line">4004d8: 48 85 c0	test %rax,%rax</span><br><span class="line">4004db: 7f f8		jg 4004d5 &lt;loop+0x5&gt;</span><br><span class="line">4004dd: f3 c3		repz retq</span><br></pre></td></tr></table></figure><h2 id="条件控制实现条件分支">条件控制实现条件分支</h2><p>goto 风格代码与汇编代码实现条件控制时非常相似</p><p>c 语言中 if-else 语句的通用形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test-expr)</span><br><span class="line">	then-statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure><p>Goto 风格代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	t = text-expr;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">		<span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">	then-statement</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">else</span>-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>其中的 goto 在汇编中为 jmp 指令</p><h3 id="练习">练习</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">  <span class="type">long</span> val = x + y + z;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">-3</span>) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (y &lt; z)</span><br><span class="line">  		val = x * y;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  		val = y * z;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">2</span>)</span><br><span class="line">	  	val = x * z;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc 产生如下汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">long test(long x, long y, long z)</span><br><span class="line">x in %rdi, y in %rsi, z in %rdx</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">leaq	(%rdi,%rsi), %rax</span><br><span class="line">addq	%rdx, %rax</span><br><span class="line">cmpq	$-3, %rdi</span><br><span class="line">jge	.L2</span><br><span class="line">cmpq	%rdx, %rsi</span><br><span class="line">jge	.L3</span><br><span class="line">movq	%rdi, %rax</span><br><span class="line">imulq	%rsi, %rax</span><br><span class="line">ret</span><br><span class="line">.L3:</span><br><span class="line">movq	%rsi, %rax</span><br><span class="line">imulq	%rdx, %rax</span><br><span class="line">ret</span><br><span class="line">.L2:</span><br><span class="line">cmpq	$2, %rdi</span><br><span class="line">jle	.L4</span><br><span class="line">movq	%rdi, %rax</span><br><span class="line">imulq	%rdx, %rax</span><br><span class="line">.L4:</span><br><span class="line">rep; ret</span><br></pre></td></tr></table></figure><h2 id="条件传送实现条件分支">条件传送实现条件分支</h2><p>条件操作的传统方式简单而通用，但在现代处理器上可能会非常低效。</p><p><img src="../../../static/CSAPP/cp3/f3.18cmov.png" alt=""></p><p>条件传送指令。当传送条件满足时，指令把源值 S 复制到目的 R</p><p>同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。<strong>但不是所有情况下都可以使用条件传送。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = test-expr ? then-expr : <span class="keyword">else</span>-expr</span><br></pre></td></tr></table></figure><p>用条件控制转移的标准方法编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!test-expr)</span><br><span class="line">  	<span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">  v = then-expr;</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">  v = <span class="keyword">else</span>-expr;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>基于条件传送代码会对两数都求值，可以用下面的抽象代码描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = then-expr;</span><br><span class="line">ve = <span class="keyword">else</span>-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t) v = ve;</span><br></pre></td></tr></table></figure><ul><li>GCC 只有在两个表达式都很容易计算时，例如表达式分别都是一条加法指令，它才会使用条件传送。</li><li>即使许多分支预测错误的开销会超过更复杂的计算，GCC 还是会使用条件控制转移。</li><li>条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的情况。</li></ul><h2 id="循环">循环</h2><h3 id="while-循环">while 循环</h3><p>C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		result *= n;</span><br><span class="line">		n = n<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Goto version</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while_jm_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">	result *= n;</span><br><span class="line">	n = n<span class="number">-1</span>;</span><br><span class="line">test:</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">goto</span> loop;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assembly-language code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">long fact_while(long n)</span><br><span class="line">n in %rdi</span><br><span class="line"></span><br><span class="line">fact_while:</span><br><span class="line">  movl	$1, %eax	         Set result = 1</span><br><span class="line">  jmp	.L5		             Goto test</span><br><span class="line">.L6:		             loop:</span><br><span class="line">  imulq	%rdi, %rax	         Compute result *= n</span><br><span class="line">  subq	$1, %rdi	         Decrement n</span><br><span class="line">.L5:		             test:</span><br><span class="line">  cmpq	$1, %rdi	         Compare n:1</span><br><span class="line">  jg	.L6		             If &gt;, goto loop</span><br><span class="line">  rep; ret		             Return</span><br></pre></td></tr></table></figure><h3 id="Guarded-do-翻译方法">Guarded-do 翻译方法</h3><ul><li>首先使用条件分支</li><li>如果初始条件不成立就跳过循环，把代码变换为 do-while 循环。</li><li>当使用较高优化等级时，例如使用命令行选项 <code>-O1</code> 时，GCC 会采用这种策略。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	body-statement</span><br><span class="line">	<span class="title function_">while</span> <span class="params">(test-expr)</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>Goto version</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">	<span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h1 id="过程">过程</h1><h2 id="运行时栈">运行时栈</h2><p><img src="../../../static/CSAPP/cp3/f3.25stack%20frame.png" alt=""></p><ul><li>通用的栈帧结构</li><li>栈用来传递参数、存储返回信息、保持寄存器，以及局部存储</li><li>为了提高空间和时间效率，<code>x86-64</code> 过程只分配自己所需要的栈帧部分</li><li>许多过程有 6 个或者更少的参数，那么所有的参数都可以通过寄存器传递</li><li>实际上，许多函数甚至根本不需要栈帧</li><li>当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，就可以这样处理。</li></ul><h3 id="练习-v2">练习</h3><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	Disassembly of leaf(long y)</span><br><span class="line">	y in %rdi</span><br><span class="line">1	0000000000400540 &lt;leaf&gt;:</span><br><span class="line">2	400540:	48 8d 47 02	lea	0x2(%rdi),%rax	L1: z+2</span><br><span class="line">3	400544:	c3		retq			L2: Return</span><br><span class="line"></span><br><span class="line">4	0000000000400545 &lt;top&gt;:</span><br><span class="line">	Disassembly of top(long x)</span><br><span class="line">	x in %rdi</span><br><span class="line">5	400545:	48 83 ef 05	 sub	$0x5,%rdi	T1: x-5</span><br><span class="line">6	400549: e8 f2 ff ff ff	callq   400540 &lt;leaf&gt;	T2: Call leaf(x-5)</span><br><span class="line">7	40054e: 4801c0		add	%rax,%rax	T3: Double result</span><br><span class="line">8	400551:c3		retq			T4: Return</span><br><span class="line">	...</span><br><span class="line">	Call to top from function main</span><br><span class="line">9	40055b: e8 e5 ff ff ff	callq	400545 &lt;top&gt;	M1: Call top(100)</span><br><span class="line">10	400560: 4889c2		mov	%rax,%rdx	M2: Resume</span><br></pre></td></tr></table></figure><p>代码执行过程表：</p><p><img src="../../../static/CSAPP/cp3/f3.27.png" alt=""></p><h2 id="数据传送">数据传送</h2><p>函数传参少于等于六个时的寄存器：</p><p><img src="../../../static/CSAPP/cp3/f3.28passing%20arguments.png" alt=""></p><ul><li>大于六个的部分使用栈传递</li><li>7~n 放到栈上，而参数 7 位于栈顶</li></ul><h3 id="例如">例如</h3><p>C code</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span> a1, <span class="type">long</span> *a1p,</span></span><br><span class="line"><span class="params">	  <span class="type">int</span> a2, <span class="type">int</span> *a2p,</span></span><br><span class="line"><span class="params">	  <span class="type">short</span> a3, <span class="type">short</span> *a3p,</span></span><br><span class="line"><span class="params">	  <span class="type">char</span> a4, <span class="type">char</span> *a4p)</span></span><br><span class="line">&#123;</span><br><span class="line">	*a1p += a1;</span><br><span class="line">	*a2p += a2;</span><br><span class="line">	*a3p += a3;</span><br><span class="line">	*a4p += a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Assembly code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	void proc(a1, a1p, a2, a2p, a3, a3p, a4, a4p)</span><br><span class="line">	Arguments passed as follows:</span><br><span class="line">	  a1 in %rdi (64 bits)</span><br><span class="line">	  a1p in %rsi (64 bits)</span><br><span class="line">	  a2 in %edx (32 bits)</span><br><span class="line">	  a2p in %rcx (64 bits)</span><br><span class="line">	  a3 in %r8w (16 bits)</span><br><span class="line">	  a3p in %r9 (64 bits)</span><br><span class="line">	  a4 at %rsp+8 ( 8 bits)</span><br><span class="line">	  a4p at %rsp+16 (64 bits)</span><br><span class="line">1	proc:</span><br><span class="line">2	movq	16(%rsp), %rax	Fetch a4p (64 bits)</span><br><span class="line">3	addq	%rdi, (%rsi)	*a1p += a1 (64 bits)</span><br><span class="line">4	addl	%edx, (%rcx)	*a2p += a2 (32 bits)</span><br><span class="line">5	addw	%r8w, (%r9)	*a3p += a3 (16 bits)</span><br><span class="line">6	movl	8(%rsp), %edx	Fetch a4 (8 bits)</span><br><span class="line">7	addb	%dl, (%rax)	*a4p += a4 (8 bits)</span><br><span class="line">8	ret			Return</span><br></pre></td></tr></table></figure><p>超出六个部分的栈帧结构：</p><p><img src="../../../static/CSAPP/cp3/f3.30stack%20frame.png" alt=""></p><h2 id="寄存器中的局部存储空间">寄存器中的局部存储空间</h2><p>x86-64采用统一的寄存器使用管理：</p><ul><li>寄存器 %rbx、%rbp 和 %r12 ~ %r15 被划分为<strong>被调用者保存寄存器</strong></li><li>P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证他们的值在 Q 返回到 P 时与 Q 被调用时是一样的</li><li>Q 为了保存一个寄存器的值不变<ul><li>要么不改变它</li><li>要么把原始的值压入栈中，改变寄存器的值，在返回前从栈中弹出旧值</li><li>压入寄存器的值会在栈帧中创建标号为“被保存的寄存器”的一部分</li></ul></li><li>所有其他的寄存器，除了栈指针 %rsp ，都分类为<strong>调用者保存寄存器</strong><ul><li>这意味着任何函数都能修改他们</li><li>调用之前首先保存好这个数据是调用者 (P) 的责任</li></ul></li></ul><h1 id="数组分配和访问">数组分配和访问</h1><h2 id="嵌套的数组">嵌套的数组</h2><p><code>int A[5][3]</code> 等价于 <code>typedef int row3_t[3]; row3_t A[5];</code></p><p><img src="../../../static/CSAPP/cp3/f3.36row-major.png" alt=""></p><p>将数组 <code>A[i][j]</code> 复制到寄存器 %eax 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	A in %rdi, i in %rsi, and j in %rdx</span><br><span class="line">1	leaq	(%rsi,%rsi,2), %rax		Compute 3i</span><br><span class="line">2	leaq	(%rdi,%rax,4), %rax		Compute xA + 12i</span><br><span class="line">3	movl	(%rax,%rdx,4), %eax		Read from M[xA + 12i + 4]</span><br></pre></td></tr></table></figure><h3 id="练习-v3">练习</h3><p>C code</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set all diagonal elements to val */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fix_set_diag</span><span class="params">(fix_matrix A, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">	<span class="type">long</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	  A[i][i] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Optimization assembly code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fix_set_diag:</span><br><span class="line">void fix_set_diag(fix_matrix A, int val)</span><br><span class="line">A in %rdi, val in %rsi</span><br><span class="line"></span><br><span class="line">	movl	$0, %eax</span><br><span class="line">.L13:</span><br><span class="line">	movl	%esi, (%rdi,%rax)</span><br><span class="line">	addq	$68, %rax</span><br><span class="line">	cmpq	$1088, %rax</span><br><span class="line">	jne	.L13</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure><p>Optimization c code</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set all diagonal elements to val */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fix_set_diag_opt</span><span class="params">(fix_matrix A, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">	<span class="type">int</span> *Abase = &amp;A[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> iend = N * (N + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		Abase[i] = val;</span><br><span class="line">		i += (N + <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (i != iend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>达到下一个对角线元素的地址恰好为 <code>i += (N + 1)</code></p><h2 id="变长数组">变长数组</h2><ul><li>在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算。</li><li>如果允许使用优化，GCC 能够识别出程序访问多维数组的元素的步长。</li><li>生成的代码会避免直接应用规律等式会导致的乘法。</li><li>无论生成基于指针的代码还是基于数组的代码，这些优化都能显著提高程序的性能。</li></ul><h1 id="异质的数据结构">异质的数据结构</h1><h2 id="结构-struct">结构 struct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应在内存中为：</p><p><img src="../../../static/CSAPP/cp3/struct.png" alt=""></p><h2 id="联合-union">联合 union</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">	<span class="type">double</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U3</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">	<span class="type">double</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应在内存中为：</p><p><img src="../../../static/CSAPP/cp3/union.png" alt=""></p><ul><li>一个 union 的总的大小等于它最大字段的大小</li><li>它会绕过 C 语言类型系统提供的安全措施</li><li>已知一个数据结构中两个不同字段的使用是互斥的，若将这两个字段声明为 union 的一部分，而不作为 struct 的一部分，会减少分配空间的总量</li></ul><h3 id="例一">例一</h3><p>二叉树数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">right</span>;</span></span><br><span class="line">	<span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>一个节点需要 32 个字节</li></ul><p>改为 union：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">node_u</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	  <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">left</span>;</span></span><br><span class="line">	  <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">right</span>;</span></span><br><span class="line">	&#125; internal;</span><br><span class="line">	<span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>一个节点只需要 16 个字节</li><li>但这样编码没法确定一个给定的节点是叶子节点还是内部节点<ul><li>可以通过引入一个枚举类型，定义这个 union 中可能的不同选择，然后再创建一个结构</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> N_LEAF, N_INTERNAL &#125; <span class="type">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span></span><br><span class="line">	<span class="type">nodetype_t</span> type;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	  	<span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">left</span>;</span></span><br><span class="line">	  	<span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">right</span>;</span></span><br><span class="line">	  &#125; internal;</span><br><span class="line">	  <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">	&#125; info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>这个结构总共需要 24 个字节<ul><li>type 是 4 个字节</li><li><code>info.internal.left</code> 和 <code>info.internal.right</code> 各要 8 个字节</li><li><code>info.data</code> 要 16 个字节</li><li>在字段 type 和 union 的元素之间需要 4 个字节的填充</li></ul></li><li>过于麻烦带来的收益较小，但是对于较多字段的数据结构还是很吸引人的</li></ul><h2 id="数据对齐">数据对齐</h2><ul><li>许多系统对基本数据类型的合法地址作出限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4 或 8)的倍数</li><li>目的是提高内存系统的性能<ul><li>假设一个处理器总是从内存中取 8 个字节，则地址必须是 8 的倍数</li><li>如果我们能保证将所有的 double 类型数据的地址都对齐成 8 的倍数，那么就可以只用一个内存操作来读或写值了</li><li>否则可能需要执行两次内存访问，因为对象被分放在两个 8 字节内存块中</li></ul></li><li>汇编命令 <code>.align 8</code> 代表后面每个元素都会遵守 8 字节对齐的限制</li></ul><p>例如考虑下列 struct 声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设用最小的 9 字节分配：</p><p><img src="../../../static/CSAPP/cp3/align1.png" alt=""></p><p>对齐之后：</p><p><img src="../../../static/CSAPP/cp3/align2.png" alt=""></p><p>向后补齐的例子：</p><p><img src="../../../static/CSAPP/cp3/align3.png" alt=""></p><h1 id="在机器级程序中将控制与数据结合起来">在机器级程序中将控制与数据结合起来</h1><h2 id="内存越界引用和缓冲区溢出">内存越界引用和缓冲区溢出</h2><p>库函数 <code>gets</code> 的一个实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Implementation of library function gets() */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">char</span> *dest = s;</span><br><span class="line">	<span class="keyword">while</span> ((c = getchar()) != `n<span class="number">&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">		*dest++ = c;</span><br><span class="line">	<span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">		<span class="comment">/* No characters read */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	*dest++ = `<span class="number">0&#x27;</span>; <span class="comment">/* Terminate string */</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Read input line and write it back */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">	gets(buf);</span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void echo()</span><br><span class="line">echo:</span><br><span class="line">subq	$24, %rsp	Allocate 24 bytes on stack</span><br><span class="line">movq	%rsp, %rdi	Compute buf as %rsp</span><br><span class="line">call	gets		Call gets</span><br><span class="line">movq	%rsp, %rdi	Compute buf as %rsp</span><br><span class="line">call	puts		Call puts</span><br><span class="line">addq	$24, %rsp	Deallocate stack space</span><br><span class="line">ret			Return</span><br></pre></td></tr></table></figure><p>echo 函数的栈组织：</p><p><img src="../../../static/CSAPP/cp3/f3.40echo.png" alt=""></p><p>存在以下问题：</p><table><thead><tr><th style="text-align:center">Characters typed</th><th style="text-align:center">Additional corrupted state</th></tr></thead><tbody><tr><td style="text-align:center">0–7</td><td style="text-align:center">None</td></tr><tr><td style="text-align:center">9–23</td><td style="text-align:center">Unused stack space</td></tr><tr><td style="text-align:center">24–31</td><td style="text-align:center">Return address</td></tr><tr><td style="text-align:center">32+</td><td style="text-align:center">Saved state in caller</td></tr></tbody></table><h2 id="对抗缓冲区溢出攻击">对抗缓冲区溢出攻击</h2><h3 id="栈随机化">栈随机化</h3><ul><li>使得栈的位置在程序每次运行时都有变化，即使不同的机器运行相同的代码，栈地址都是不同的</li><li>在 linux 系统中，有一个技术：<code>地址空间布局随机化</code>，简称 ASLR<ul><li>每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域</li></ul></li><li>空操作雪橇 (nop sled)<ul><li>执着的攻击者用蛮力克服随机化，反复的用不同的地址进行攻击</li><li>在实际攻击代码之前插入很长一段 nop 指令，不停的对程序计数器加一，直到找到序列中的某个地址，程序就会经过这个序列到达攻击代码。</li><li>但是在 64 位系统的出现，进行攻击需要尝试枚举更多更长的地址，大大降低了病毒或者蠕虫的传播速度</li></ul></li></ul><h3 id="栈破坏检测">栈破坏检测</h3><ul><li>金丝雀<ul><li>在栈帧中的任何局部缓冲区与栈状态之间存储一个特殊的值</li><li>在程序每次运行时随机产生</li></ul></li></ul><h3 id="限制可执行代码区域">限制可执行代码区域</h3><h1 id="浮点代码">浮点代码</h1><h2 id="媒体-media-指令">媒体 (media) 指令</h2><ul><li>这些指令的本意是允许多个操作以并行模式执行，称为单指令多数据或 SIMD<ul><li>这种模式中，对多个不同的数据并行执行同一个操作</li></ul></li><li>最早出现的是 MMX ，然后从 MMX 到 SSE (streaming SIMD extensions 流式 SIMD 扩展)，以及最新的 AVX (advanced vector extensions 高级向量扩展)</li><li>每个扩展都是管理寄存器组中的数据<ul><li>MMX 中称为 “MM” 寄存器 (64 位)</li><li>SSE 中称为 “XMM” 寄存器 (128 位)</li><li>AVX 中称为 “YMM” 寄存器 (256 位)</li><li>所以每个 YMM 寄存器可以存放 8 个 32 位值，或 4 个 64 位值，这些值可以是整数或者浮点数</li></ul></li><li>当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位 (对于 float) 或 64 位 (对于 double)</li></ul><p><img src="../../../static/CSAPP/cp3/f3.45Media%20registers.png" alt=""></p><h2 id="浮点传送和转换操作">浮点传送和转换操作</h2><ul><li>引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作</li><li>建议 32 位内存数据满足 4 字节对齐，64 位满足 8 字节对齐</li></ul><p><img src="../../../static/CSAPP/cp3/f3.46Floating-point%20movement%20instructions.png" alt=""></p><ul><li>浮点传送指令。X: XMM 寄存器，M32: 32-bit memory range; M64: 64-bit memory range</li><li>对于在两个 XMM 寄存器之间传送数据，GCC 会使用上图倒数两种指令之一<ul><li>这种情况，程序复制整个寄存器还是只复制低位值既不会影响程序功能也不会影响执行速度</li><li>所以使用这些指令还是针对标量数据的指令没有实质上的差别</li></ul></li><li>字母 a 表示 “aligned (对齐的)”</li><li>当用于读写内存时，如果地址不满足 16 字节对齐，它们会导致异常</li><li>但在两个寄存器之间传送数据，绝对不会出现错误对齐的情况</li></ul><p><img src="../../../static/CSAPP/cp3/f3.47Two-operand%20floating-point%20conversion%20operations.png" alt=""></p><ul><li>这些操作将浮点数转换成整数</li></ul><p><img src="../../../static/CSAPP/cp3/f3.48Three-operand%20floating-point%20conversion%20operations.png" alt=""></p><ul><li>第一个源的数据类型转换成目的的数据类型，它读自内存或一个通用的目的寄存器</li><li>第二个源值只会影响结果的高位字节，可以忽略</li><li>目标必须是 XMM 寄存器</li><li>最常见的使用场景中，第二个源和目的操作数都是一样的<ul><li>例如：<code>vcvtsi2sdq	%rax, %xmm1, %xmm1</code></li><li>它从 %rax 中读出一个长整数，转换为数据类型 double，最后把结果放进 XMM 寄存器 %xmm1 的低字节中</li></ul></li></ul><p><code>vunpcklps</code> 指令通常用来交叉放置来自两个 XMM 寄存器的值，把他们存储到第三个寄存器中。若一个源寄存器的内容为字 <code>[s3, s2, s1, s0]</code> ，另一个源寄存器的内容 <code>[d3, d2, d1, d0]</code>，那么目的寄存器的值会是 <code>[s1, d1, s0, d0]</code> 。</p><h3 id="例子">例子</h3><p>c code</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fcvt</span><span class="params">(<span class="type">int</span> i, <span class="type">float</span> *fp, <span class="type">double</span> *dp, <span class="type">long</span> *lp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> f = *fp; <span class="type">double</span> d = *dp; <span class="type">long</span> l = *lp;</span><br><span class="line">	*lp = (<span class="type">long</span>) d;</span><br><span class="line">	*fp = (<span class="type">float</span>) i;</span><br><span class="line">	*dp = (<span class="type">double</span>) l;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">double</span>) f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x86-64 assembly code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">double fcvt(int i, float *fp, double *dp, long *lp)</span><br><span class="line">	i in %edi, fp in %rsi, dp in %rdx, lp in %rcx</span><br><span class="line">fcvt:</span><br><span class="line"> vmovss	(%rsi), %xmm0			Get f = *fp</span><br><span class="line"> movq	(%rcx), %rax			Get l = *lp</span><br><span class="line"> vcvttsd2siq	(%rdx), %r8		Get d = *dp and convert to long</span><br><span class="line"> movq	%r8, (%rcx)			Store at lp</span><br><span class="line"> vcvtsi2ss	%edi, %xmm1, %xmm1	Convert i to float</span><br><span class="line"> vmovss	%xmm1, (%rsi)			Store at fp</span><br><span class="line"> vcvtsi2sdq	%rax, %xmm1, %xmm1	Convert l to double</span><br><span class="line"> vmovsd	%xmm1, (%rdx)			Store at dp</span><br><span class="line">The following two instructions convert f to double</span><br><span class="line"> vunpcklps	%xmm0, %xmm0, %xmm0</span><br><span class="line"> vcvtps2pd	%xmm0, %xmm0</span><br><span class="line"> ret					Return f</span><br></pre></td></tr></table></figure><h2 id="浮点数操作">浮点数操作</h2><p><img src="../../../static/CSAPP/cp3/f3.49Scalar%20floating-point%20arithmetic%20operations.png" alt=""></p><ul><li>S1 可以是一个 XMM 寄存器或一个内存位置</li><li>S2 和 D 必须都是 XMM 寄存器</li></ul><h3 id="例子-v2">例子</h3><p>assembly code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double funct2(double w, int x, float y, long z)</span><br><span class="line">w in %xmm0, x in %edi, y in %xmm1, z in %rsi</span><br><span class="line"></span><br><span class="line">funct2:</span><br><span class="line">  vcvtsi2ss	%edi, %xmm2, %xmm2</span><br><span class="line">  vmulss	%xmm1, %xmm2, %xmm1</span><br><span class="line">  vunpcklps	%xmm1, %xmm1, %xmm1</span><br><span class="line">  vcvtps2pd	%xmm1, %xmm2</span><br><span class="line">  vcvtsi2sdq	%rsi, %xmm1, %xmm1</span><br><span class="line">  vdivsd	%xmm1, %xmm0, %xmm0</span><br><span class="line">  vsubsd	%xmm0, %xmm2, %xmm0</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>转换以上汇编代码为 c 语言版本：<code>y * x - w / z</code></p><h2 id="定义和使用浮点常数">定义和使用浮点常数</h2><ul><li>和整数运算操作不同，AVX 浮点操作不能以立即数值作为操作数</li><li>编译器必须为所有的常量值分配和初始化存储空间，然后代码再把这些值从内存读入</li></ul><h3 id="例子-v3">例子</h3><p>c code</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">cel2fahr</span><span class="params">(<span class="type">double</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.8</span> * temp + <span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assembly code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double cel2fahr(double temp) temp in %xmm0</span><br><span class="line">cel2fahr:</span><br><span class="line">  vmulsd	.LC2(%rip), %xmm0, %xmm0	Multiply by 1.8</span><br><span class="line">  vaddsd	.LC3(%rip), %xmm0, %xmm0	Add 32.0</span><br><span class="line">  ret</span><br><span class="line">.LC2:</span><br><span class="line">  .long	3435973837				Low-order 4 bytes of 1.8</span><br><span class="line">  .long	1073532108				High-order 4 bytes of 1.8</span><br><span class="line">.LC3:</span><br><span class="line">  .long	0					Low-order 4 bytes of 32.0</span><br><span class="line">  .long	1077936128				High-order 4 bytes of 32.0</span><br></pre></td></tr></table></figure><h2 id="位级操作">位级操作</h2><p><img src="../../../static/CSAPP/cp3/f3.50Bitwise%20operations.png" alt=""></p><h2 id="比较操作">比较操作</h2><p><img src="../../../static/CSAPP/cp3/f3.11.6.png" alt=""></p><ul><li>S1 可以在 XMM 寄存器中也可以在内存中</li><li>S2 必须在 XMM 寄存器中</li></ul><p><img src="../../../static/CSAPP/cp3/f3.11.6condition%20codes.png" alt=""></p><ul><li>浮点比较指令会设置三个条件码：<ul><li>零标志位 <code>ZF</code></li><li>进位标志位 <code>CF</code></li><li>奇偶标志位 <code>PF</code><ul><li>当两个操作数中人一个是 NaN 时就会设置该位</li></ul></li></ul></li><li>当任意操作数为 NaN，就会出现 <code>Unordered</code> 情况</li></ul></div><div class="article-licensing box"><div class="licensing-title"><p>cp3 程序的机器级表示</p><p><a href="https://tomatoblog.netlify.app/Study/csapp/cp3/">https://tomatoblog.netlify.app/Study/csapp/cp3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TOMATO</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-04-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-05-19</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/csapp/">csapp</a></div></article></div><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Study/dataStruct/Hash-Table/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Hash Table</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Study/live/coffee-magic/"><span class="level-item">coffee magic</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div></div><style>.column.column-left,.column.column-right{display:none}</style><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/static/avatar.jpg" alt="ToMaTo"></figure><p class="title is-size-4 is-block" style="line-height:inherit">ToMaTo</p><p class="is-size-6 is-block">Back-end Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>GuangZhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">59</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/dontSerious/" target="_blank" rel="noopener" id="widget-follow">Github</a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">2024年04月</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">2024年03月</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">2024年02月</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">2023年12月</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">2023年11月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">2023年10月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">2023年09月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">2023年08月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">2023年06月</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">2023年05月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">2023年04月</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">2023年03月</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">2023年02月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-04-28T10:24:18.000Z">2024-04-28</time></p><p class="title"><a href="/FrontEnd/Flutter/">flutter 笔记</a></p><p class="categories"><a href="/categories/FrontEnd/">FrontEnd</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T06:43:15.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/go/">go面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T02:10:11.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/datastruct/">数据结构和算法面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T02:10:11.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/distributed/">分布式面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-16T07:28:10.000Z">2024-03-16</time></p><p class="title"><a href="/BackEnd/sql/index/">SQL 索引</a></p><p class="categories"><a href="/categories/BackEnd/">BackEnd</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#名词"><span class="level-left"><span class="level-item">1</span><span class="level-item">名词</span></span></a></li><li><a class="level is-mobile" href="#gcc"><span class="level-left"><span class="level-item">2</span><span class="level-item">gcc</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#参数"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">参数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#优化等级"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">优化等级</span></span></a></li><li><a class="level is-mobile" href="#汇编代码"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">汇编代码</span></span></a></li><li><a class="level is-mobile" href="#目标代码"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">目标代码</span></span></a></li><li><a class="level is-mobile" href="#可执行代码"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">可执行代码</span></span></a></li><li><a class="level is-mobile" href="#反汇编器"><span class="level-left"><span class="level-item">2.1.5</span><span class="level-item">反汇编器</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#数据格式"><span class="level-left"><span class="level-item">3</span><span class="level-item">数据格式</span></span></a></li><li><a class="level is-mobile" href="#访问信息"><span class="level-left"><span class="level-item">4</span><span class="level-item">访问信息</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#操作数指示符"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">操作数指示符</span></span></a></li><li><a class="level is-mobile" href="#数据传送指令"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">数据传送指令</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简单的数据传送指令"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">简单的数据传送指令</span></span></a></li><li><a class="level is-mobile" href="#零扩展数据传送指令"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">零扩展数据传送指令</span></span></a></li><li><a class="level is-mobile" href="#符号扩展数据传送指令"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">符号扩展数据传送指令</span></span></a></li></ul></li><li><a class="level is-mobile" href="#压入和弹出栈数据"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">压入和弹出栈数据</span></span></a></li></ul></li><li><a class="level is-mobile" href="#算数和逻辑操作"><span class="level-left"><span class="level-item">5</span><span class="level-item">算数和逻辑操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#加载有效地址-leaq"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">加载有效地址(leaq)</span></span></a></li><li><a class="level is-mobile" href="#二元操作"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">二元操作</span></span></a></li><li><a class="level is-mobile" href="#移位操作-SA"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">移位操作 SA</span></span></a></li><li><a class="level is-mobile" href="#xorq-rdx-rdx"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">xorq %rdx,%rdx</span></span></a></li><li><a class="level is-mobile" href="#特殊的算术操作"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">特殊的算术操作</span></span></a></li></ul></li><li><a class="level is-mobile" href="#控制"><span class="level-left"><span class="level-item">6</span><span class="level-item">控制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#条件码"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">条件码</span></span></a></li><li><a class="level is-mobile" href="#访问条件码"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">访问条件码</span></span></a></li><li><a class="level is-mobile" href="#跳转指令"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">跳转指令</span></span></a></li><li><a class="level is-mobile" href="#条件控制实现条件分支"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">条件控制实现条件分支</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#练习"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">练习</span></span></a></li></ul></li><li><a class="level is-mobile" href="#条件传送实现条件分支"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">条件传送实现条件分支</span></span></a></li><li><a class="level is-mobile" href="#循环"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">循环</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#while-循环"><span class="level-left"><span class="level-item">6.6.1</span><span class="level-item">while 循环</span></span></a></li><li><a class="level is-mobile" href="#Guarded-do-翻译方法"><span class="level-left"><span class="level-item">6.6.2</span><span class="level-item">Guarded-do 翻译方法</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#过程"><span class="level-left"><span class="level-item">7</span><span class="level-item">过程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#运行时栈"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">运行时栈</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#练习-v2"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">练习</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据传送"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">数据传送</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#例如"><span class="level-left"><span class="level-item">7.2.1</span><span class="level-item">例如</span></span></a></li></ul></li><li><a class="level is-mobile" href="#寄存器中的局部存储空间"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">寄存器中的局部存储空间</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数组分配和访问"><span class="level-left"><span class="level-item">8</span><span class="level-item">数组分配和访问</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#嵌套的数组"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">嵌套的数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#练习-v3"><span class="level-left"><span class="level-item">8.1.1</span><span class="level-item">练习</span></span></a></li></ul></li><li><a class="level is-mobile" href="#变长数组"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">变长数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#异质的数据结构"><span class="level-left"><span class="level-item">9</span><span class="level-item">异质的数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#结构-struct"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">结构 struct</span></span></a></li><li><a class="level is-mobile" href="#联合-union"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">联合 union</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#例一"><span class="level-left"><span class="level-item">9.2.1</span><span class="level-item">例一</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据对齐"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">数据对齐</span></span></a></li></ul></li><li><a class="level is-mobile" href="#在机器级程序中将控制与数据结合起来"><span class="level-left"><span class="level-item">10</span><span class="level-item">在机器级程序中将控制与数据结合起来</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存越界引用和缓冲区溢出"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">内存越界引用和缓冲区溢出</span></span></a></li><li><a class="level is-mobile" href="#对抗缓冲区溢出攻击"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">对抗缓冲区溢出攻击</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#栈随机化"><span class="level-left"><span class="level-item">10.2.1</span><span class="level-item">栈随机化</span></span></a></li><li><a class="level is-mobile" href="#栈破坏检测"><span class="level-left"><span class="level-item">10.2.2</span><span class="level-item">栈破坏检测</span></span></a></li><li><a class="level is-mobile" href="#限制可执行代码区域"><span class="level-left"><span class="level-item">10.2.3</span><span class="level-item">限制可执行代码区域</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#浮点代码"><span class="level-left"><span class="level-item">11</span><span class="level-item">浮点代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#媒体-media-指令"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">媒体 (media) 指令</span></span></a></li><li><a class="level is-mobile" href="#浮点传送和转换操作"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">浮点传送和转换操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#例子"><span class="level-left"><span class="level-item">11.2.1</span><span class="level-item">例子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#浮点数操作"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">浮点数操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#例子-v2"><span class="level-left"><span class="level-item">11.3.1</span><span class="level-item">例子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#定义和使用浮点常数"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">定义和使用浮点常数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#例子-v3"><span class="level-left"><span class="level-item">11.4.1</span><span class="level-item">例子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#位级操作"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">位级操作</span></span></a></li><li><a class="level is-mobile" href="#比较操作"><span class="level-left"><span class="level-item">11.6</span><span class="level-item">比较操作</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/BackEnd/"><span class="level-start"><span class="level-item">BackEnd</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/"><span class="level-start"><span class="level-item">Interview</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Memo/"><span class="level-start"><span class="level-item">Memo</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Study/"><span class="level-start"><span class="level-item">Study</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/Tutorial/"><span class="level-start"><span class="level-item">Tutorial</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Flutter/"><span class="tag">Flutter</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT6-S081/"><span class="tag">MIT6.S081</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue-js/"><span class="tag">Vue.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bookNote/"><span class="tag">bookNote</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/career/"><span class="tag">career</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cs/"><span class="tag">cs</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/csapp/"><span class="tag">csapp</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/curriculum/"><span class="tag">curriculum</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dataStruct/"><span class="tag">dataStruct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/datastruct/"><span class="tag">datastruct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/distributed/"><span class="tag">distributed</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/live/"><span class="tag">live</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/log/"><span class="tag">log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memo/"><span class="tag">memo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/network/"><span class="tag">network</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidian/"><span class="tag">obsidian</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/project/"><span class="tag">project</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psychology/"><span class="tag">psychology</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/simpleBank/"><span class="tag">simpleBank</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql/"><span class="tag">sql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tools/"><span class="tag">tools</span><span class="tag">10</span></a></div></div></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"><img class="logo-img-dark" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 TOMATO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/deed.zh"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="/js/imaegoo/jquery/3.3.1/dist/jquery.min.js"></script><script src="/js/imaegoo/moment/2.22.2/min/moment-with-locales.min.js"></script><script src="/js/imaegoo/clipboard/2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "此网站使用 Cookie，以启用评论系统和分析功能。",
          dismiss: "知道了",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="/js/imaegoo/lightgallery/1.10.0/dist/js/lightgallery.min.js" defer></script><script src="/js/imaegoo/justifiedGallery/3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>