<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>go grammar - Tomato&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Tomato&#039;s Blog"><meta name="msapplication-TileImage" content="static/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Tomato&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="基础语法 变量定义 12345678910var identifier [type] &amp;#x3D; value&amp;#x2F;&amp;#x2F; oridentifier :&amp;#x3D; value&amp;#x2F;&amp;#x2F; orvar (    vname1 v_type1    vname2 v_type2)var a int &amp;#x3D; 10 常量定义 1const identifier [type] &amp;#x3D; value 作为枚举使用 12345const (    Unk"><meta property="og:type" content="article"><meta property="og:title" content="go grammar"><meta property="og:url" content="https://tomatoblog.netlify.app/BackEnd/go/go-grammar/"><meta property="og:site_name" content="Tomato&#039;s Blog"><meta property="og:description" content="基础语法 变量定义 12345678910var identifier [type] &amp;#x3D; value&amp;#x2F;&amp;#x2F; oridentifier :&amp;#x3D; value&amp;#x2F;&amp;#x2F; orvar (    vname1 v_type1    vname2 v_type2)var a int &amp;#x3D; 10 常量定义 1const identifier [type] &amp;#x3D; value 作为枚举使用 12345const (    Unk"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tomatoblog.netlify.app/img/og_image.png"><meta property="article:published_time" content="2023-04-11T07:11:33.000Z"><meta property="article:modified_time" content="2024-03-26T07:08:12.000Z"><meta property="article:author" content="TOMATO"><meta property="article:tag" content="go"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tomatoblog.netlify.app/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomatoblog.netlify.app/BackEnd/go/go-grammar/"},"headline":"go grammar","image":["https://tomatoblog.netlify.app/img/og_image.png"],"datePublished":"2023-04-11T07:11:33.000Z","dateModified":"2024-03-26T07:08:12.000Z","author":{"@type":"Person","name":"TOMATO"},"publisher":{"@type":"Organization","name":"Tomato's Blog","logo":{"@type":"ImageObject","url":{"light":"static/avatar.jpg","dark":"static/avatar.jpg"}}},"description":"基础语法 变量定义 12345678910var identifier [type] &#x3D; value&#x2F;&#x2F; oridentifier :&#x3D; value&#x2F;&#x2F; orvar (    vname1 v_type1    vname2 v_type2)var a int &#x3D; 10 常量定义 1const identifier [type] &#x3D; value 作为枚举使用 12345const (    Unk"}</script><link rel="canonical" href="https://tomatoblog.netlify.app/BackEnd/go/go-grammar/"><link rel="icon" href="/static/avatar.jpg"><link rel="stylesheet" href="/css/font/fontawesome/css/all.min.css"><link rel="stylesheet" href="/js/imaegoo/highlight.js/11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="/js/imaegoo/lightgallery/1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="/js/imaegoo/justifiedGallery/3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="/js/imaegoo/pace-js/1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 7.1.1"></head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"><img class="logo-img-dark" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives/">时间轴</a><a class="navbar-item" href="/categories/">分类</a><a class="navbar-item" href="/tags/">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-04-11T07:11:33.000Z" title="4/11/2023, 7:11:33 AM">2023-04-11</time>发表</span><span class="level-item"><time datetime="2024-03-26T07:08:12.000Z" title="3/26/2024, 7:08:12 AM">2024-03-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/BackEnd/">BackEnd</a></span><span class="level-item">29 分钟读完 (大约4367个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">go grammar</h1><div class="content"><h1 id="基础语法">基础语法</h1><h2 id="变量定义">变量定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">identifier := value</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="常量定义">常量定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><p>作为枚举使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="iota">iota</h3><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。</p><p>iota 可以被用作枚举值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="用法">用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 ha ha 100 100 7 8</span><br></pre></td></tr></table></figure><h2 id="条件语句">条件语句</h2><h3 id="switch语句">switch语句</h3><p>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Type-Switch">Type Switch</h4><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)     </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)</span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select语句">select语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s)      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s)</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个case都必须是一个通信</li><li>所有channel表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行；其他被忽略。</li><li>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</li></ul><p>否则：</p><ul><li>如果有default子句，则执行该语句。</li><li>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li></ul><h2 id="循环语句">循环语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">15</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   numbers := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* for 循环 */</span></span><br><span class="line">   <span class="keyword">for</span> a := <span class="number">0</span>; a &lt; <span class="number">10</span>; a++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代替while</span></span><br><span class="line">   <span class="keyword">for</span> a &lt; b &#123;</span><br><span class="line">      a++</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数">函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types]&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包">闭包</h3><p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个&quot;内联&quot;语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="函数方法">函数方法</h3><p>设置接收者函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span></span> function_name() [return_type]&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义函数 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Area of Circle(c1) = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> getArea() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Area of Circle(c1) =  314</span><br></pre></td></tr></table></figure><h3 id="defer语句">defer语句</h3><p>Go语言中的defer语句会将其后面跟随的语句进行延迟处理</p><p>在defer所属的函数即将返回时，将延迟处理的语句按照defer定义的顺序入栈执行，即先进后出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">结束</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="数组">数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="切片">切片</h2><p>“动态数组”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以指定容量，其中capacity为可选参数。</span></span><br><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，可缺省其中一个</span></span><br><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure><h3 id="len-和-cap">len() 和 cap()</h3><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><h3 id="append-和-copy">append() 和 copy()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">len=1 cap=1 slice=[0]</span><br><span class="line">len=2 cap=2 slice=[0 1]       </span><br><span class="line">len=5 cap=6 slice=[0 1 2 3 4] </span><br><span class="line">len=5 cap=12 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure><h2 id="结构体">结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map">Map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* delete() */</span></span><br><span class="line"><span class="built_in">delete</span>(map_variable, key)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Italy&quot;</span>] = <span class="string">&quot;Rome&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Japan&quot;</span>] = <span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;India&quot;</span>] = <span class="string">&quot;New Delhi&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   capital, ok := countryCapitalMap[<span class="string">&quot;United States&quot;</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Capital of United States is&quot;</span>, capital)  </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Capital of United States is not present&quot;</span>) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Capital of United States is not present</span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><p><strong>go 不支持隐式转换类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure><h2 id="接口">接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_name1() [return_type] &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am Nokia, I can call you!</span><br><span class="line">I am iPhone, I can call you!</span><br></pre></td></tr></table></figure><h2 id="Reflect">Reflect</h2><h3 id="reflect-New"><code>reflect.New()</code></h3><ol><li><strong>指针类型的创建</strong>：<ul><li>如果原始类型是指针类型，那么在创建值时需要使用 <code>reflect.New()</code> 函数创建一个指向该类型的指针。</li><li>这是因为指针类型的值是存储变量地址的，而不是变量本身的值。如果直接创建变量的值，那么它将是零值，而不是指向原始类型的指针。</li></ul></li><li><strong>非指针类型的创建</strong>：<ul><li>如果原始类型不是指针类型，那么创建的值应该是该类型的零值。</li><li>这是因为非指针类型的值是直接存储变量的值的，而不是存储变量地址的。因此，可以直接使用 <code>reflect.New()</code> 函数创建该类型的变量，然后通过 <code>Elem()</code> 方法获取其值。</li></ul></li></ol><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> methodType <span class="keyword">struct</span> &#123;</span><br><span class="line">	method    reflect.Method</span><br><span class="line">	ArgType   reflect.Type</span><br><span class="line">	ReplyType reflect.Type</span><br><span class="line">	numCalls  <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *methodType)</span></span> newArgv() reflect.Value &#123;</span><br><span class="line">	<span class="keyword">var</span> argv reflect.Value</span><br><span class="line">	<span class="comment">//arg may be a pointer type, or a value type</span></span><br><span class="line">	<span class="keyword">if</span> m.ArgType.Kind() == reflect.Ptr &#123;</span><br><span class="line">		argv = reflect.New(m.ArgType.Elem())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		argv = reflect.New(m.ArgType).Elem()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> argv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reflect-TypeOf">Reflect.TypeOf()</h3><p>TypeOf返回接口中保存的值得类型，TypeOf(nil)会返回nil</p><h3 id="Reflect-ValueOf">Reflect.ValueOf()</h3><p>ValueOf返回一个初始化为interface接口保管的具体值得Value，ValueOf(nil)返回Value零值</p><h1 id="并发">并发</h1><h2 id="goroutine">goroutine</h2><p><strong>goroutine的调度是随机的</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>创建线程之后需要一段时间让线程执行：</p><ul><li>time.sleep()睡眠一会</li><li>sync.WaitGroup</li></ul><h3 id="sync-WaitGroup">sync.WaitGroup</h3><p>当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，WaitGroup是实现等待一组并发操作完成的好方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;world!&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()         <span class="comment">//计数器减一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)               <span class="comment">//计数器加一</span></span><br><span class="line">	<span class="keyword">go</span> hello()</span><br><span class="line">	fmt.Print(<span class="string">&quot;hello &quot;</span>)</span><br><span class="line">	wg.Wait()               <span class="comment">//阻塞代码的运行，直到计数器为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure><h2 id="Lock-锁">Lock 锁</h2><h3 id="Mutex-互斥锁">Mutex 互斥锁</h3><ul><li>Mutex 是最基本的一种锁，用于保护临界区，确保同一时刻只有一个 Goroutine 可以访问共享资源。</li><li>Mutex 的零值是未加锁的状态，通过 Lock () 方法进行加锁，通过 Unlock () 方法进行解锁。</li><li>如果一个 Goroutine 尝试对已经加锁的 Mutex 再次加锁，它会阻塞直到 Mutex 被解锁。</li><li>Mutex 是排他锁，意味着当一个 Goroutine 获得了锁之后，其他 Goroutine 就无法获得锁，直到锁被释放。</li></ul><h3 id="RWMute-读写锁">RWMute 读写锁</h3><ul><li>RWMutex 是对 Mutex 的扩展，它分为读锁和写锁两种状态，多个 Goroutine 可以同时获取读锁，但只有一个 Goroutine 可以获取写锁。</li><li>当存在读锁时，其他 Goroutine 可以继续获取读锁，但无法获取写锁；当存在写锁时，其他 Goroutine 无法获取读锁或写锁。</li><li>RWMutex 适用于读多写少的场景，可以提高并发访问的效率。</li></ul><h3 id="RLock-and-Lock"><code>RLock()</code> and <code>Lock()</code></h3><p><strong>Lock()</strong>:通过获取锁，一次只能进行一次读/写。</p><p><strong>RLock()</strong>:多个 go routine 可以通过获取锁同时读取(不能写入)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    a := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    lock := sync.RWMutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            lock.Lock()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Lock: from go routine %d: a = %d\n&quot;</span>,i, a)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            lock.Unlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">11</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            lock.RLock()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;RLock: from go routine %d: b = %d\n&quot;</span>,i, b)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            lock.RUnlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;-time.After(time.Second*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当一个 go-routine 已经获取了一个 RLock() 时，另一个 go-routine 是否可以获取一个 Lock() 进行写入，或者它必须等到 RUnlock() 发生？</li></ol><ul><li>要获取用于写入的 Lock()，它必须等到 RUnlock()</li></ul><ol start="2"><li>当有人已经为 map 获取了 Lock() 时会发生什么，其他 go-routine 是否仍然可以获取 RLock()</li></ol><ul><li>如果某人 X 已经获取了 Lock()，那么其他获取 RLock() 的 go-routine 将必须等到 X 释放锁(Unlock())</li></ul><ol start="3"><li>假设我们在这里处理Maps，是否有可能出现“并发读/写Map”错误？</li></ol><ul><li>Map 不是线程安全的。所以“ map 的并发读/写”会导致错误。</li></ul><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/53427824/what-is-the-difference-between-rlock-and-lock-in-golang">go - what is the difference between RLock() and Lock() in Golang? - Stack Overflow</a></p><h2 id="channel">channel</h2><p>goroutine 之间交换数据的解决办法：</p><ul><li>为了保证线程间数据交换的正确性，很多并发模型使用互斥锁，但这样会造成性能问题。</li><li>Go采用的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存，而不是通过共享内存而实现通信</li><li>Go 语言中的<code>channel</code>是一种特殊的类型。<code>channel</code>像一个队列，总是遵循先入先出的规则，保证收发数据的顺序。每一个<code>channel</code>都是一个具体类型的导管，也就是声明<code>channel</code>的时候需要为其指定元素类型。</li></ul><h3 id="操作">操作</h3><ul><li><code>channel</code> 的零值为nil</li><li>发送和接收操作均用<code>​&lt;-</code>​符号</li><li>它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用make()初始化</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型,[缓冲大小])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个通道并初始化</span></span><br><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把10发送给a通道</span></span><br><span class="line">a &lt;- <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x从a通道中取值</span></span><br><span class="line">value, ok := &lt;-ch</span><br><span class="line"><span class="comment">//从a通道中取值，忽略结果</span></span><br><span class="line">&lt;-a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line"><span class="built_in">close</span>(a)</span><br></pre></td></tr></table></figure><h3 id="关闭">关闭</h3><ul><li>当一个通道被关闭后，再往该通道发送值会引发panic。</li><li>对已关闭的通道进行取值的操作会先取完通道中的值。</li><li>通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 for range 取完通道所有的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="keyword">range</span> ch&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;v:%v&quot;</span>,i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无缓冲channel-阻塞的channel">无缓冲channel(阻塞的channel)</h3><ul><li>无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段。</li><li>同理，如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，deadlock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	a &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(x <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	ret := &lt;-x</span><br><span class="line">	fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> receive(a)</span><br><span class="line">	a &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有缓冲区channel">有缓冲区channel</h3><ul><li>通道的容量大于零，该通道就是有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。</li><li>通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。</li><li>可以使用 <code>len()</code> 获取通道的长度，使用 <code>cap()</code> 获取通道的容量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)</span><br><span class="line">	a &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向通道">单向通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 只接收通道，只能接收不能发送</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">// 只发送通道，只能发送不能接收</span></span><br></pre></td></tr></table></figure><ol><li><strong>发送通道（send-only channel）</strong>：<ul><li>发送通道只能用于向通道中发送数据，而不能从通道中接收数据。</li><li>通过使用语法<code>chan&lt;- 数据类型</code>来声明发送通道，其中<code>chan&lt;-</code>表示该通道只能用于发送数据，不能用于接收数据。</li><li>例如：<code>ch := make(chan&lt;- int)</code>表示创建一个只能用于发送整数类型数据的发送通道。</li></ul></li><li><strong>接收通道（receive-only channel）</strong>：<ul><li>接收通道只能用于从通道中接收数据，而不能向通道中发送数据。</li><li>通过使用语法<code>&lt;-chan 数据类型</code>来声明接收通道，其中<code>&lt;-chan</code>表示该通道只能用于接收数据，不能用于发送数据。</li><li>例如：<code>ch := make(&lt;-chan int)</code>表示创建一个只能用于接收整数类型数据的接收通道。</li></ul></li></ol><h3 id="select-多路复用">select 多路复用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次进入循环只会执行其中满足条件的，下列结果为 1 3 5 7 9</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">                fmt.Println(x)</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁">互斥锁</h3><p>一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go语言中使用sync包中提供的Mutex类型来实现互斥锁</p><ul><li>互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；</li><li>当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区</li><li>多个 goroutine 同时等待一个锁时，唤醒的策略是随机的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x  <span class="type">int64</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">	m  sync.Mutex           <span class="comment">// 互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		m.Lock()            <span class="comment">// 修改x前加锁</span></span><br><span class="line">		x = x + <span class="number">1</span></span><br><span class="line">		m.Unlock()          <span class="comment">// 改完解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(x)          <span class="comment">//10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁">读写锁</h3><ul><li>当并发的去读取一个资源而不涉及资源修改的时没有必要使用互斥锁，读写锁是一种更好的选择。</li><li>在Go语言中使用sync包中的RWMutex类型来实现读写互斥锁</li><li>读写锁分为两种：读锁和写锁。<ul><li>当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；</li><li>而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x  = <span class="number">0</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">	RWLock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	RWLock.RLock()</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	RWLock.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	RWLock.Lock()</span><br><span class="line">	x += <span class="number">1</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">	RWLock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> write()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> read()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="context">context</h2><p><code>context</code> 包提供了在不同 Goroutine 之间传递请求特定值、取消信号以及请求范围的截止时间等功能。主要用于控制 Goroutine 的生命周期和上下文，避免因为不同 Goroutine 之间的竞争而导致的问题，比如取消请求、超时处理、请求跟踪等。</p><ul><li><code>WithCancel(parent Context)</code>：创建一个新的上下文，返回的上下文的 <code>Done</code> 通道会在父上下文的 <code>Done</code> 通道关闭或调用 <code>Cancel</code> 方法时关闭</li><li><code>WithDeadline(parent Context, deadline time.Time)</code>：创建一个新的上下文，返回的上下文的<code>Done</code>通道会在指定截止时间到达、父上下文的<code>Done</code>通道关闭或调用<code>Cancel</code>方法时关闭，以最先发生的情况为准</li><li><code>WithTimeout(parent Context, timeout time.Duration)</code>：类似<code>WithDeadline</code>，不过是相对于当前时间计算截止时间</li><li><code>WithValue(parent Context, key, val interface&#123;&#125;)</code>：创建一个新的上下文，包含了一个键值对。这个函数一般用来传递请求特定的值</li></ul><p>包含了以下几个方法：</p><ul><li><code>Deadline() (deadline time.Time, ok bool)</code>：返回上下文的截止时间，如果不存在截止时间，则 <code>ok</code> 为 <code>false</code></li><li><code>Done() &lt;-chan struct&#123;&#125;</code>：返回一个通道，当上下文被取消或超时时，该通道会被关闭</li><li><code>Err() error</code>：返回上下文的错误信息，如果上下文被取消或超时，则返回相应的错误信息</li><li><code>Value(key interface&#123;&#125;) interface&#123;&#125;</code>：返回上下文中指定键的值</li></ul></div><div class="article-licensing box"><div class="licensing-title"><p>go grammar</p><p><a href="https://tomatoblog.netlify.app/BackEnd/go/go-grammar/">https://tomatoblog.netlify.app/BackEnd/go/go-grammar/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TOMATO</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-04-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-03-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/go/">go</a></div></article></div><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/BackEnd/go/go-memo/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">go memo</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Study/dataStruct/Hash-Table/"><span class="level-item">Hash Table</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div></div><style>.column.column-left,.column.column-right{display:none}</style><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/static/avatar.jpg" alt="ToMaTo"></figure><p class="title is-size-4 is-block" style="line-height:inherit">ToMaTo</p><p class="is-size-6 is-block">Back-end Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>GuangZhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">59</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/dontSerious/" target="_blank" rel="noopener" id="widget-follow">Github</a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">2024年04月</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">2024年03月</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">2024年02月</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">2023年12月</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">2023年11月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">2023年10月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">2023年09月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">2023年08月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">2023年06月</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">2023年05月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">2023年04月</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">2023年03月</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">2023年02月</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-04-28T10:24:18.000Z">2024-04-28</time></p><p class="title"><a href="/FrontEnd/Flutter/">flutter 笔记</a></p><p class="categories"><a href="/categories/FrontEnd/">FrontEnd</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T06:43:15.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/go/">go面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T02:10:11.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/datastruct/">数据结构和算法面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-26T02:10:11.000Z">2024-03-26</time></p><p class="title"><a href="/Interview/distributed/">分布式面试</a></p><p class="categories"><a href="/categories/Interview/">Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-03-16T07:28:10.000Z">2024-03-16</time></p><p class="title"><a href="/BackEnd/sql/index/">SQL 索引</a></p><p class="categories"><a href="/categories/BackEnd/">BackEnd</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础语法"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础语法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#变量定义"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">变量定义</span></span></a></li><li><a class="level is-mobile" href="#常量定义"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">常量定义</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#iota"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">iota</span></span></a></li></ul></li><li><a class="level is-mobile" href="#条件语句"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">条件语句</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#switch语句"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">switch语句</span></span></a></li><li><a class="level is-mobile" href="#select语句"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">select语句</span></span></a></li></ul></li><li><a class="level is-mobile" href="#循环语句"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">循环语句</span></span></a></li><li><a class="level is-mobile" href="#函数"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#闭包"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">闭包</span></span></a></li><li><a class="level is-mobile" href="#函数方法"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">函数方法</span></span></a></li><li><a class="level is-mobile" href="#defer语句"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">defer语句</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数组"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">数组</span></span></a></li><li><a class="level is-mobile" href="#切片"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">切片</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#len-和-cap"><span class="level-left"><span class="level-item">1.7.1</span><span class="level-item">len() 和 cap()</span></span></a></li><li><a class="level is-mobile" href="#append-和-copy"><span class="level-left"><span class="level-item">1.7.2</span><span class="level-item">append() 和 copy()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#结构体"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">结构体</span></span></a></li><li><a class="level is-mobile" href="#Map"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">Map</span></span></a></li><li><a class="level is-mobile" href="#类型转换"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">类型转换</span></span></a></li><li><a class="level is-mobile" href="#接口"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">接口</span></span></a></li><li><a class="level is-mobile" href="#Reflect"><span class="level-left"><span class="level-item">1.12</span><span class="level-item">Reflect</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#reflect-New"><span class="level-left"><span class="level-item">1.12.1</span><span class="level-item">reflect.New()</span></span></a></li><li><a class="level is-mobile" href="#Reflect-TypeOf"><span class="level-left"><span class="level-item">1.12.2</span><span class="level-item">Reflect.TypeOf()</span></span></a></li><li><a class="level is-mobile" href="#Reflect-ValueOf"><span class="level-left"><span class="level-item">1.12.3</span><span class="level-item">Reflect.ValueOf()</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#并发"><span class="level-left"><span class="level-item">2</span><span class="level-item">并发</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#goroutine"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">goroutine</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#sync-WaitGroup"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">sync.WaitGroup</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Lock-锁"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Lock 锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Mutex-互斥锁"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">Mutex 互斥锁</span></span></a></li><li><a class="level is-mobile" href="#RWMute-读写锁"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">RWMute 读写锁</span></span></a></li><li><a class="level is-mobile" href="#RLock-and-Lock"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">RLock() and Lock()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#channel"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">channel</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#操作"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">操作</span></span></a></li><li><a class="level is-mobile" href="#关闭"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">关闭</span></span></a></li><li><a class="level is-mobile" href="#无缓冲channel-阻塞的channel"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">无缓冲channel(阻塞的channel)</span></span></a></li><li><a class="level is-mobile" href="#有缓冲区channel"><span class="level-left"><span class="level-item">2.3.4</span><span class="level-item">有缓冲区channel</span></span></a></li><li><a class="level is-mobile" href="#单向通道"><span class="level-left"><span class="level-item">2.3.5</span><span class="level-item">单向通道</span></span></a></li><li><a class="level is-mobile" href="#select-多路复用"><span class="level-left"><span class="level-item">2.3.6</span><span class="level-item">select 多路复用</span></span></a></li><li><a class="level is-mobile" href="#互斥锁"><span class="level-left"><span class="level-item">2.3.7</span><span class="level-item">互斥锁</span></span></a></li><li><a class="level is-mobile" href="#读写锁"><span class="level-left"><span class="level-item">2.3.8</span><span class="level-item">读写锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#context"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">context</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/BackEnd/"><span class="level-start"><span class="level-item">BackEnd</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Interview/"><span class="level-start"><span class="level-item">Interview</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Memo/"><span class="level-start"><span class="level-item">Memo</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Study/"><span class="level-start"><span class="level-item">Study</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/Tutorial/"><span class="level-start"><span class="level-item">Tutorial</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Flutter/"><span class="tag">Flutter</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT6-S081/"><span class="tag">MIT6.S081</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue-js/"><span class="tag">Vue.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bookNote/"><span class="tag">bookNote</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/career/"><span class="tag">career</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cs/"><span class="tag">cs</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/csapp/"><span class="tag">csapp</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/curriculum/"><span class="tag">curriculum</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dataStruct/"><span class="tag">dataStruct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/datastruct/"><span class="tag">datastruct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/distributed/"><span class="tag">distributed</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/live/"><span class="tag">live</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/log/"><span class="tag">log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memo/"><span class="tag">memo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/network/"><span class="tag">network</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/obsidian/"><span class="tag">obsidian</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/project/"><span class="tag">project</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psychology/"><span class="tag">psychology</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/simpleBank/"><span class="tag">simpleBank</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql/"><span class="tag">sql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tools/"><span class="tag">tools</span><span class="tag">10</span></a></div></div></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"><img class="logo-img-dark" src="/static/avatar.jpg" alt="Tomato&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 TOMATO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/deed.zh"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="/js/imaegoo/jquery/3.3.1/dist/jquery.min.js"></script><script src="/js/imaegoo/moment/2.22.2/min/moment-with-locales.min.js"></script><script src="/js/imaegoo/clipboard/2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "此网站使用 Cookie，以启用评论系统和分析功能。",
          dismiss: "知道了",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="/js/imaegoo/lightgallery/1.10.0/dist/js/lightgallery.min.js" defer></script><script src="/js/imaegoo/justifiedGallery/3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>