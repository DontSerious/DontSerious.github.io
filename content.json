{"posts":[{"title":"flutter 笔记","text":"State accessing external state pass value from external 1234567891011121314151617181920212223class ... { ... int _count = 0; void add(int value) { setState(() { _count += value; }); } @override Widget build(...) { ... Text( '$_count', ), Foo( count: _count, add: add, ), ... }} 1234567891011121314151617181920212223class Foo extends StatelessWidget { final int count; final void Function(int) onPressed; const Foo({ Key? key, required this.count, required this.onPressed, }) : super(key: key); @override Widget build(...) { ... Text( '$count', ), ElevatedButton( onPressed: add, child: Text(&quot;+2&quot;), ), ... };} holder 12345678910111213141516class DoubleHolder extends ChangeNotifier { double _num; DoubleHolder(this._num); double get num =&gt; _num; set num(double newNum){ _num = newNum; notifyListeners(); } void setMax() { _num = 1.0; notifyListeners(); }} 123456789101112class ... { ... final _controller = TextEditingController(); @override Widget build(...) { ... Foo(), ElevatedButton(onPressed: widget.dh.setMax();, child: Text(&quot;set to 100%&quot;)), ... }} 123456789101112131415161718192021222324class Foo extends StatefulWidget { ... final DoubleHolder dh;}class _FooState extends State&lt;Foo&gt; { @override Widget build(...) { ... ListenableBuilder( listenable: widget.dh, // when notify, only render this builder builder: (BuilderContext context, Widget? child) { retrun FlutterLogo(size: widget.dh.num * 100 + 50); }, ), Slider( value: widget.dh.num, onChanged: (double value) { widget.dh.num = value; }, ), },} valueNotifier the same as holder 1234class DoubleController { ValueNotifier&lt;double&gt; num1 = ValueNotifier(0.0); ValueNotifier&lt;double&gt; num2 = ValueNotifier(0.0);} usage 123456789101112widget.dh.num.value++ListenableBuilder( listenable: Listenable.merge([ widget.controller.num1, widget.controller.num2, ]), // when notify, only render this builder builder: (BuilderContext context, Widget? child) { retrun FlutterLogo(size: widget.dh.num1.value * 100 + 50); },),","link":"/FrontEnd/Flutter/"},{"title":"TypeScript笔记","text":"基础语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let v1: string = 'abc'let v2: number = 10let v3: boolean = truelet nu: null = nulllet un: undefined = undefinedlet v4: string | null = nulllet v5: 1 | 2 | 3 = 2let arr: number[] = [1, 2, 3]let arr1: Array&lt;String&gt; = ['a', 'b', 'c']// 元组let t1: [number, string, number?] = [1, 'a', 2]t1 = [2, 'c']// 枚举enum myEnum { A, B, C}// 相等console.log(myEnum.A)console.log(myEnum[0])// : void 表示没有返回值// a = 10 代表默认赋值，建议写左边// ? 代表可选参数，建议写右边function MyFun(a = 10, b: string, c?: boolean, ...rest: number[]): void { let d = a + b + c // return c}// 接口interface Boy { name: string, age: number}const bobo: Boy = { name: 'bobo', age: 10}// 自定义类型type MyUserName = string | numberlet a: MyUserName = 1// 泛型function MyFunc&lt;T&gt;(a: T, b: T): T[] { return [a, b]}MyFunc&lt;number&gt;(1, 2)","link":"/FrontEnd/TypeScript/"},{"title":"Vue速记","text":"2.0 基础 基础格式 12345678910111213141516171819202122232425262728293031&lt;script&gt; const vm = new Vue({ el: '#app', data() { return { title: '', content: '' } }, methods: { func() { } }, computed: { computedFunc() { } }, watch: { title (newValue, oldValue) { } } })&lt;/script&gt;&lt;div&gt; &lt;p v-text=&quot;title&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;title&quot;&gt;&lt;/p&gt;&lt;/div&gt; {{ title }} 显示 title 内容 {{ func() }} 显示 fun() return 内容 {{ computedFunc }} 有缓存的显示 computedFunc() return 内容 watch 监听：title 改变时执行花括号内代码 v-text 和 v-html 都可以覆盖元素显示内容，但 v-html 会经过编译 v-for=&quot;(item, key, index) in arr&quot; : arr 可以替换为数字，表示循环几次 v-if=&quot;true&quot; v-show=&quot;true&quot; 适合频繁开关 v-bind:title == :title v-on:click=&quot;func&quot; == @click=&quot;func&quot; v-model=&quot;&quot; 双向数据绑定 组件化开发 123456789101112131415&lt;script&gt;export default { name: '', props: { msg: String, count: { type: [String, Number], // 类型 default: 100, // 默认值 required: true, // 是否必须设置 } }, data () {}, method: {}}&lt;/script&gt;","link":"/FrontEnd/Vue%E9%80%9F%E8%AE%B0/"},{"title":"nodejs","text":"Linux 下使用包管理安装 github教程 NPM npm i 权限不足 方法一 使用普通用户重装 nodejs 方法二 修改 npm 安装位置 1234567mkdir ~/.npm-globalnpm config set prefix '~/.npm-global'# 在profile里添加以下export PATH=~/.npm-global/bin:$PATHsource ~/.profile 换源 因为 nrm(NPM registry manager)会因为使用国外源导致无法安装，所以没有魔法就先得使用手动方法换源后安装。 手动方法 查看源 1npm config get registry 更换源 这里先使用 taobao 源 1npm config set registry https://registry.npmmirror.com/ 这个配置会持久化保存到 ~/.npmrc 文件中，你也可以通过手动改该文件来修改配置。 nrm 安装 1npm i -g nrm 使用 12345678$ nrm ls npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ tencent ------ https://mirrors.cloud.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/ taobao ------- https://registry.npmmirror.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ 应用 1$ nrm use taobao create-react-app 修改端口号 1npm i cross-env react-app-rewried customize-cra -D 修改 package.json 12345&quot;scripts&quot;: { &quot;start&quot;: &quot;cross-env PORT=12333 react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;,},","link":"/FrontEnd/nodejs/"},{"title":"react笔记","text":"基础语法 状态 12345const [content, setContent] = useState('123');const [data, setData] = useState({ title: '', content: ''}) 修改 1234567function fun() { setContent('') setData({ ...data, title: '' })} 数组用法 12345678910111213141516171819202122232425const [data, setData] = useState({ { id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }})const listData = data.map(item =&gt; ( &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;))let id = 3function handleClick () { //setData([ // ...data, // { id: ++id, name: 'd' } //]) setData(data.filter(item =&gt; item.id !== 2))}return { &lt;&gt; &lt;ul&gt;{listData}&lt;/ul&gt; &lt;button onclick={handleClick}&gt;按钮&lt;/button&gt; &lt;/&gt;} 展开 123456789101112131415161718192021import img form './logo.svg'function App() { const imgData = { className: 'small', style: { width: 200, height: 200 } } return ( &lt;div&gt; &lt;img src={img} alt=&quot;&quot; {...imgData} /&gt; &lt;/div&gt; )} 传值 父向子 1234567891011121314151617181920212223242526272829303132333435function Detail({content, active}) { return ( &lt;&gt; &lt;p&gt;{content}&lt;/p&gt; &lt;p&gt;状态：{active ? '显示中' : '已隐藏'}&lt;/p&gt; &lt;/&gt; )}function Article({title, articleData}) { return ( &lt;div&gt; &lt;h2&gt;{title}&lt;/h2&gt; &lt;Detail {...articleData} /&gt; &lt;/div&gt; )}export default function App() { const articleData = { title: '标题1', detailData: { content: '内容1', active: true } } return ( &lt;&gt; &lt;Article {...articleData} /&gt; &lt;/&gt; )} 子向父 1234567891011121314151617181920212223242526272829303132import { useState } from &quot;react&quot;function Detail ({ onActive }) { const [status, setStatus] = useState(false) function handleClick() { setStatus(!status) onActive(status) } return ( &lt;div&gt; &lt;button onClick={handleClick}&gt;按钮&lt;/button&gt; &lt;p style={{ display: status ? 'block' : 'none' }}&gt;Detail的内容&lt;/p&gt; &lt;/div&gt; )}export default function App() { function handleActive(status) { console.log(status) } return ( &lt;&gt; &lt;Detail onActive={handleActive} /&gt; &lt;/&gt; )} 多级传输 Context 1 插槽 12345678910111213141516171819function List ({ children }) { return ( &lt;div&gt; {children} &lt;/div&gt; )}export default function App() { return ( &lt;&gt; &lt;List&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;/List&gt; &lt;/&gt; )} 脚手架安装 依赖 1npm i -g create-react-app 初始化 使用 react+ts 1create-react-app 项目名 --template typescript 暴露 webpack 配置文件 (可选) 1npm run eject 引入 Ant-Design 组件库 依赖 1npm i antd --save 引入测试 12345678910111213// App.tsximport type { FC } from 'react'import { Button } from 'antd'const App: FC = () =&gt; ( &lt;div&gt; &lt;Button type='primary'&gt;Button&lt;/Button&gt; &lt;Button type='link'&gt;哈哈哈&lt;/Button&gt; &lt;/div&gt;)export default App 语言汉化 使用 ConfigProvider 包裹 App 根组件 1234567891011121314151617181920//index.tsximport React from 'react';import ReactDOM from 'react-dom/client';import App from './App';// 汉化import { ConfigProvider } from 'antd';import zhCN from 'antd/locale/zh_CN'const root = ReactDOM.createRoot( document.getElementById('root') as HTMLElement);root.render( &lt;React.StrictMode&gt; &lt;ConfigProvider locale={ zhCN }&gt; &lt;App /&gt; &lt;/ConfigProvider&gt; &lt;/React.StrictMode&gt;); 引入 react 路由 依赖 1npm i react-router-dom 编写路由表 src/routes 1234567891011121314151617181920212223// index.tsximport { Navigate } from &quot;react-router-dom&quot;;import Login from '../pages/login'import Home from '../pages/home'export default [ { path: '/login', element: &lt;Login /&gt; }, { path: '/home', element: &lt;Home /&gt; }, { // 重定向 path: '/', element: &lt;Navigate to = '/home' /&gt; }] as { path: string, element: JSX.Element}[] 注册路由 12345678910111213141516171819202122232425// index.tsximport React from 'react';import ReactDOM from 'react-dom/client';import App from './App';// 路由import { BrowserRouter } from 'react-router-dom';// 汉化import { ConfigProvider } from 'antd';import zhCN from 'antd/locale/zh_CN'const root = ReactDOM.createRoot( document.getElementById('root') as HTMLElement);root.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;ConfigProvider locale={ zhCN }&gt; &lt;App /&gt; &lt;/ConfigProvider&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;); 123456789101112131415161718// App.tsximport type { FC } from 'react'import { useRoutes } from 'react-router-dom'import routes from './routes/index'const App: FC = () =&gt; { // 获得路由表 const routeView = useRoutes(routes) return ( &lt;div&gt; { routeView } &lt;/div&gt; )}export default App zustand 状态管理 1npm i zustand --save 基本用法 123456789101112131415161718192021222324// AuthStore.tsximport { create } from 'zustand';interface State { statusCode: number | null; statusMsg: string | null;}interface Action { setAuthData: (statusCode: State['statusCode'], statusMsg: State['statusMsg']) =&gt; void;}export const useAuthStore = create&lt;State &amp; Action&gt;()( (set) =&gt; ({ statusCode: null, statusMsg: null, setAuthData: (statusCode, statusMsg) =&gt; set( () =&gt; ({ statusCode: statusCode, statusMsg: statusMsg, }) ), })) 12345678// login.tsximport { useAuthStore } from '../contexts/AuthStore'const Login: FC = () =&gt; { const { statusCode, statusMsg, setAuthData } = useAuthStore() setAuthData(1, 'msg')} Immer middleware 给cats的某个属性赋值时不用再 ...cats 123456789101112131415161718192021222324252627282930313233import { create } from &quot;zustand&quot;;import { immer } from &quot;zustand/middleware/immer&quot;;type TCatStoreState = { cats: { bigCats: number; smallCats: number; }; increaseBigCats: () =&gt; void; increaseSmallCats: () =&gt; void; summary: () =&gt; void;};export const useCatStore = create&lt;TCatStoreState&gt;()( immer((set, get) =&gt; ({ cats: { bigCats: 0, smallCats: 0, }, increaseBigCats: () =&gt; set((state) =&gt; { state.cats.bigCats++; }), increaseSmallCats: () =&gt; set((state) =&gt; { state.cats.smallCats++; }), summary: () =&gt; { const total = get().cats.bigCats + get().cats.smallCats; return `There are ${total} cats in total. `; }, }))); 重渲染 不同组件使用同一个 store 的部分状态时，会出现重渲染导致性能下降 也就是牵一发而动全身的情况：在组件使用状态时，别的组件就算没有导入正在使用的状态也会导致重新加载 Selector 12// 使用selector指定只使用某一个状态const bigCats = useCatStor((state) =&gt; state.cats.bigCats) auto selector 123456789101112131415161718// auto selectorimport { StoreApi, UseBoundStore } from 'zustand'type WithSelectors&lt;S&gt; = S extends { getState: () =&gt; infer T } ? S &amp; { use: { [K in keyof T]: () =&gt; T[K] } } : neverexport const createSelectors = &lt;S extends UseBoundStore&lt;StoreApi&lt;object&gt;&gt;&gt;( _store: S,) =&gt; { let store = _store as WithSelectors&lt;typeof _store&gt; store.use = {} for (let k of Object.keys(store.getState())) { ;(store.use as any)[k] = () =&gt; store((s) =&gt; s[k as keyof typeof s]) } return store} 1234567891011121314interface BearState { bears: number increase: (by: number) =&gt; void increment: () =&gt; void}const useBearStoreBase = create&lt;BearState&gt;()((set) =&gt; ({ bears: 0, increase: (by) =&gt; set((state) =&gt; ({ bears: state.bears + by })), increment: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),}))// 包一下const useBearStore = createSelectors(useBearStoreBase) 12345// get the propertyconst bears = useBearStore.use.bears()// get the actionconst increment = useBearStore.use.increment() useShallow 当您需要从存储订阅计算状态时，建议的方法是使用 selector。 如果输出已根据 Object.is 更改，则计算的选择器将导致重新渲染。 在这种情况下，如果计算值始终与前一个值相等，则可能需要使用 useShallow 来避免重新渲染。 12345678910111213import { create } from 'zustand'const useMeals = create(() =&gt; ({ papaBear: 'large porridge-pot', mamaBear: 'middle-size porridge pot', littleBear: 'A little, small, wee pot',}))export const BearNames = () =&gt; { const names = useMeals((state) =&gt; Object.keys(state)) return &lt;div&gt;{names.join(', ')}&lt;/div&gt;} 1234// 改变useMeals.setState({ papaBear: 'a large pizza',}) 此更改会导致 BearNames 重新渲染，即使名称的实际输出没有根据浅相等而改变。 1234567891011121314import { create } from 'zustand'import { useShallow } from 'zustand/react/shallow'const useMeals = create(() =&gt; ({ papaBear: 'large porridge-pot', mamaBear: 'middle-size porridge pot', littleBear: 'A little, small, wee pot',}))export const BearNames = () =&gt; { const names = useMeals(useShallow((state) =&gt; Object.keys(state))) return &lt;div&gt;{names.join(', ')}&lt;/div&gt;} Persist 持久化 123456789101112131415import { create } from 'zustand'import { persist, createJSONStorage } from 'zustand/middleware'export const useBearStore = create( persist( (set, get) =&gt; ({ bears: 0, addABear: () =&gt; set({ bears: get().bears + 1 }), }), { name: 'food-storage', // name of the item in the storage (must be unique) storage: createJSONStorage(() =&gt; sessionStorage), // (optional) by default, 'localStorage' is used }, ),) partialize 指定哪些不进行持久化 1234567891011121314151617export const useBoundStore = create( persist( (set, get) =&gt; ({ foo: 0, bar: 1, }), { // ... partialize: (state) =&gt; Object.fromEntries( Object.entries(state).filter(([key]) =&gt; !['foo'].includes(key)), ), }, // or partialize: (state) =&gt; ({ foo: state.foo }), ),) 更多… Subscribe 防止状态不停改变时，页面跟着疯狂重渲染 123456789101112// component// 会在component页面不起作用时取消订阅，避免浪费资源useEffect(() =&gt; { const unsub = useFoodStore.subscribe((state, prevState) =&gt; { if (prevState.fish &lt;= 5 &amp;&amp; state.fish &gt; 5) { // code } else if (prevState.fish &gt; 5 &amp;&amp; state.fish &lt;= 5) { // code } }) return unsub}, []) or 12345678910111213141516171819// component// 会在component页面不起作用时取消订阅，避免浪费资源useEffect(() =&gt; { const unsub = useFoodStore.subscribe( state=&gt;state.fish, (fish, prevFish) =&gt; { if (prevFish &lt;= 5 &amp;&amp; fish &gt; 5) { // code } else if (prevFish &gt; 5 &amp;&amp; fish &lt;= 5) { // code } }, { equalityFn: shallow, fireImmediately: true, //是否在第一次运行时就执行 } }) return unsub}, []) subscribe 监听的是整个 store，如果想监听某个字段，需要用到 subscribeWithSelector 中间件。 Get Set State action 123456export const useBoundStore = create((set) =&gt; ({ count: 0, text: 'hello', inc: () =&gt; set((state) =&gt; ({ count: state.count + 1 })), setText: (text) =&gt; set({ text }),})) No action 123456789export const useBoundStore = create(() =&gt; ({ count: 0, text: 'hello',}))export const inc = () =&gt; useBoundStore.setState((state) =&gt; ({ count: state.count + 1 }))export const setText = (text) =&gt; useBoundStore.setState({ text }) 简化 middleware 包裹 外置包裹 12345678910111213141516import { create } from 'zustand'import { devtools, persist } from 'zustand/middleware'const myMiddlewares = (f) =&gt; devtools(persist(f, { name: 'bearStore' }))interface BearState { bears: number increase: (by: number) =&gt; void}const useBearStore = create&lt;BearState&gt;()( myMiddlewares((set) =&gt; ({ bears: 0, increase: (by) =&gt; set((state) =&gt; ({ bears: state.bears + by })), })),) 挤出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import { StateCreator, create } from &quot;zustand&quot;;import { immer } from &quot;zustand/middleware/immer&quot;;import { createSelectors } from &quot;../utils/createSelectors&quot;;import { devtools, persist, subscribeWithSelector } from &quot;zustand/middleware&quot;;type TCatStoreState = { cats: { bigCats: number; smallCats: number; }; increaseBigCats: () =&gt; void; increaseSmallCats: () =&gt; void; summary: () =&gt; void;};const createCatSlice: StateCreator&lt; TCatStoreState, [ [&quot;zustand/immer&quot;, never], [&quot;zustand/devtools&quot;, unknown], [&quot;zustand/subscribeWithSelector&quot;, never], [&quot;zustand/persist&quot;, unknown] ]&gt; = (set, get) =&gt; ({ cats: { bigCats: 0, smallCats: 0, }, increaseBigCats: () =&gt; set((state) =&gt; { state.cats.bigCats++; }), increaseSmallCats: () =&gt; set((state) =&gt; { state.cats.smallCats++; }), summary: () =&gt; { const total = get().cats.bigCats + get().cats.smallCats; return `There are ${total} cats in total. `; },});export const useCatStore = createSelectors( create&lt;TCatStoreState&gt;()( immer( devtools( subscribeWithSelector( persist(createCatSlice, { name: &quot;cat store&quot;, }) ), { enabled: true, name: &quot;cat store&quot;, } ) ) ));","link":"/FrontEnd/react%E7%AC%94%E8%AE%B0/"},{"title":"数据结构和算法面试","text":"排序 算法 最佳情况 平均情况 最坏情况 空间复杂度 稳定性 冒泡排序（Bubble Sort） O(n) O(n^2) O(n^2) O(1) 是 选择排序（Selection Sort） O(n^2) O(n^2) O(n^2) O(1) 否 插入排序（Insertion Sort） O(n) O(n^2) O(n^2) O(1) 是 归并排序（Merge Sort） O(n log n) O(n log n) O(n log n) O(n) 是 快速排序（Quick Sort） O(n log n) O(n log n) O(n^2) O(log n)~O(n) 否 堆排序（Heap Sort） O(n log n) O(n log n) O(n log n) O(1) 否 计数排序（Counting Sort） O(n+k) O(n+k) O(n+k) O(n+k) 是 桶排序（Bucket Sort） O(n+k) O(n+k) O(n^2) O(n+k) 是 基数排序（Radix Sort） O(nk) O(nk) O(nk) O(n+k) 是 查找 算法 最佳情况 平均情况 最坏情况 空间复杂度 线性查找（Linear Search） O(1) O(n) O(n) O(1) 二分查找（Binary Search） O(1) O(log n) O(log n) O(1) 插值查找（Interpolation Search） O(1) O(log log n) O(n) O(1) 哈希查找（Hashing） - O(1) - O(n) O(1) - O(n) O(n) 二叉查找树（BST） O(1) - O(log n) O(log n) O(n) O(n) 平衡二叉查找树（AVL、红黑树等） O(1) - O(log n) O(log n) O(log n) O(n)","link":"/Interview/datastruct/"},{"title":"分布式面试","text":"消息队列 消息队列通常由以下几个组件组成： 消息生产者（Producer）：负责生成并发送消息到消息队列中。 消息队列（Message Queue）：是消息传递的中间件，用于存储消息。它是生产者和消费者之间的缓冲区。 消息消费者（Consumer）：负责从消息队列中取出消息并进行处理。 作用 解耦、异步、削峰 解耦：可以进行数据分发，生产者发送消息可以由多个消费者进行消费 特点 先进先出、持久化、分布式 持久化：消息队列能像数据库一样将储存核心数据 各大队列特点介绍 RabbitMQ 多线程 采用队列（Queue）模型，消息被发送到队列中，消费者从队列中接收消息并进行处理 侧重于消息的可靠性传递和消息的持久化，对于高吞吐量的需求可能需要进行优化和调整 RocketMQ ： 多线程 采用主题（Topic）和标签（Tag）的模型，消息被发布到主题上，消费者可以根据主题和标签进行订阅和过滤消息 具有较高的吞吐量，可以达到百万级消息的处理能力 在分布式事务和大规模消息传递场景下表现出色 Kafka 采用发布-订阅的模型，消息被发布到主题上，多个消费者可以订阅同一个主题并独立消费消息。 单线程、不重试 吞吐非常大 会丢数据 功能较为单一 适用于大规模数据处理、实时流处理和日志处理等高吞吐量场景 缺点 ： 系统可用性降低 系统复杂度提高 消息一致性问题 服务发现 流程 服务实例启动时，会向服务发现组件注册自己的元数据，内容包括名称、IP 地址、端口号等 服务实例会周期性的发送心跳，若长时间没有心跳则会被标记为不可用 当服务实例需要与特定的服务进行通信 向服务发现组件发送查询请求 服务发现组件检索实例列表、进行筛选并返回一个或多个服务实例的元数据 请求方收到之后就可以直接与特定的服务建立通信，可以基于 HTTP、RPC 等网络协议 服务发现组件需要能处理服务实例的动态变更，发生改变时，服务发现组件需要更新内部实例列表，并通知被影响到的服务 序列化 处理序列化和反序列化 在网络通信中，将数据对象转换为可以在网络上传输的格式，以及将接收到的数据反序列化为程序能够处理的对象 在分布式系统中，序列化中间件通常用于在不同节点之间传递数据，确保数据的正确传输和解析 XML、JSON、Protobuf","link":"/Interview/distributed/"},{"title":"go面试","text":"语言有关 锁 Mutex 互斥锁 Mutex是最基本的一种锁，用于保护临界区，确保同一时刻只有一个Goroutine可以访问共享资源。 Mutex的零值是未加锁的状态，通过Lock()方法进行加锁，通过Unlock()方法进行解锁。 如果一个Goroutine尝试对已经加锁的Mutex再次加锁，它会阻塞直到Mutex被解锁。 Mutex是排他锁，意味着当一个Goroutine获得了锁之后，其他Goroutine就无法获得锁，直到锁被释放。 RWMute 读写锁 RWMutex是对Mutex的扩展，它分为读锁和写锁两种状态，多个Goroutine可以同时获取读锁，但只有一个Goroutine可以获取写锁。 当存在读锁时，其他Goroutine可以继续获取读锁，但无法获取写锁；当存在写锁时，其他Goroutine无法获取读锁或写锁。 RWMutex适用于读多写少的场景，可以提高并发访问的效率。 项目有关 jwt 由三部分组成: header、payload、signature header：通常包含两部分信息，即令牌的类型（typ）和所使用的签名算法（alg） payload：包含了被 JWT 签发的声明，也就是一些有关用户的信息，例如用户的ID、用户名、角色等等。Payload 是 JWT 的主要内容，也是可以自定义的部分。 是将头部和载荷进行编码后用于验证身份的一部分。签名通常由使用私钥对头部、载荷和一个密钥进行哈希计算得到的。通过签名，可以验证 JWT 是否被篡改过。","link":"/Interview/go/"},{"title":"计算机网络面试","text":"HTTP 1.1 优点： 简单 灵活、易于扩展 应用广泛、跨平台 缺点： 明文传输 应用层队头阻塞 无状态：使用 Cookie 解决 没有请求优先级控制 请求只能从客户端开始，服务器只能被动响应 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大，只能压缩 Body 的部分 新增： 长连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态，使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 管道网络传输：可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，减少整体的响应时间。但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。出现 队头阻塞 问题。 优化 避免发送 HTTP 请求 缓存 减少请求次数 利用代理服务器减少重定向次数 合并请求，小资源合并为大资源，减少请求次数就是减少头部数据重复传输，减少 TCP 连接数量，最终省去 TCP 握手和慢启动的网络消耗 延迟发送，按需获取 压缩响应数据 有损压缩 无损压缩 HTTP 超文本传输协议 HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 状态码 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。 常见字段 Host：指定服务器域名 Content-Length：数据长度 HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。 Connection：指定长连接机制 Content-Type：服务器为客户端返回数据时指定数据格式 Content-Type: text/html; Charset=utf-8代表服务器发送的是网页，编码格式是 utf-8 Accept: */* 客户端请求时指定，表示自己可接受任何格式数据 Content-Encoding：数据的压缩方法 Content-Encoding: gzip 服务器指定发送数据的压缩方法 Accept-Encoding: gzip, deflate 客户端指定可接受哪些压缩方法 请求方法 GET 和 POST 方法都是安全和幂等的吗？ 安全和幂等的概念： 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 如果从 RFC 规范定义的语义来看： GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。 缓存 强制缓存 200 from disk cache 强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期： Cache-Control， 是一个相对时间； Expires，是一个绝对时间； 如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，Cache-Control 的优先级高于 Expires 。 Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下： 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小； 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器； 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。 协商缓存 协商缓存可以基于两种头部来实现。 第一种 请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现 响应头部中的 Last-Modified：标示这个响应资源的最后修改时间； 请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。 第二种 ETag 请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是： 响应头部中 Etag：唯一标识响应资源； 请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。 第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。 如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，这时 Etag 的优先级更高，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。 为什么 ETag 的优先级更高？ 因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题： 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求； 可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次； 有些服务器不能精确获取文件的最后修改时间。 注意，协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。 当使用 ETag 字段实现的协商缓存的过程： 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的； 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期： 如果没有过期，则直接使用本地缓存； 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识； 服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较： 如果值相等，则返回 304 Not Modified，不会返回资源； 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识； 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。 HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。 而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。 HTTP 默认端口号是 80，HTTPS 默认端口号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 HTTPS 双向认证 一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。 如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。 HTTP 2 头部压缩 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后只发送索引号，这样就提高速度了。 二进制格式 HTTP/2 不再明文传输，而是全面采用了二进制格式，头信息和数据体都是二进制，来回发送不用二次转换格式，增加了数据传输的效率，节省字节 统称为帧（frame）：头信息帧（Headers Frame）和数据帧（Data Frame），Frame 是 HTTP/2 最小单位。 并发传输 Stream 多路复用： 一个 TCP 连接包含多个 Stream，Stream 里可以包含一个或多个 Message，Message 里包含一个或者多个 Frame Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成 Stream ID 是独一无二的，所以 Stream 和 Stream 的帧可以乱序发送，接收端通过 Stream ID 有序组装成 HTTP 消息，最终 HTTP/2 可以并行交错地发送请求和响应。 服务端推送 服务端不再被动地响应，可以主动向客户端发送消息。 客户端和服务器双方都可以建立 Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。 比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。 缺陷 利用 Stream 的并发能力解决了应用层的队头阻塞的问题，但是 TCP 协议本身的特性依然会导致队头阻塞： HTTP/2 基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样 kernel 才会将 buffer 里的数据返回给应用层 当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在 buffer 里，只有等到这 1 个字节数据到达时，应用层才能从 kernel 中拿到数据 所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。 HTTP 3 UDP HTTP/3 将 TCP 协议更换为 UDP 协议，利用 UDP 协议中的 QUIC 协议实现类似 TCP 的可靠性传输： 当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题 HTTP 和 RPC 他们都是属于应用层，都可以选择使用 TCP 或者 UDP，服务发现方式不同 HTTP：超文本传输协议，属于协议 多用于 Browser/Server (B/S) 架构 使用 DNS 解析获取 IP 信息 RPC：远程过程调用，属于调用方式 使用 gRPC，thrift 等协议可以做到远程调用 多用于 Client/Server (C/S)架构，多用于公司内部集群 使用 Etcd 等中间服务进行保存服务名和 IP 信息 定制化程度更高，可以采用更多序列化协议保存结构体数据，性能更好 HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合，软件同时支持多端。 HTTP/2.0 在 HTTP/1.1 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。 HTTP 和 WebSocket TCP 协议本身是全双工，HTTP 基于的 TCP 协议，但是使用半双工 全双工：同一时间里，双方都可以主动向对方发送数据，比如 Websocket 半双工：同一时间里，客户端和服务器只能有一方主动发数据，比如 HTTP/1.1 HTTP 和 WebSocket 都处于应用层 WebSocket 为了应用于客户端和服务器频繁交互的场景，比如游戏 WebSocket 只有在建立连接时才用到了 HTTP，升级完成之后就跟 HTTP 没有任何关系了 WebSocket 的数据格式也是消息头+消息体的形式：数据头（内含 payload 长度） + payload data HTTP 轮询 轮询：网页的前端不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息 长轮询 将超时设置的很大，比如 30 秒，在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。 他们本质都是客户端主动获取数据，多应用于简单场景，如扫码登录。 在网页游戏等，有大量数据需要推送时，则会出现 Websocket Websocket 建立连接 使用协议升级的方式进行切换协议 123Connection: UpgradeUpgrade: WebSocketSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n 1234HTTP/1.1 101 Switching Protocols\\r\\nSec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\nUpgrade: WebSocket\\r\\nConnection: Upgrade\\r\\n Sec-WebSocket-Accept：一段随机生成的 base64 码 101 状态码：协议切换 Websocket 消息格式 数据包在这叫做帧 opcode 字段：这个是用来标志这是个什么类型的数据帧。比如。 等于 1 ，是指text类型（string）的数据包 等于 2 ，是二进制数据类型（[]byte）的数据包 等于 8 ，是关闭连接的信号 payload 字段：存放的是我们真正想要传输的数据的长度，单位是字节。比如你要发送的数据是字符串：111 ，那它的长度就是3。 读取方式 用最开始的7bit 做标志位，不管接下来的数据有多大，都先读最先的7个 bit： 如果 最开始的7bit 的值是 0~125，那么它就表示了 payload 全部长度，只读最开始的 7个bit 就完事了。 如果是 126（0x7E）。那它表示 payload 的长度范围在 126~65535 之间，接下来还需要再读16bit。这16bit 会包含 payload 的真实长度。 如果是127（0x7F）。那它表示payload的长度范围&gt;=65536，接下来还需要再读64bit。这64bit会包含payload的长度。这能放2的64次方byte的数据，换算一下好多个TB，肯定够用了。 引用 图解网络介绍 | 小林coding (xiaolincoding.com) OSI 七层 应用层（Application Layer）： 应用层是 OSI 模型中最高层的层次，它提供了网络服务和应用程序之间的接口。在这一层，用户可以访问各种网络服务，如电子邮件、文件传输、远程登录等。 典型的应用层协议包括 HTTP、FTP、SMTP、POP 3、IMAP、DNS 等。 表示层（Presentation Layer）： 表示层负责数据的格式化和编码，以便应用层能够正确地解释数据。它也负责数据的加密和解密，以确保数据在传输过程中的安全性。 典型的表示层协议包括 JPEG、GIF、ASCII、UTF-8、SSL 等。 会话层（Session Layer）： 会话层负责建立、管理和维护应用程序之间的通信会话。它提供了一种机制，允许应用程序在通信过程中建立、终止和管理会话。 典型的会话层协议包括 NetBIOS、RPC、SSH 等。 传输层（Transport Layer）： 传输层负责在网络中的两个节点之间提供端到端的数据传输服务。它将数据分割为适合传输的数据块，并确保数据的可靠传输，包括错误检测和纠正、流量控制和拥塞控制等功能。 典型的传输层协议包括 TCP、UDP 等。 网络层（Network Layer）： 网络层负责在网络中的不同节点之间提供路由和转发服务。它定义了数据在网络中的传输路径，并处理数据包的路由选择、拆分和重组等任务。 典型的网络层协议包括 IP、ICMP、ARP、RIP、OSPF 等。 数据链路层（Data Link Layer）： 数据链路层负责在相邻节点之间提供数据传输的物理连接和数据帧的传输。它处理数据帧的封装、发送和接收，以及物理介质的访问控制。 典型的数据链路层协议包括以太网、Wi-Fi、PPP、HDLC 等。 物理层（Physical Layer）： 物理层负责定义网络的物理介质和传输技术，包括电缆、光纤、无线电等。它处理数据的传输速率、信号编码、物理连接和电气特性等。 典型的物理层标准包括 RJ 45、IEEE 802.3、IEEE 802.11 等。 问题 TCP 和 UDP 的区别？ TCP 有连接；UDP 无连接。 TCP 可靠；UDP 不可靠。 TCP 基于数据流；UDP 基于数据报。 UDP 比 TCP 更高效。 TCP 发送缓冲区、接收缓冲区；UDP 只有接收缓冲区，没有发送缓冲区。 TCP 的可靠性传输怎么保证？ 保证可靠性的机制： 确认应答。 超时重传。 连接管理（三次握手和四次挥手）。 拥塞控制 流量控制 TCP 为什么需要三次握手 TCP 通讯的双方都是全双工的，所以他们彼此要证明自己和对方的发送能力和接收能力。 TCP 如果两次握手不能证明服务器端的发送能力和客户端的接受能力 -&gt; 两次握手。 TCP 至少需要三次握手才能证明彼此的全双工能力。 TCP 为什么需要四次挥手 TCP 本身自带确认应答。 TCP 有接收缓冲区的任务可能没执行完。","link":"/Interview/network/"},{"title":"memo","text":"[ ] 极简版抖音回顾 [ ] 矛盾论、实践论","link":"/Memo/memo/"},{"title":"go simpleBank project","text":"环境 go Gin gomock golang-migrate postgres sqlc Docker Makefile Viper zerolog asynq go 第三方包 github.com/stretchr/testify：测试 github.com/lib/pq：postgres 驱动 Docker-compose 12345678910111213141516171819202122232425version: &quot;3.8&quot;services: postgres: container_name: simpleBank-postgres image: postgres:alpine restart: unless-stopped # set shared memory limit when using docker-compose # shm_size: 128mb # or set shared memory limit when deploy via swarm stack volumes: - ./.docker-data/postgres/db:/var/lib/postgresql/data:z - run:/var/run environment: POSTGRES_USER: tomato POSTGRES_PASSWORD: joker TZ: Asia/Shanghai # ports: # - 9090:9090 network_mode: host command: &quot;-c TimeZone=Asia/Shanghai -c log_timezone=Asia/Shanghai -c unix_socket_permissions=0777&quot; # command: &quot;-c TimeZone=Asia/Shanghai -c log_timezone=Asia/Shanghai -c listen_addresses='' -c unix_socket_permissions=0777&quot;volumes: run: Postgres 网络使用 host 模式， localhost:5432 即可访问 执行 psql -U tomato 即可以 tomato 的身份进入 postgres migrate golang invoke migrate 12345678910111213func runDBMigration(migrationUrl, dbSource string) { migration, err := migrate.New(migrationUrl, dbSource) if err != nil { log.Fatal(&quot;cannot create new migrate instance&quot;) } // 防止发生 no change fatal 导致无法启动 if err = migration.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange { log.Fatal(&quot;failed to run migrate up: &quot;, err) } log.Println(&quot;db migrate successfully.&quot;)} Init_schema 12345# init_schemamigrate create -ext sql -dir db/migration/ -seq init_schema/home/soft/simple_bank/db/migration/000001_init_schema.up.sql/home/soft/simple_bank/db/migration/000001_init_schema.down.sql migrate up 会执行 up 脚本 migrate down 会执行 down 脚本 new migrate version 1migrate create -ext sql -dir db/migration/ -seq add_users 然后在新的 sql 文件添加新的内容 Sqlc 配置 12345678910111213141516171819202122version: &quot;2&quot;cloud: organization: &quot;&quot; project: &quot;&quot; hostname: &quot;&quot;sql: - engine: &quot;postgresql&quot; queries: &quot;./db/query/&quot; # query查询保存目录，用于生成代码 schema: &quot;./db/migration/&quot; # 表 sql 地址 gen: go: package: &quot;db&quot; # go package name out: &quot;./db/sqlc&quot; # go 代码位置 emit_json_tags: true emit_prepared_queries: false emit_interface: false emit_exact_table_names: falseoverrides: go: nullplugins: []rules: []options: {} 可选参数 123456789-- name: UpdateUser :oneUPDATE usersSET hashed_password = COALESCE(sqlc.narg(hashed_password), hashed_password), full_name = COALESCE(sqlc.narg(full_name), full_name), email = COALESCE(sqlc.narg(email), email)WHERE username = sqlc.arg(username)RETURNING *; 123456789101112131415updateUser, err := testQueries.UpdateUser(context.Background(), UpdateUserParams{ Username: oldUser.Username, HashedPassword: sql.NullString{ String: newHashedPassword, Valid: true, }, Email: sql.NullString{ String: newEmail, Valid: true, }, FullName: sql.NullString{ String: newFullName, Valid: true, }, }) protobuf 123456message UpdateUserRequest { string username = 1; optional string full_name = 2; optional string email = 3; optional string password = 4;} Makefile 12345678910111213141516171819dockerup: docker compose up -dcreatedb: docker exec -it simpleBank-postgres createdb --username=tomato --owner=tomato simple_bankdropdb: docker exec -it simpleBank-postgres dropdb simple_bank --username=tomatomigrateup: ./tools/migrate -path db/migration/ -database &quot;postgresql://tomato:joker@192.168.6.153:5432/simple_bank?sslmode=disable&quot; -verbose upmigratedown: ./tools/migrate -path db/migration/ -database &quot;postgresql://tomato:joker@192.168.6.153:5432/simple_bank?sslmode=disable&quot; -verbose down -allsqlc: ./tools/sqlc generate.PHONY: dockerup createdb dropdb migrateup migratedown sqlc 12// 执行dockerup下的命令make dockerup Viper 使用包：github.com/spf13/viper 读取配置文件 gomock 123456go install github.com/golang/mock/mockgen@v1.6.0go get github.com/golang/mock/mockgen/model# 使用反射生成# mockgen moduleName/dir interfacemockgen -package mockDB -destination db/mock/store.go github.com/DontSerious/simpleBank/db/sqlc Store Custom matcher 12345678910111213141516171819202122232425262728type eqCreateUserParamsMatcher struct { arg db.CreateUserParams password string}// 用自己写的工具重新实现matches来自定义对比passwordfunc (e eqCreateUserParamsMatcher) Matches(x interface{}) bool { arg, ok := x.(db.CreateUserParams) if !ok { return false } err := util.CheckPassword(e.password, arg.HashedPassword) if err != nil { return false } e.arg.HashedPassword = arg.HashedPassword return reflect.DeepEqual(e.arg, arg)}func (e eqCreateUserParamsMatcher) String() string { return fmt.Sprintf(&quot;marches args %v and password %v&quot;, e.arg, e.password)}func eqCreateUserParams(arg db.CreateUserParams, password string) gomock.Matcher { return eqCreateUserParamsMatcher{arg: arg, password: password}} 使用： 1234567891011121314151617181920212223242526272829303132testCases := []struct { name string body gin.H buildStubs func(store *mockDB.MockStore) checkResponse func(t *testing.T, recorder *httptest.ResponseRecorder) }{ { name: &quot;OK&quot;, body: gin.H{ &quot;username&quot;: user.Username, &quot;full_name&quot;: user.FullName, &quot;email&quot;: user.Email, &quot;password&quot;: password, }, buildStubs: func(store *mockDB.MockStore) { arg := db.CreateUserParams{ Username: user.Username, FullName: user.FullName, Email: user.Email, } store.EXPECT(). // 在这加入自定义matcher CreateUser(gomock.Any(), eqCreateUserParams(arg, password)). Times(1). Return(user, nil) }, checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) { require.Equal(t, http.StatusOK, recorder.Code) requireBodyMatchUser(t, recorder.Body, user) }, }, } swagger 使用 swagger ui 12fs := http.FileServer(http.Dir(&quot;./doc/swagger&quot;))mux.Handle(&quot;/swagger/&quot;, http.StripPrefix(&quot;/swagger/&quot;, fs)) 添加 swagger 文件中的项目信息 12345678910111213import &quot;protoc-gen-openapiv2/options/annotations.proto&quot;;option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = { info: { title: &quot;simple Bank API&quot;; version: &quot;1.0&quot;; contact: { name: &quot;Don't Serious&quot;; url: &quot;https://github.com/DontSerious/simpleBank&quot;; email: &quot;none@example.com&quot;; }; };}; zerolog app.env 1ENVIRONMENT=dev 设置不为dev时，logger 打印格式为 json grpc 1234// loggergrpcLogger := grpc.UnaryInterceptor(util.GRPCLogger)gRPCServer := grpc.NewServer(grpcLogger) HTTP 以 middleware 形式作用 123log.Info().Msgf(&quot;start HTTP server at %s&quot;, listener.Addr().String())handler := util.HTTPLogger(mux)err = http.Serve(listener, handler) 自定义 ResponseRecorder 获取 body 和 statusCode 信息供 logger 打印 1234567891011121314151617181920212223242526272829303132333435363738394041type ResponseRecorder struct { http.ResponseWriter StatusCode int Body []byte}func (rec *ResponseRecorder) WriteHeader(statusCode int) { rec.StatusCode = statusCode rec.ResponseWriter.WriteHeader(statusCode)}func (rec *ResponseRecorder) Write(body []byte) (int, error) { rec.Body = body return rec.ResponseWriter.Write(body)}// middlewarefunc HTTPLogger(handler http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { startTime := time.Now() rec := &amp;ResponseRecorder{ ResponseWriter: w, StatusCode: http.StatusOK, } handler.ServeHTTP(rec, r) duration := time.Since(startTime) logger := log.Info() if rec.StatusCode != http.StatusOK { logger = log.Error().Bytes(&quot;body&quot;, rec.Body) } logger.Str(&quot;protocol&quot;, &quot;http&quot;). Str(&quot;method&quot;, r.Method). Str(&quot;path&quot;, r.RequestURI). Int(&quot;status_code&quot;, rec.StatusCode). Str(&quot;status_text&quot;, http.StatusText(rec.StatusCode)). Dur(&quot;duration&quot;, duration). Msg(&quot;received a HTTP request&quot;) })} asynq 使用 redis 实现队列，让服务器异步执行自定义的 task Distributor（分发器）：负责将任务分配给可用处理器（processors）的组件。它的主要职责是将待执行的任务从任务队列中取出，并将其分发给处理器进行处理。Distributor 负责任务的调度和分配，以确保任务能够按照适当的顺序和优先级执行。 Processor（处理器）：实际执行异步任务的组件。当 Distributor 将任务分配给处理器时，处理器会负责执行任务所需的操作。处理器根据任务的类型和属性执行相应的处理逻辑，并负责处理任务执行过程中可能出现的错误和异常情况。 SQL dbml cli 快速生成 sql 123npm install -g @dbml/clidbml2sql --postgres -o doc/shecma.sql doc/db.dbml docs 根据 dbml 部署 docs 页面 1234567npm install -g dbdocsdbdocs logindbdocs build doc/db.dbmldbdocs password --set tomato --project simple_bank sqlc 表查询设计 account 12345678910111213141516171819202122232425262728293031323334353637383940-- name: CreateAccount :oneINSERT INTO accounts ( owner, balance, currency) VALUES ( $1, $2, $3) RETURNING *;-- name: GetAccount :oneSELECT * FROM accountsWHERE id = $1 LIMIT 1;-- name: GetAccountForUpdate :oneSELECT * FROM accountsWHERE id = $1 LIMIT 1FOR NO KEY UPDATE;-- name: ListAccounts :manySELECT * FROM accountsORDER BY idLIMIT $1OFFSET $2;-- name: UpdateAccount :oneUPDATE accountsSET balance = $2WHERE id = $1RETURNING *;-- name: AddAccountBalance :oneUPDATE accountsSET balance = balance + sqlc.arg(amount)WHERE id = sqlc.arg(id)RETURNING *;-- name: DeleteAccount :execDELETE FROM accountsWHERE id = $1; GetAccountForUpdate FOR UPDATE 解决并发查询问题 NO KEY 指明此查询未涉及修改 key，防止死锁 AddAccountBalance sqlc.arg(amount) 指明生成结构体的参数名 Mock 创建测试用例 创建 test 新建 controller 新建 store 存储并传入 controller 执行 store.EXPECT() 创建 stubs 指定测试流程 启动测试服务器 使用 httptest 包创建 Recorder 记录响应 使用 http 包创建请求并发送 解析 recorder 完成测试 创建测试集 12345678910111213141516171819202122testCases := []struct { name string accountID int64 buildStubs func(store *mockDB.MockStore) checkResponse func(t *testing.T, recorder *httptest.ResponseRecorder) }{ { name: &quot;OK&quot;, accountID: account.ID, buildStubs: func(store *mockDB.MockStore) { store.EXPECT(). GetAccount(gomock.Any(), gomock.Eq(account.ID)). Times(1). Return(account, nil) }, checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) { require.Equal(t, http.StatusOK, recorder.Code) requireBodyMatchAccount(t, recorder.Body, account) }, }, }} 启动 gin 测试模式 1234func TestMain(m *testing.M) { gin.SetMode(gin.TestMode) os.Exit(m.Run())} Gin Validator 使用 go 的 go-playground/validator/v10 和 gin 的 binding 包对 api 查询参数进行解析，对请求发送的参数内容进行限制 util/validator.go 123456789101112import ( &quot;github.com/go-playground/validator/v10&quot;)var ValidCurrency validator.Func = func(fieldLevel validator.FieldLevel) bool { if currency, ok := fieldLevel.Field().Interface().(string); ok { // 自定义方法 return IsSupportedCurrency(currency) } return false} 12345678910111213const ( USD = &quot;USD&quot; EUR = &quot;EUR&quot; CAD = &quot;CAD&quot;)func IsSupportedCurrency(currency string) bool { switch currency { case USD, EUR, CAD: return true } return false} server.go 123456789101112131415161718func NewServer(store db.Store) *Server { server := &amp;Server{store: store} router := gin.Default() // 注册自定义的validator，名为currency if v, ok := binding.Validator.Engine().(*validator.Validate); ok { v.RegisterValidation(&quot;currency&quot;, util.ValidCurrency) } router.POST(&quot;/accounts&quot;, server.createAccount) router.GET(&quot;/accounts/:id&quot;, server.getAccount) router.GET(&quot;/accounts&quot;, server.listAccount) router.POST(&quot;/transfer&quot;, server.createTransfer) server.router = router return server} 使用方法： 在 binding 处添加自定义的 validator 名即可 123456type transferRequest struct { FromAccountID int64 `json:&quot;from_account_id&quot; binding:&quot;required,min=1&quot;` ToAccountID int64 `json:&quot;to_account_id&quot; binding:&quot;required,min=1&quot;` Amount int64 `json:&quot;amount&quot; binding:&quot;required,gt=0&quot;` Currency string `json:&quot;currency&quot; binding:&quot;required,currency&quot;`} gRPC protobuf install 12345sudo apt install -y protobuf-compilergo install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 Evans 开启反射，让 evans 可以读取 123gRPCServer := grpc.NewServer()pb.RegisterSimpleBankServer(gRPCServer, server)reflection.Register(gRPCServer) 1234567891011121314# 进入服务器evans -r repl --port 9797 --host localhost# 查看包show package# 选择包package pb# 选择服务service simplebank# 执行call ... gateway 使用 gateway 转换 http 请求让服务器可以处理 http 请求并返回网页可读取的 json 格式数据 tip testing 跳过测试 在需要跳过的地方添加以下代码 123if testing.Short() { t.skip()} 测试时添加 -short 1go test -v -cover -short ./...","link":"/Project/simpleBank/"},{"title":"Bash脚本编程","text":"基础 创建 1touch hello.sh hello.sh 12#!/bin/bashecho &quot;Hello World&quot; 执行 1234bash hello.shchmod u+x hello.sh./hello.sh 变量 1234#!/bin/bashvar=valueecho $var 传递参数变量 1./my_script.sh arg1 arg2 在脚本中，你可以使用 $1 来代表第 1 个参数，用 $2 来代表第 2 个参数，以此类推。$0 是一个特殊变量，它代表正在运行的脚本的名字。 12345#!/bin/bashecho &quot;Script name is: $0&quot;echo &quot;First argument is: $1&quot;echo &quot;Second argument is: $2&quot; 1234./argument.sh abhishek prakashScript name is: ./argument.shFirst argument is: abhishekSecond argument is: prakash 特殊变量 特殊变量 描述 $0 脚本名称 $1、$2… $9 脚本参数 ${n} 10 到 255 的脚本参数 $# 参数数量 $@ 所有参数一起 $$ 当前 shell 的进程 id $! 最后执行命令的进程 id $? 最后执行命令的退出状态 read 可以使用 read -p 命令提示用户进行键盘输入，而不需要 echo 命令。 12345#!/bin/bashecho &quot;What is your name, stranger?&quot;read nameread -p &quot;What's your full name, $name? &quot; full_nameecho &quot;Welcome, $full_name&quot; 12345$ ./argument.shWhat is your name, stranger?abhishekWhat's your full name, abhishek? abhishek prakashWelcome, abhishek prakash 执行算术运算 语法 1$((arithmetic_operation)) 操作符 描述 + 加法 - 减法 * 乘法 / 整数除法（没有小数） % 模运算（只余） ** 指数（a 的 b 次方） 1234567#!/bin/bashread -p &quot;Enter first number: &quot; num1read -p &quot;Enter second number: &quot; num2sum=$(($num1+$num2))sub=$(($num1-$num2))echo &quot;The summation of $num1 and $num2 is $sum&quot;echo &quot;The substraction of $num2 from $num1 is $sub&quot; 浮点运算 bc 12345#!/bin/bashnum1=50num2=6result=$(echo &quot;$num1/$num2&quot; | bc -l)echo &quot;The result is $result&quot; 数组 1234567891011#!/bin/bashdistros=(Ubuntu Fedora SUSE &quot;Arch Linux&quot; Nix)# 访问${array_name[N]}# 显示所有元素${array[*]}# 获取数组长度${#array_name[@]} 字符串 1234567891011121314# 获取字符串长度${#string}# 连接字符串str3=$str1$str2# 提取子串${string:$pos:$len}# 替换${string/substr1/substr2}# 删除字串${string/substring} 条件语句 注意使用 [ ... ]; 和 then 。 12345678910111213# ifif [ condition ]; then # code fi# if-elseif [ expression ]; then ## execute this block if condition is true else go to nextelif [ expression ]; then ## execute this block if condition is true else go to nextelse ## if none of the above conditions are true, execute this blockfi -eq 数值比较 条件 当…时，等同于 true $a -lt $b $a &lt; $b （$a 是小于 $b） $a -gt $b $a &gt; $b （$a 是大于 $b） $a -le $b $a &lt;= $b （$a 是小于或等于 $b） $a -ge $b $a &gt;= $b （$a 是大于或等于 $b） $a -eq $b $a == $b （$a 等于 $b） $a -ne $b $a != $b （$a 不等于 $b） 字符串比较 条件 当…时，等同于 true &quot;$a&quot; = &quot;$b&quot; $a 等同于 $b &quot;$a&quot; == &quot;$b&quot; $a 等同于 $b &quot;$a&quot; != &quot;$b&quot; $a 不同于 $b -z &quot;$a&quot; $a 是空的 检查文件类型 条件 当…时，等同于 true -f $a $a 是一个文件 -d $a $a 是一个目录 -L $a $a 是一个链接 要特别注意空格。开括号和闭括号、条件之间必须有空格。同样地，条件操作符（-le、== 等）之前和之后必须有空格。 循环 For 1234#!/bin/bashfor num in {1..10}; do echo $numdone While 123456#!/bin/bashnum=1while [ $num -le 10 ]; do echo $num num=$(($num+1))done Until 123456#!/bin/bashnum=1until [ $num -gt 10 ]; do echo $num num=$(($num+1))done while 循环在条件为真时运行，而 until 循环在条件为假时运行。 函数 123function_name() { commands} 1234567#!/bin/bashsum() { sum=$(($1+$2)) echo &quot;The sum of $1 and $2 is: $sum&quot;}echo &quot;Let's use the sum function&quot;sum 1 5 Bash 的模式扩展 简介 Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。 这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。 波浪线扩展 ? 字符扩展 * 字符扩展 方括号扩展 大括号扩展 变量扩展 子命令扩展 算术扩展 本章介绍这八种扩展。 Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。 模块扩展的英文单词是globbing，这个词来自于早期的 Unix 系统有一个/etc/glob文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。 模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。 Bash 允许用户关闭扩展。 123$ set -o noglob# 或者$ set -f 下面的命令可以重新打开扩展。 123$ set +o noglob# 或者$ set +f 波浪线扩展 波浪线~会自动扩展成当前用户的主目录。 12$ echo ~/home/me ~/dir表示扩展成主目录的某个子目录，dir是主目录里面的一个子目录名。 12# 进入 /home/me/foo 目录$ cd ~/foo ~user表示扩展成用户user的主目录。 12345$ echo ~foo/home/foo$ echo ~root/root 上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。 如果~user的user是不存在的用户名，则波浪号扩展不起作用。 12$ echo ~nonExistedUser~nonExistedUser ~+会扩展成当前所在的目录，等同于pwd命令。 123$ cd ~/foo$ echo ~+/home/me/foo ? 字符扩展 ?字符代表文件路径里面的任意单个字符，不包括空字符。比如，Data???匹配所有Data后面跟着三个字符的文件名。 123# 存在文件 a.txt 和 b.txt$ ls ?.txta.txt b.txt 上面命令中，?表示单个字符，所以会同时匹配a.txt和b.txt。 如果匹配多个字符，就需要多个?连用。 123# 存在文件 a.txt、b.txt 和 ab.txt$ ls ??.txtab.txt 上面命令中，??匹配了两个字符。 ? 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。 1234567# 当前目录有 a.txt 文件$ echo ?.txta.txt# 当前目录为空目录$ echo ?.txt?.txt 上面例子中，如果?.txt可以扩展成文件名，echo命令会输出扩展后的结果；如果不能扩展成文件名，echo就会原样输出?.txt。 * 字符扩展 *字符代表文件路径里面的任意数量的任意字符，包括零个字符。 123# 存在文件 a.txt、b.txt 和 ab.txt$ ls *.txta.txt b.txt ab.txt 上面例子中，*.txt代表后缀名为.txt的所有文件。 如果想输出当前目录的所有文件，直接用*即可。 1$ ls * *可以匹配空字符，下面是一个例子。 123456# 存在文件 a.txt、b.txt 和 ab.txt$ ls a*.txta.txt ab.txt$ ls *b*b.txt ab.txt 注意，*不会匹配隐藏文件（以.开头的文件），即ls *不会输出隐藏文件。 如果要匹配隐藏文件，需要写成.*。 12# 显示所有隐藏文件$ echo .* 如果要匹配隐藏文件，同时要排除.和..这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成.[!.]*。 1$ echo .[!.]* 注意，*字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。 123# 当前目录不存在 c 开头的文件$ echo c*.txtc*.txt 上面例子中，当前目录里面没有c开头的文件，导致c*.txt会原样输出。 *只匹配当前目录，不会匹配子目录。 123456# 子目录有一个 a.txt# 无效的写法$ ls *.txt# 有效的写法$ ls */*.txt 上面的例子，文本文件在子目录，*.txt不会产生匹配，必须写成*/*.txt。有几层子目录，就必须写几层星号。 Bash 4.0 引入了一个参数globstar，当该参数打开时，允许**匹配零个或多个子目录。因此，**/*.txt可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面shopt命令的介绍。 方括号扩展 方括号扩展的形式是[...]，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，[aeiou]可以匹配五个元音字母中的任意一个。 1234567# 存在文件 a.txt 和 b.txt$ ls [ab].txta.txt b.txt# 只存在文件 a.txt$ ls [ab].txta.txt 上面例子中，[ab]可以匹配a或b，前提是确实存在相应的文件。 方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。 123# 不存在文件 a.txt 和 b.txt$ ls [ab].txtls: 无法访问'[ab].txt': 没有那个文件或目录 上面例子中，由于扩展后的文件不存在，[ab].txt就原样输出了，导致ls命名报错。 方括号扩展还有两种变体：[^...]和[!...]。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，[^abc]或[!abc]表示匹配除了a、b、c以外的字符。 123# 存在 aaa、bbb、aba 三个文件$ ls ?[!a]?aba bbb 上面命令中，[!a]表示文件名第二个字符不是a的文件名，所以返回了aba和bbb两个文件。 注意，如果需要匹配[字符，可以放在方括号内，比如[[aeiou]。如果需要匹配连字号-，只能放在方括号内部的开头或结尾，比如[-aeiou]或[aeiou-]。 [start-end] 扩展 方括号扩展有一个简写形式[start-end]，表示匹配一个连续的范围。比如，[a-c]等同于[abc]，[0-9]匹配[0123456789]。 123456789101112# 存在文件 a.txt、b.txt 和 c.txt$ ls [a-c].txta.txtb.txtc.txt# 存在文件 report1.txt、report2.txt 和 report3.txt$ ls report[0-9].txtreport1.txtreport2.txtreport3.txt... 下面是一些常用简写的例子。 [a-z]：所有小写字母。 [a-zA-Z]：所有小写字母与大写字母。 [a-zA-Z0-9]：所有小写字母、大写字母与数字。 [abc]*：所有以a、b、c字符之一开头的文件名。 program.[co]：文件program.c与文件program.o。 BACKUP.[0-9][0-9][0-9]：所有以BACKUP.开头，后面是三个数字的文件名。 这种简写形式有一个否定形式[!start-end]，表示匹配不属于这个范围的字符。比如，[!a-zA-Z]表示匹配非英文字母的字符。 12$ ls report[!1–3].txtreport4.txt report5.txt 上面代码中，[!1-3]表示排除1、2和3。 大括号扩展 大括号扩展{...}表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，{1,2,3}扩展成1 2 3。 12345678$ echo {1,2,3}1 2 3$ echo d{a,e,i,u,o}gdag deg dig dug dog$ echo Front-{A,B,C}-BackFront-A-Back Front-B-Back Front-C-Back 注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。 1234$ ls {a,b,c}.txtls: 无法访问'a.txt': 没有那个文件或目录ls: 无法访问'b.txt': 没有那个文件或目录ls: 无法访问'c.txt': 没有那个文件或目录 上面例子中，即使不存在对应的文件，{a,b,c}依然扩展成三个文件名，导致ls命令报了三个错误。 另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。 12$ echo {1 , 2}{1 , 2} 上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。 逗号前面可以没有值，表示扩展的第一项为空。 1234$ cp a.log{,.bak}# 等同于# cp a.log a.log.bak 大括号可以嵌套。 12345$ echo {j{p,pe}g,png}jpg jpeg png$ echo a{A{1,2},B{3,4}}baA1b aA2b aB3b aB4b 大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。 12345$ echo /bin/{cat,b*}/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...# 基本等同于$ echo /bin/cat;echo /bin/b* 上面例子中，会先进行大括号扩展，然后进行*扩展，等同于执行两条echo命令。 大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。 12$ echo {cat,dog}cat dog 由于大括号扩展{...}不是文件名扩展，所以它总是会扩展的。这与方括号扩展[...]完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。 123456# 不存在 a.txt 和 b.txt$ echo [ab].txt[ab].txt$ echo {a,b}.txta.txt b.txt 上面例子中，如果不存在a.txt和b.txt，那么[ab].txt就会变成一个普通的文件名，而{a,b}.txt可以照样扩展。 {start…end} 扩展 大括号扩展有一个简写形式{start..end}，表示扩展成一个连续序列。比如，{a..z}可以扩展成26个小写英文字母。 1234567891011$ echo {a..c}a b c$ echo d{a..d}gdag dbg dcg ddg$ echo {1..4}1 2 3 4$ echo Number_{1..5}Number_1 Number_2 Number_3 Number_4 Number_5 这种简写形式支持逆序。 12345$ echo {c..a}c b a$ echo {5..1}5 4 3 2 1 注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。 12$ echo {a1..3c}{a1..3c} 这种简写形式可以嵌套使用，形成复杂的扩展。 12$ echo .{mp{3..4},m4{a,b,p,v}}.mp3 .mp4 .m4a .m4b .m4p .m4v 大括号扩展的常见用途为新建一系列目录。 1$ mkdir {2007..2009}-{01..12} 上面命令会新建36个子目录，每个子目录的名字都是”年份-月份“。 这个写法的另一个常见用途，是直接用于for循环。 1234for i in {1..4}do echo $idone 上面例子会循环4次。 如果整数前面有前导0，扩展输出的每一项都有前导0。 12345$ echo {01..5}01 02 03 04 05$ echo {001..5}001 002 003 004 005 这种简写形式还可以使用第二个双点号（start..end..step），用来指定扩展的步长。 12$ echo {0..8..2}0 2 4 6 8 上面代码将0扩展到8，每次递增的长度为2，所以一共输出5个数字。 多个简写形式连用，会有循环处理的效果。 12$ echo {a..c}{1..3}a1 a2 a3 b1 b2 b3 c1 c2 c3 变量扩展 Bash 将美元符号$开头的词元视为变量，将其扩展成变量值，详见《Bash 变量》一章。 12$ echo $SHELL/bin/bash 变量名除了放在美元符号后面，也可以放在${}里面。 12$ echo ${SHELL}/bin/bash ${!string*}或${!string@}返回所有匹配给定字符串string的变量名。 12$ echo ${!S*}SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK 上面例子中，${!S*}扩展成所有以S开头的变量名。 子命令扩展 $(...)可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。 12$ echo $(date)Tue Jan 28 00:01:13 CST 2020 上面例子中，$(date)返回date命令的运行结果。 还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。 12$ echo `date`Tue Jan 28 00:01:13 CST 2020 $(...)可以嵌套，比如$(ls $(pwd))。 算术扩展 $((...))可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。 12$ echo $((2 + 2))4 字符类 [[:class:]]表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。 [[:alnum:]]：匹配任意英文字母与数字 [[:alpha:]]：匹配任意英文字母 [[:blank:]]：空格和 Tab 键。 [[:cntrl:]]：ASCII 码 0-31 的不可打印字符。 [[:digit:]]：匹配任意数字 0-9。 [[:graph:]]：A-Z、a-z、0-9 和标点符号。 [[:lower:]]：匹配任意小写字母 a-z。 [[:print:]]：ASCII 码 32-127 的可打印字符。 [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。 [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。 [[:upper:]]：匹配任意大写字母 A-Z。 [[:xdigit:]]：16进制字符（A-F、a-f、0-9）。 请看下面的例子。 1$ echo [[:upper:]]* 上面命令输出所有大写字母开头的文件名。 字符类的第一个方括号后面，可以加上感叹号!，表示否定。比如，[![:digit:]]匹配所有非数字。 1$ echo [![:digit:]]* 上面命令输出所有不以数字开头的文件名。 字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。 123# 不存在以大写字母开头的文件$ echo [[:upper:]]*[[:upper:]]* 上面例子中，由于没有可匹配的文件，字符类就原样输出了。 使用注意点 通配符有一些使用注意点，不可不知。 （1）通配符是先解释，再执行。 Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。 12$ ls a*.txtab.txt 上面命令的执行过程是，Bash 先将a*.txt扩展成ab.txt，然后再执行ls ab.txt。 （2）文件名扩展在不匹配时，会原样输出。 文件名扩展在没有可匹配的文件时，会原样输出。 123# 不存在 r 开头的文件名$ echo r*r* 上面代码中，由于不存在r开头的文件名，r*会原样输出。 下面是另一个例子。 12$ ls *.csvls: *.csv: No such file or directory 另外，前面已经说过，大括号扩展{...}不是文件名扩展。 （3）只适用于单层路径。 所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（/）。 如果要匹配子目录里面的文件，可以写成下面这样。 1$ ls */*.txt Bash 4.0 新增了一个globstar参数，允许**匹配零个或多个子目录，详见后面shopt命令的介绍。 （4）文件名可以使用通配符。 Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号或双引号里面。 123$ touch 'fo*'$ lsfo* 上面代码创建了一个fo*文件，这时*就是文件名的一部分。 量词语法 量词语法用来控制模式匹配的次数。它只有在 Bash 的extglob参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。 12$ shopt extglobextglob on 如果extglob参数是关闭的，可以用下面的命令打开。 1$ shopt -s extglob 量词语法有下面几个。 ?(pattern-list)：模式匹配零次或一次。 *(pattern-list)：模式匹配零次或多次。 +(pattern-list)：模式匹配一次或多次。 @(pattern-list)：只匹配一次模式。 !(pattern-list)：匹配给定模式以外的任何内容。 12$ ls abc?(.)txtabctxt abc.txt 上面例子中，?(.)匹配零个或一个点。 12$ ls abc?(def)abc abcdef 上面例子中，?(def)匹配零个或一个def。 12$ ls abc@(.txt|.php)abc.php abc.txt 上面例子中，@(.txt|.php)匹配文件有且只有一个.txt或.php后缀名。 12$ ls abc+(.txt)abc.txt abc.txt.txt 上面例子中，+(.txt)匹配文件有一个或多个.txt后缀名。 12$ ls a!(b).txta.txt abb.txt ac.txt 上面例子中，!(b)表示匹配单个字母b以外的任意内容，所以除了ab.txt以外，其他文件名都能匹配。 量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。 123# 没有 abc 开头的文件名$ ls abc?(def)ls: 无法访问'abc?(def)': 没有那个文件或目录 上面例子中，由于没有可匹配的文件，abc?(def)就原样输出，导致ls命令报错。 shopt 命令 shopt命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。 shopt命令的使用方法如下。 12345678# 打开某个参数$ shopt -s [optionname]# 关闭某个参数$ shopt -u [optionname]# 查询某个参数关闭还是打开$ shopt [optionname] （1）dotglob 参数 dotglob参数可以让扩展结果包括隐藏文件（即点开头的文件）。 正常情况下，扩展结果不包括隐藏文件。 12$ ls *abc.txt 打开dotglob，就会包括隐藏文件。 123$ shopt -s dotglob$ ls *abc.txt .config （2）nullglob 参数 nullglob参数可以让通配符不匹配任何文件名时，返回空字符。 默认情况下，通配符不匹配任何文件名时，会保持不变。 12$ rm b*rm: 无法删除'b*': 没有那个文件或目录 上面例子中，由于当前目录不包括b开头的文件名，导致b*不会发生文件名扩展，保持原样不变，所以rm命令报错没有b*这个文件。 打开nullglob参数，就可以让不匹配的通配符返回空字符串。 123$ shopt -s nullglob$ rm b*rm: 缺少操作数 上面例子中，由于没有b*匹配的文件名，所以rm b*扩展成了rm，导致报错变成了”缺少操作数“。 （3）failglob 参数 failglob参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。 123$ shopt -s failglob$ rm b*bash: 无匹配: b* 上面例子中，打开failglob以后，由于b*不匹配任何文件名，Bash 直接报错了，不再让rm命令去处理。 （4）extglob 参数 extglob参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。 12$ shopt extglobextglob on 它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。 1$ shopt -u extglob （5）nocaseglob 参数 nocaseglob参数可以让通配符扩展不区分大小写。 12345$ shopt -s nocaseglob$ ls /windows/program*/windows/ProgramData/windows/Program Files/windows/Program Files (x86) 上面例子中，打开nocaseglob以后，program*就不区分大小写了，可以匹配ProgramData等。 （6）globstar 参数 globstar参数可以使得**匹配零个或多个子目录。该参数默认是关闭的。 假设有下面的文件结构。 123a.txtsub1/b.txtsub1/sub2/c.txt 上面的文件结构中，顶层目录、第一级子目录sub1、第二级子目录sub1\\sub2里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？ 默认情况下，只能写成下面这样。 12$ ls *.txt */*.txt */*/*.txta.txt sub1/b.txt sub1/sub2/c.txt 这是因为*只匹配当前目录，如果要匹配子目录，只能一层层写出来。 打开globstar参数以后，**匹配零个或多个子目录。因此，**/*.txt就可以得到想要的结果。 123$ shopt -s globstar$ ls **/*.txta.txt sub1/b.txt sub1/sub2/c.txt 参考链接 Think You Understand Wildcards? Think Again Advanced Wildcard Patterns Most People Don’t Know Bash 简介 - Bash 脚本教程 - 网道 (wangdoc.com)","link":"/Tutorial/Bash%20script/"},{"title":"Deciding which Type to Use","text":"Use an unsigned type when you know that the vales cannot be negative. Use int for integer arithmetic, short is usually too small and, in practice, long often has the same size as int. If your data values are larger than the minimum guaranteed size as int, then use long long. Do not use plain char or bool in arithmetic expressions. Use them only to hold characters or truth values. Computations using char are especially problematic because char is signed on some machines and unsigned on others. If you need a tiny integer, explicitly specify either signed char or unsigned char. Use double for floating-point computations; float usually does not have enough precision, and the cost of double-precision calculations versus single-precision is negligible. In fact, on some machines, double-precision operations are faster than single. The precision offered by long double usually is unnecessary and often entails considerable run-time cost.","link":"/BackEnd/cpp/Deciding-which-Type-to-Use/"},{"title":"IO","text":"标准错误流（cerr） 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 12345678910#include &lt;iostream&gt; using namespace std; int main( ){ char str[] = &quot;Unable to read....&quot;; cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;} Error message : Unable to read… 标准日志流（clog） 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 12345678910#include &lt;iostream&gt; using namespace std; int main( ){ char str[] = &quot;Unable to read....&quot;; clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;} Error message : Unable to read… 使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 sort from 菜鸟教程","link":"/BackEnd/cpp/IO/"},{"title":"OOP class","text":"类定义 123456789101112131415161718192021222324// 关键字 类名class Box{ // 默认为private double length; // 变量 public: // 访问修饰符：private/public/protected double breadth; double height; // 内部定义函数 double getV(void) { return length * breadth * height; } // 外部定义函数 void set( double len, double bre, double hei );}; // 分号结束一个类// 成员函数定义void Box::set(double len, double bre, double hei){ length = len; breadth = bre; height = hei;} 构造函数 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。 构造函数可用于为某些成员变量设置初始值。 sort from 菜鸟教程","link":"/BackEnd/cpp/OOP-class/"},{"title":"ctime","text":"ctime常用函数 time() time_t time(time_t *seconds) seconds – 这是指向类型为 time_t 的对象的指针，用来存储 seconds 的值。 用法 1time_t seconds = time(NULL); 12time_t seconds;time( &amp;seconds ); ctime() char *ctime(const time_t *timer) timer – 这是指向 time_t 对象的指针，该对象包含了一个日历时间。 返回：Www Mmm dd hh:mm:ss yyyy localtime() 和 asctime() struct tm *localtime(const time_t *timer) timer – 这是指向表示日历时间的 time_t 值的指针。 char *asctime(const struct tm *timeptr) struct tm *timeptr – 指的是结构体tm localtime() 使用 time_t *timer 生成 结构体tm asctime() 将 结构体tm 转换为字符串形式 cpp安全问题 在Visual Studio 2015里使用asctime函数报错C4996提示asctime不安全，建议使用asctime_s代替。与localtime_s结合使用： 12345678910111213141516#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int main(){ struct tm t; //tm结构指针 char stTmp[32]; time_t now; //声明time_t类型变量 time(&amp;now); //获取系统日期和时间 localtime_s(&amp;t, &amp;now); //获取当地日期和时间 asctime_s(stTmp, &amp;t); cout &lt;&lt; stTmp &lt;&lt; endl; return 0;} 结构体 tm 1234567891011struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时}; 针对计算程序执行时间问题使用clock_t clock(void); sort from 菜鸟教程","link":"/BackEnd/cpp/ctime/"},{"title":"rand()","text":"在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。 下面是一个关于生成随机数的简单实例。实例中使用了 time() 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;using namespace std; int main (){ int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i &lt; 10; i++ ){ // 生成实际的随机数 j= rand(); cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; } return 0;} copy from w3c","link":"/BackEnd/cpp/rand/"},{"title":"C++ 引用","text":"和指针的差别 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 把引用作为参数 支持把引用作为参数传给函数，这比传一般的参数更安全。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std; // 函数声明void swap(int&amp; x, int&amp; y); int main (){ // 局部变量声明 int a = 100; int b = 200; cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl; /* 调用函数来交换值 */ swap(a, b); cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl; return 0;} // 函数定义void swap(int&amp; x, int&amp; y){ int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return;} 1234交换前，a 的值： 100交换前，b 的值： 200交换后，a 的值： 200交换后，b 的值： 100 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。 C++ 函数可以返回一个引用，方式与返回一个指针类似。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt; using namespace std; double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0}; double&amp; setValues(int i) { double&amp; ref = vals[i]; return ref; // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]} // 要调用上面定义函数的主函数int main (){ cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) { cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; vals[i] &lt;&lt; endl; } setValues(1) = 20.23; // 改变第 2 个元素 setValues(3) = 70.8; // 改变第 4 个元素 cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) { cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; vals[i] &lt;&lt; endl; } return 0;} 123456789101112改变前的值vals[0] = 10.1vals[1] = 12.6vals[2] = 33.1vals[3] = 24.1vals[4] = 50改变后的值vals[0] = 10.1vals[1] = 20.23vals[2] = 33.1vals[3] = 70.8vals[4] = 50","link":"/BackEnd/cpp/reference/"},{"title":"C# 高级","text":"IO 文件类File来自System.IO命名空间，允许我们处理文件 方法 描述 AppendText() 在现有文件末尾追加文本 Copy() 复制文件 Create() 创建或覆盖文件 Delete() 删除文件 Exists() 测试文件是否存在 ReadAllText() 读取文件的内容 Replace() 用另一个文件的内容替换文件的内容 WriteAllText() 创建新文件并将内容写入其中。如果文件已经存在，它将被覆盖。 实例 1234567using System.IO; // 包括 System.IO 命名空间string writeText = &quot;Hello World!&quot;; // 创建文本字符串File.WriteAllText(&quot;filename.txt&quot;, writeText); // 创建一个文件并将 writeText 的内容写入其中string readText = File.ReadAllText(&quot;filename.txt&quot;); // 读取文件内容Console.WriteLine(readText); // 输出内容 Hello World! 异常处理 try 语句允许您定义要在执行时测试错误的代码块。 catch 语句允许您定义要执行的代码块，如果 try 块中发生错误。 finally 语句允许您在 try...catch 之后执行代码，而不管结果如何 实例 12345678910111213try{ int[] myNumbers = {1, 2, 3}; Console.WriteLine(myNumbers[10]);}catch (Exception e){ Console.WriteLine(&quot;Something went wrong.&quot;);}finally{ Console.WriteLine(&quot;The 'try catch' is finished.&quot;);} throw 语句 throw 语句允许您创建自定义错误。 throw 语句与异常类exception class一起使用。 C# 中有许多可用的异常类： ArithmeticException, FileNotFoundException, IndexOutOfRangeException, TimeOutException等 实例 12345678910111213141516static void checkAge(int age){ if (age &lt; 18) { throw new ArithmeticException(&quot;Access denied - You must be at least 18 years old.&quot;); } else { Console.WriteLine(&quot;Access granted - You are old enough!&quot;); }}static void Main(string[] args){ checkAge(15);} System.ArithmeticException: ‘Access denied - You must be at least 18 years old.’ 运算符重载 您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。 实例 12345678public static Box operator + (Box b, Box c){ Box box = new Box(); box.length = b.length + c.length; box.breadth = b.breadth + c.breadth; box.height = b.height + c.height; return box;} 上面的函数为用户自定义的类 Box 实现了加法运算符（+）。它把两个 Box 对象的属性相加，并返回相加后的 Box 对象。 可重载和不可重载运算符 运算符 描述 +, -, !, ~, ++, – 这些一元运算符只有一个操作数，且可以被重载。 +, -, *, /, % 这些二元运算符带有两个操作数，且可以被重载。 ==, !=, &lt;, &gt;, &lt;=, &gt;= 这些比较运算符可以被重载。 &amp;&amp;, || 这些条件逻辑运算符不能被直接重载。 +=, -=, *=, /=, %= 这些赋值运算符不能被重载。 =, ., ?:, -&gt;, new, is, sizeof, typeof 这些运算符不能被重载。 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static bool operator == (Box lhs, Box rhs) { bool status = false; if (lhs.length == rhs.length &amp;&amp; lhs.height == rhs.height &amp;&amp; lhs.breadth == rhs.breadth) { status = true; } return status; } public static bool operator !=(Box lhs, Box rhs) { bool status = false; if (lhs.length != rhs.length || lhs.height != rhs.height || lhs.breadth != rhs.breadth) { status = true; } return status; } public static bool operator &lt;(Box lhs, Box rhs) { bool status = false; if (lhs.length &lt; rhs.length &amp;&amp; lhs.height &lt; rhs.height &amp;&amp; lhs.breadth &lt; rhs.breadth) { status = true; } return status; } public static bool operator &gt;(Box lhs, Box rhs) { bool status = false; if (lhs.length &gt; rhs.length &amp;&amp; lhs.height &gt; rhs.height &amp;&amp; lhs.breadth &gt; rhs.breadth) { status = true; } return status; } public static bool operator &lt;=(Box lhs, Box rhs) { bool status = false; if (lhs.length &lt;= rhs.length &amp;&amp; lhs.height &lt;= rhs.height &amp;&amp; lhs.breadth &lt;= rhs.breadth) { status = true; } return status; } public static bool operator &gt;=(Box lhs, Box rhs) { bool status = false; if (lhs.length &gt;= rhs.length &amp;&amp; lhs.height &gt;= rhs.height &amp;&amp; lhs.breadth &gt;= rhs.breadth) { status = true; } return status; } public override string ToString() { return String.Format(&quot;({0}, {1}, {2})&quot;, length, breadth, height); } 结构体(struct) 在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构体。 12345678910111213141516171819202122struct Books{ private string title; private string author; private string subject; private int book_id; public void setValues(string t, string a, string s, int id) { title = t; author = a; subject = s; book_id =id; } public void display() { Console.WriteLine(&quot;Title : {0}&quot;, title); Console.WriteLine(&quot;Author : {0}&quot;, author); Console.WriteLine(&quot;Subject : {0}&quot;, subject); Console.WriteLine(&quot;Book_id :{0}&quot;, book_id); }}; 特点 您已经用了一个简单的名为 Books 的结构。在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点： 结构可带有方法、字段、索引、属性、运算符方法和事件。 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。 与类不同，结构不能继承其他的结构或类。 结构不能作为其他结构或类的基础结构。 结构可实现一个或多个接口。 结构成员不能指定为 abstract、virtual 或 protected。 当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。 命名空间(namespace) 命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。 为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面。 例如：namespace_name.item_name; 命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间 12345678910111213141516171819202122232425262728using System;using SomeNameSpace;using SomeNameSpace.Nested;namespace SomeNameSpace{ public class MyClass { static void Main() { Console.WriteLine(&quot;In SomeNameSpace&quot;); Nested.NestedNameSpaceClass.SayHello(); } } // 内嵌命名空间 namespace Nested { public class NestedNameSpaceClass { public static void SayHello() { Console.WriteLine(&quot;In Nested&quot;); } } }} In SomeNameSpace In Nested","link":"/BackEnd/cs/Advanced/"},{"title":"C# OOP","text":"属性 12345678910111213141516class Person{ private string name; // 方法 // 以下写法可以使用get，set public string Name // 属性 { get { return name; } set { name = value; } }}// 以下简写产生同样结果class Person{ public string Name // property { get; set; }} 继承 要从类继承，请使用 : 符号。 12345678910111213class Vehicle // 基类（父类）{ public string brand = &quot;Ford&quot;; // Vehicle 字段 public void honk() // Vehicle 方法 { Console.WriteLine(&quot;Tuut, tuut!&quot;); }}class Car : Vehicle // 派生类（子）{ public string modelName = &quot;Mustang&quot;; // Car 字段} 密封关键字 如果不希望其他类从类继承，请使用sealed关键字 123456789sealed class Vehicle { ...}class Car : Vehicle { ...} 多态 C#提供了一个重写基类方法的选项，方法是将virtual关键字添加到基类内的方法，并对每个派生类方法使用override关键字： 12345678910111213141516171819202122232425262728293031323334353637class Animal // 基类（父类）{ public virtual void animalSound() { Console.WriteLine(&quot;The animal makes a sound&quot;); }}class Pig : Animal // 派生类（子）{ public override void animalSound() { Console.WriteLine(&quot;The pig says: wee wee&quot;); }}class Dog : Animal // 派生类（子）{ public override void animalSound() { Console.WriteLine(&quot;The dog says: bow wow&quot;); }}class Program { static void Main(string[] args) { Animal myAnimal = new Animal(); // 创建一个 Animal 对象 Animal myPig = new Pig(); // 创建 Pig 对象 Animal myDog = new Dog(); // 创建 Dog 对象 myAnimal.animalSound(); myPig.animalSound(); myDog.animalSound(); }} 输出： 123The animal makes a soundThe pig says: wee weeThe dog says: bow wow 抽象类 使用abstract关键字 12345678910111213141516171819202122232425262728293031// 抽象类abstract class Animal{ // 抽象方法（没有主体） public abstract void animalSound(); // 常规方法 public void sleep() { Console.WriteLine(&quot;Zzz&quot;); }}// 派生类（继承自 Animal）class Pig : Animal{ public override void animalSound() { // 这里提供了 animalSound() 的主体 Console.WriteLine(&quot;The pig says: wee wee&quot;); }}class Program{ static void Main(string[] args) { Pig myPig = new Pig(); // 创建 Pig 对象 myPig.animalSound(); // 调用抽象方法 myPig.sleep(); // 调用常规方法 }} 接口 要访问接口方法，接口必须由另一个类实现(类似于继承)。要实现接口，请使用:符号(与继承一样)。接口方法的主体由&quot;implement&quot;类提供。 注意，在实现接口时，不必使用override 关键字 可实现多个接口 123456789101112131415161718192021222324252627282930313233// 接口interface IFirstInterface { void myMethod(); // 接口方法}interface ISecondInterface { void myOtherMethod(); // 接口方法}// 实现多个接口class DemoClass : IFirstInterface, ISecondInterface { public void myMethod() { Console.WriteLine(&quot;Some text..&quot;); } public void myOtherMethod() { Console.WriteLine(&quot;Some other text...&quot;); }}class Program { static void Main(string[] args) { DemoClass myObj = new DemoClass(); myObj.myMethod(); myObj.myOtherMethod(); }} 枚举 枚举 enum 是一个特殊的类&quot;class&quot;，它表示一组常量(不可更改/只读变量)。 类内枚举 1234567891011121314class Program{ enum Level { Low, Medium, High } static void Main(string[] args) { Level myVar = Level.Medium; Console.WriteLine(myVar); }} 枚举值 必须进行显示转换为int 可自定义枚举值 12345678910111213141516enum Months{ January, // 0 February, // 1 March=6, // 6 April, // 7 May, // 8 June, // 9 July // 10}static void Main(string[] args){ int myNum = (int) Months.April; Console.WriteLine(myNum);} 输出为7 Switch中的应用 1234567891011121314151617181920212223enum Level { Low, Medium, High}static void Main(string[] args) { Level myVar = Level.Medium; switch(myVar) { case Level.Low: Console.WriteLine(&quot;Low level&quot;); break; case Level.Medium: Console.WriteLine(&quot;Medium level&quot;); break; case Level.High: Console.WriteLine(&quot;High level&quot;); break; }} 输出： Medium level","link":"/BackEnd/cs/OOP/"},{"title":"C# 代码框架","text":"代码框架 123456789namespace HelloWorld{ class Program { static void Main(string[] args) { } }}","link":"/BackEnd/cs/grammar/"},{"title":"GO 协程调度器 GMP","text":"由来 G: goroutine 协程 M: thread 进程 P: processor 处理器 单线程任务：单一流程、进程阻塞 多线程： 设计复杂 进程/线程数量越多，切换成本越大 同步竞争：锁、竞争资源冲突 壁垒 进程内存占用，比如虚拟内存 线程内存占用 高 CPU 调度消耗 协程（co-routine） n:1：无法利用多个 cpu，出现阻塞瓶颈 1:1：与多线程无异 m:n：过于依赖调度器算法和优化，能利用多核 调度器优化： goroutine：内存占用小、切换成本低 早期调度器：基本的全局 go 队列和比较传统的轮询，利用多个 thread 进行调度 早期调度器弊端 创建、销毁、调度 G 都需要每个 M 获取锁，造成激烈的锁竞争 M 转移 G 会造成延迟和额外的系统负载 系统调用（CPU 在 M 之间切换）导致频繁的线程阻塞和取消阻塞操作增加系统开销 模型 P 本地队列： 存放等待的 G 数量限制：256 个 G 新 G 优先放 P 的本地队列，满了采访全局队列 列表： 程序启动时创建 可配置的 GOMAXPROCS 修改 $GOMAXPROCS runtime.GOMAXPROCS() M 列表：操作系统调度器分配到当前程序的内核线程数 数量：GO 语言限定了 M 最大量为 10000，太多了实际上可忽略 SetMaxThreads 函数可设置 有一个 M 阻塞，就会创建一个新的 M 自动空闲回收或者睡眠 策略 复用线程 work stealing P 的本地队列从其他的本地队列偷取 G Hand off 如果 M 执行的 G 进行阻塞操作，则新建或唤醒一个 M 继承它的本地队列 利用并行 设置GOMAXPROCS 限定 P 的个数 抢占 旧：co-routine 主动释放 CPU 新：goroutine 限定 CPU 占用时间，防止其他 G 被饿死 全局 G 队列 当 work stealing 偷不到东西时，从全局队列获取 go func() 流程 创建 入局部队列 局部已满则入全局 M 获取 G 从全局获取 work stealing 调度 执行 若发生 syscall 或者阻塞操作 创建或休眠队列中获取 M 接管当前阻塞 G 的 P 时间片超时返回 生命周期 M0 启动程序后的编号为 0 的主线程 在全局变量 runtime.m0 中，不需要在 heap 上分配 负责执行初始化创作和启动第一个 G 启动第一个 G 之后，M0 就和其他 M 一样了 G0 每次启动一个 M，都会直接创建一个 G0 G0 仅用于负责调度，不指向任何可执行的函数 每一个 M 都有一个自己的 G0 在调度或系统调用时会使用先清楚 G0 再通过 G0 切换到其他的 G M0 的 G0 会放在全局空间 可视化的 GMP go tool trace 12345678910111213141516171819202122232425262728package mainimport ( &quot;os&quot; &quot;fmt&quot; &quot;runtime/trace&quot;)func main() { //创建trace文件 f, err := os.Create(&quot;trace.out&quot;) if err != nil { panic(err) } defer f.Close() //启动trace goroutine err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() //main fmt.Println(&quot;Hello World&quot;)} 1234$ go tool trace trace.out 2020/02/23 10:44:11 Parsing trace...2020/02/23 10:44:11 Splitting trace...2020/02/23 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:33479 Debug trace 12345678910111213package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { for i := 0; i &lt; 5; i++ { time.Sleep(time.Second) fmt.Println(&quot;Hello World&quot;) }} 1$ go build trace2.go 1234567891011$ GODEBUG=schedtrace=1000 ./trace2 SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]Hello WorldSCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello WorldSCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello WorldSCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello WorldSCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]Hello World SCHED：调试信息输出标志字符串，代表本行是 goroutine 调度器的输出； 0ms：即从程序启动到输出这行日志的时间； gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置； idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量； threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量； spinningthreads: 处于自旋状态的os thread数量； idlethread: 处于idle状态的os thread的数量； runqueue=0： Scheduler全局队列中G的数量； [0 0]: 分别为2个P的local queue中的G的数量。","link":"/BackEnd/go/GO%20GMP/"},{"title":"gin笔记","text":"文件上传 前端部分 以 form 的方式提交 data 1234567891011121314151617181920// react antd upload// 自定义上传 const customUpload = async (file: File, path: string) =&gt; { const form = new FormData() form.append(&quot;file&quot;, file) form.append(&quot;path&quot;, path) const resp = await uploadFile(form) } const props: UploadProps = { name: &quot;file&quot;, multiple: true, showUploadList: false, beforeUpload: () =&gt; { isLoading(true) }, customRequest: (options: any) =&gt; { customUpload(options.file, currPath) }, } 后端 1234567891011121314151617181920212223242526272829func UploadFile(c *gin.Context) { var resp *edit.UploadFileResponse var err error // 获取上传的文件信息 path := c.PostForm(&quot;path&quot;) fileSet, err := c.MultipartForm() // 获取所有上传的文件 if err != nil { SendErrResponse(c, errno.ParamErrCode, errno.ParamErr.ErrMsg) return } // 打开文件 form中的name为file for _, file := range fileSet.File[&quot;file&quot;] { fs, err := file.Open() if err != nil { SendErrResponse(c, errno.ParamErrCode, errno.ParamErr.ErrMsg) return } defer fs.Close() // 读取文件内容 fileContent格式为[]byte fileContent, err := io.ReadAll(fs) if err != nil { SendErrResponse(c, errno.ParamErrCode, errno.ParamErr.ErrMsg) return } }} Go Request的Form、PostForm、MultipartForm、FormValue()、FormPostValue()、FileValue()区别 - 掘金 (juejin.cn) 跨域请求 使用 Gin Cors 中间件解决 12345678910111213141516171819202122232425262728293031323334// Cors 跨域中间件func Cors() gin.HandlerFunc { return func(c *gin.Context) { method := c.Request.Method origin := c.Request.Header.Get(&quot;Origin&quot;) if origin != &quot;&quot; { //接收客户端发送的origin （重要！） c.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, origin) //服务器支持的所有跨域请求的方法 c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE,UPDATE&quot;) //允许跨域设置可以返回其他子段，可以自定义字段 c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, content-type, Content-Length, X-CSRF-Token, Token,session,Access-Control-Allow-Headers,account&quot;) // 允许浏览器（客户端）可以解析的头部 （重要） c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers&quot;) //设置缓存时间 c.Header(&quot;Access-Control-Max-Age&quot;, &quot;172800&quot;) //允许客户端传递校验信息比如 cookie (重要) c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) c.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) } //允许类型校验 if method == &quot;OPTIONS&quot; { c.JSON(http.StatusOK, &quot;ok!&quot;) } defer func() { if err := recover(); err != nil { fmt.Printf(&quot;Panic info is: %v\\n&quot;, err) } }() c.Next() }} 12r := gin.Default()r.Use(middlewares.Cors())","link":"/BackEnd/go/gin/"},{"title":"Go context","text":"语法 12345678910type Context interface { // 获取ctx截止时间 Deadline() (deadline time.Time, ok bool) // 返回一个只读的channel，用于通知当前的ctx是否已经被取消 Done() &lt;-chan struct{} // 获取ctx取消的原因 Err() error // 获取ctx中保存的键值对 Value(key any) any} 他们相等，都是创建一个 empty context，但是 background 是最顶层的上下文不会被取消，但是 todo 就有点待定的意思，可以被轻松替换 12context.Background()context.TODO() 数据传递 123456789101112131415161718192021222324252627type UserInfo struct { Name string}func step1(ctx context.Context) context.Context { child := context.WithValue(ctx, &quot;age&quot;, 18) return child}func step2(ctx context.Context) context.Context { child := context.WithValue(ctx, &quot;aaa&quot;, UserInfo{ Name: &quot;abc&quot;, }) return child}func step3(ctx context.Context) { fmt.Printf(&quot;name %s\\n&quot;, ctx.Value(&quot;aaa&quot;).(UserInfo).Name) fmt.Printf(&quot;age %d\\n&quot;, ctx.Value(&quot;age&quot;))}func main() { grandpa := context.Background() father := step1(grandpa) son := step2(father) step3(son)} 取消协程 12345678910111213141516171819202122232425262728293031323334353637383940func main() { t1 := time.Now() wg := sync.WaitGroup{} ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go func() { ip, err := GetIp(ctx, &amp;wg) fmt.Println(ip, err) wg.Done() }() // 取消协程 go func() { time.Sleep(2 * time.Second) // cancel()执行，Done()发送信号 cancel() }() wg.Wait() fmt.Println(&quot;执行完成&quot;, time.Since(t1))}func GetIp(ctx context.Context, wg *sync.WaitGroup) (ip string, err error) { go func() { select { case &lt;-ctx.Done(): fmt.Println(&quot;协程取消&quot;, ctx.Err()) err = ctx.Err() wg.Done() return } }() time.Sleep(4 * time.Second) ip = &quot;192.168.1.1&quot; wg.Done() return} 截止时间和超时时间 如果继承了 context timeout，那么会以最先结束的为准 123456789101112131415161718192021222324252627282930313233343536func main() { t1 := time.Now() wg := sync.WaitGroup{} // 获取cancel也可以手动取消 ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(time.Second*2)) // 超时时间 // context.WithTimeout(context.Background(), time.Second*2) wg.Add(1) go func() { ip, err := GetIp(ctx, &amp;wg) fmt.Println(ip, err) wg.Done() }() wg.Wait() fmt.Println(&quot;执行完成&quot;, time.Since(t1))}func GetIp(ctx context.Context, wg *sync.WaitGroup) (ip string, err error) { go func() { select { case &lt;-ctx.Done(): fmt.Println(&quot;协程取消&quot;, ctx.Err()) err = ctx.Err() wg.Done() return } }() time.Sleep(4 * time.Second) ip = &quot;192.168.1.1&quot; wg.Done() return} 超时时间","link":"/BackEnd/go/go%20context/"},{"title":"go grammar","text":"基础语法 变量定义 12345678910var identifier [type] = value// oridentifier := value// orvar ( vname1 v_type1 vname2 v_type2)var a int = 10 常量定义 1const identifier [type] = value 作为枚举使用 12345const ( Unknown = 0 Female = 1 Male = 2) iota iota，特殊常量，可以认为是一个可以被编译器修改的常量。 在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。 iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： 12345const ( a = iota b c) 用法 1234567891011121314func main() { const ( a = iota //0 b //1 c //2 d = &quot;ha&quot; //独立值，iota += 1 e //&quot;ha&quot; iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i)} 10 1 2 ha ha 100 100 7 8 条件语句 switch语句 switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break 12345678switch var1 { case val1: ... case val2: ... default: ...} Type Switch switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。 123456789switch x.(type){ case type: statement(s) case type: statement(s) /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s)} select语句 123456789select { case communication clause : statement(s) case communication clause : statement(s) /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s)} 每个case都必须是一个通信 所有channel表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行；其他被忽略。 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。 否则： 如果有default子句，则执行该语句。 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。 循环语句 12345678910111213141516171819202122func main() { var b int = 15 var a int numbers := [6]int{1, 2, 3, 5} /* for 循环 */ for a := 0; a &lt; 10; a++ { fmt.Printf(&quot;a 的值为: %d\\n&quot;, a) } // 代替while for a &lt; b { a++ fmt.Printf(&quot;a 的值为: %d\\n&quot;, a) } for i,x:= range numbers { fmt.Printf(&quot;第 %d 位 x 的值 = %d\\n&quot;, i,x) } } 函数 123func function_name( [parameter list] ) [return_types]{ 函数体} 闭包 Go 语言支持匿名函数，可作为闭包。匿名函数是一个&quot;内联&quot;语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。 12345678910111213141516171819202122func getSequence() func() int { i:=0 return func() int { i+=1 return i }}func main(){ /* nextNumber 为一个函数，函数 i 为 0 */ nextNumber := getSequence() /* 调用 nextNumber 函数，i 变量自增 1 并返回 */ fmt.Println(nextNumber()) fmt.Println(nextNumber()) fmt.Println(nextNumber()) /* 创建新的函数 nextNumber1，并查看结果 */ nextNumber1 := getSequence() fmt.Println(nextNumber1()) fmt.Println(nextNumber1())} 1234512312 函数方法 设置接收者函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。 123func (variable_name variable_data_type) function_name() [return_type]{ /* 函数体*/} 例如： 12345678910111213141516/* 定义函数 */type Circle struct { radius float64}func main() { var c1 Circle c1.radius = 10.00 fmt.Println(&quot;Area of Circle(c1) = &quot;, c1.getArea())}//该 method 属于 Circle 类型对象中的方法func (c Circle) getArea() float64 { //c.radius 即为 Circle 类型对象中的属性 return 3.14 * c.radius * c.radius} 1Area of Circle(c1) = 314 defer语句 Go语言中的defer语句会将其后面跟随的语句进行延迟处理 在defer所属的函数即将返回时，将延迟处理的语句按照defer定义的顺序入栈执行，即先进后出 1234567func main() { fmt.Println(&quot;开始&quot;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(&quot;结束&quot;)} 12345开始结束321 数组 123var variable_name [SIZE] variable_typevar balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 切片 “动态数组” 123456789var slice1 []type = make([]type, len)slice1 := make([]type, len)// 也可以指定容量，其中capacity为可选参数。make([]T, length, capacity)// 初始化，可缺省其中一个s := arr[startIndex:endIndex] len() 和 cap() 切片是可索引的，并且可以由 len() 方法获取长度。 切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。 append() 和 copy() 123456789101112131415161718192021222324252627func main() { var numbers []int printSlice(numbers) /* 允许追加空切片 */ numbers = append(numbers, 0) printSlice(numbers) /* 向切片添加一个元素 */ numbers = append(numbers, 1) printSlice(numbers) /* 同时添加多个元素 */ numbers = append(numbers, 2,3,4) printSlice(numbers) /* 创建切片 numbers1 是之前切片的两倍容量*/ numbers1 := make([]int, len(numbers), (cap(numbers))*2) /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) }func printSlice(x []int){ fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)} 12345len=0 cap=0 slice=[]len=1 cap=1 slice=[0]len=2 cap=2 slice=[0 1] len=5 cap=6 slice=[0 1 2 3 4] len=5 cap=12 slice=[0 1 2 3 4] 结构体 123456type struct_variable_type struct { member definition member definition ... member definition} Map 12345678/* 声明变量，默认 map 是 nil */var map_variable map[key_data_type]value_data_type/* 使用 make 函数 */map_variable = make(map[key_data_type]value_data_type)/* delete() */delete(map_variable, key) 12345678910111213141516171819func main() { var countryCapitalMap map[string]string /* 创建集合 */ countryCapitalMap = make(map[string]string) /* map 插入 key-value 对，各个国家对应的首都 */ countryCapitalMap[&quot;France&quot;] = &quot;Paris&quot; countryCapitalMap[&quot;Italy&quot;] = &quot;Rome&quot; countryCapitalMap[&quot;Japan&quot;] = &quot;Tokyo&quot; countryCapitalMap[&quot;India&quot;] = &quot;New Delhi&quot; /* 查看元素在集合中是否存在 */ capital, ok := countryCapitalMap[&quot;United States&quot;] /* 如果 ok 是 true, 则存在，否则不存在 */ if(ok){ fmt.Println(&quot;Capital of United States is&quot;, capital) }else { fmt.Println(&quot;Capital of United States is not present&quot;) } 1Capital of United States is not present 类型转换 go 不支持隐式转换类型 1type_name(expression) 接口 12345678910111213141516/* 定义接口 */type interface_name interface { method_name1 [return_type] method_name2 [return_type] ...}/* 定义结构体 */type struct_name struct { /* variables */}/* 实现接口方法 */func (struct_name_variable struct_name) method_name1() [return_type] { /* 方法实现 */} 12345678910111213141516171819202122232425262728type Phone interface { call()}type NokiaPhone struct {}func (nokiaPhone NokiaPhone) call() { fmt.Println(&quot;I am Nokia, I can call you!&quot;)}type IPhone struct {}func (iPhone IPhone) call() { fmt.Println(&quot;I am iPhone, I can call you!&quot;)}func main() { var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()} 12I am Nokia, I can call you!I am iPhone, I can call you! Reflect reflect.New() 指针类型的创建： 如果原始类型是指针类型，那么在创建值时需要使用 reflect.New() 函数创建一个指向该类型的指针。 这是因为指针类型的值是存储变量地址的，而不是变量本身的值。如果直接创建变量的值，那么它将是零值，而不是指向原始类型的指针。 非指针类型的创建： 如果原始类型不是指针类型，那么创建的值应该是该类型的零值。 这是因为非指针类型的值是直接存储变量的值的，而不是存储变量地址的。因此，可以直接使用 reflect.New() 函数创建该类型的变量，然后通过 Elem() 方法获取其值。 例如： 1234567891011121314151617type methodType struct { method reflect.Method ArgType reflect.Type ReplyType reflect.Type numCalls uint64}func (m *methodType) newArgv() reflect.Value { var argv reflect.Value //arg may be a pointer type, or a value type if m.ArgType.Kind() == reflect.Ptr { argv = reflect.New(m.ArgType.Elem()) } else { argv = reflect.New(m.ArgType).Elem() } return argv} Reflect.TypeOf() TypeOf返回接口中保存的值得类型，TypeOf(nil)会返回nil Reflect.ValueOf() ValueOf返回一个初始化为interface接口保管的具体值得Value，ValueOf(nil)返回Value零值 并发 goroutine goroutine的调度是随机的 1go func() 创建线程之后需要一段时间让线程执行： time.sleep()睡眠一会 sync.WaitGroup sync.WaitGroup 当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，WaitGroup是实现等待一组并发操作完成的好方法 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var wg sync.WaitGroupfunc hello() { fmt.Println(&quot;world!&quot;) defer wg.Done() //计数器减一}func main() { wg.Add(1) //计数器加一 go hello() fmt.Print(&quot;hello &quot;) wg.Wait() //阻塞代码的运行，直到计数器为0} 1hello world! Lock 锁 Mutex 互斥锁 Mutex 是最基本的一种锁，用于保护临界区，确保同一时刻只有一个 Goroutine 可以访问共享资源。 Mutex 的零值是未加锁的状态，通过 Lock () 方法进行加锁，通过 Unlock () 方法进行解锁。 如果一个 Goroutine 尝试对已经加锁的 Mutex 再次加锁，它会阻塞直到 Mutex 被解锁。 Mutex 是排他锁，意味着当一个 Goroutine 获得了锁之后，其他 Goroutine 就无法获得锁，直到锁被释放。 RWMute 读写锁 RWMutex 是对 Mutex 的扩展，它分为读锁和写锁两种状态，多个 Goroutine 可以同时获取读锁，但只有一个 Goroutine 可以获取写锁。 当存在读锁时，其他 Goroutine 可以继续获取读锁，但无法获取写锁；当存在写锁时，其他 Goroutine 无法获取读锁或写锁。 RWMutex 适用于读多写少的场景，可以提高并发访问的效率。 RLock() and Lock() Lock():通过获取锁，一次只能进行一次读/写。 RLock():多个 go routine 可以通过获取锁同时读取(不能写入)。 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)func main() { a := 0 lock := sync.RWMutex{} for i := 1; i &lt; 10; i++ { go func(i int) { lock.Lock() fmt.Printf(&quot;Lock: from go routine %d: a = %d\\n&quot;,i, a) time.Sleep(time.Second) lock.Unlock() }(i) } b := 0 for i := 11; i &lt; 20; i++ { go func(i int) { lock.RLock() fmt.Printf(&quot;RLock: from go routine %d: b = %d\\n&quot;,i, b) time.Sleep(time.Second) lock.RUnlock() }(i) } &lt;-time.After(time.Second*10)} 当一个 go-routine 已经获取了一个 RLock() 时，另一个 go-routine 是否可以获取一个 Lock() 进行写入，或者它必须等到 RUnlock() 发生？ 要获取用于写入的 Lock()，它必须等到 RUnlock() 当有人已经为 map 获取了 Lock() 时会发生什么，其他 go-routine 是否仍然可以获取 RLock() 如果某人 X 已经获取了 Lock()，那么其他获取 RLock() 的 go-routine 将必须等到 X 释放锁(Unlock()) 假设我们在这里处理Maps，是否有可能出现“并发读/写Map”错误？ Map 不是线程安全的。所以“ map 的并发读/写”会导致错误。 go - what is the difference between RLock() and Lock() in Golang? - Stack Overflow channel goroutine 之间交换数据的解决办法： 为了保证线程间数据交换的正确性，很多并发模型使用互斥锁，但这样会造成性能问题。 Go采用的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存，而不是通过共享内存而实现通信 Go 语言中的channel是一种特殊的类型。channel像一个队列，总是遵循先入先出的规则，保证收发数据的顺序。每一个channel都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。 操作 channel 的零值为nil 发送和接收操作均用​&lt;-​符号 它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。 12345678910111213141516// 使用make()初始化make(chan 元素类型,[缓冲大小])// 声明一个通道并初始化a := make(chan int)// 把10发送给a通道a &lt;- 10// x从a通道中取值value, ok := &lt;-ch//从a通道中取值，忽略结果&lt;-a// 关闭通道close(a) 关闭 当一个通道被关闭后，再往该通道发送值会引发panic。 对已关闭的通道进行取值的操作会先取完通道中的值。 通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。 123456// 使用 for range 取完通道所有的值func receive(ch chan int) { for i:=range ch{ fmt.Printf(&quot;v:%v&quot;,i) }} 无缓冲channel(阻塞的channel) 无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段。 同理，如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。 123456// 报错，deadlockfunc main() { a := make(chan int) a &lt;- 10 fmt.Println(&quot;发送成功&quot;)} 123456789101112// 成功func receive(x chan int) { ret := &lt;-x fmt.Println(&quot;接收成功&quot;, ret)}func main() { a := make(chan int) go receive(a) a &lt;- 10 fmt.Println(&quot;发送成功&quot;)} 有缓冲区channel 通道的容量大于零，该通道就是有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。 通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。 可以使用 len() 获取通道的长度，使用 cap() 获取通道的容量 123456// 成功func main() { a := make(chan int,1) a &lt;- 10 fmt.Println(&quot;发送成功&quot;)} 单向通道 12&lt;-chan int // 只接收通道，只能接收不能发送chan&lt;- int // 只发送通道，只能发送不能接收 发送通道（send-only channel）： 发送通道只能用于向通道中发送数据，而不能从通道中接收数据。 通过使用语法chan&lt;- 数据类型来声明发送通道，其中chan&lt;-表示该通道只能用于发送数据，不能用于接收数据。 例如：ch := make(chan&lt;- int)表示创建一个只能用于发送整数类型数据的发送通道。 接收通道（receive-only channel）： 接收通道只能用于从通道中接收数据，而不能向通道中发送数据。 通过使用语法&lt;-chan 数据类型来声明接收通道，其中&lt;-chan表示该通道只能用于接收数据，不能用于发送数据。 例如：ch := make(&lt;-chan int)表示创建一个只能用于接收整数类型数据的接收通道。 select 多路复用 1234567891011// 每次进入循环只会执行其中满足条件的，下列结果为 1 3 5 7 9func main() { ch := make(chan int, 1) for i := 1; i &lt;= 10; i++ { select { case x := &lt;-ch: fmt.Println(x) case ch &lt;- i: } }} 互斥锁 一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go语言中使用sync包中提供的Mutex类型来实现互斥锁 互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁； 当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区 多个 goroutine 同时等待一个锁时，唤醒的策略是随机的 12345678910111213141516171819202122var ( x int64 wg sync.WaitGroup m sync.Mutex // 互斥锁)func add() { for i := 0; i &lt; 5000; i++ { m.Lock() // 修改x前加锁 x = x + 1 m.Unlock() // 改完解锁 } wg.Done()}func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) //10000} 读写锁 当并发的去读取一个资源而不涉及资源修改的时没有必要使用互斥锁，读写锁是一种更好的选择。 在Go语言中使用sync包中的RWMutex类型来实现读写互斥锁 读写锁分为两种：读锁和写锁。 当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待； 而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待 123456789101112131415161718192021222324252627282930313233343536var ( x = 0 wg sync.WaitGroup RWLock sync.RWMutex)func read() { defer wg.Done() RWLock.RLock() fmt.Println(x) time.Sleep(time.Millisecond) RWLock.RUnlock()}func write() { defer wg.Done() RWLock.Lock() x += 1 time.Sleep(time.Millisecond * 5) RWLock.Unlock()}func main() { start := time.Now() for i := 0; i &lt; 10; i++ { go write() wg.Add(1) } time.Sleep(time.Second) for i := 0; i &lt; 1000; i++ { go read() wg.Add(1) } wg.Wait() fmt.Println(time.Since(start))} context context 包提供了在不同 Goroutine 之间传递请求特定值、取消信号以及请求范围的截止时间等功能。主要用于控制 Goroutine 的生命周期和上下文，避免因为不同 Goroutine 之间的竞争而导致的问题，比如取消请求、超时处理、请求跟踪等。 WithCancel(parent Context)：创建一个新的上下文，返回的上下文的 Done 通道会在父上下文的 Done 通道关闭或调用 Cancel 方法时关闭 WithDeadline(parent Context, deadline time.Time)：创建一个新的上下文，返回的上下文的Done通道会在指定截止时间到达、父上下文的Done通道关闭或调用Cancel方法时关闭，以最先发生的情况为准 WithTimeout(parent Context, timeout time.Duration)：类似WithDeadline，不过是相对于当前时间计算截止时间 WithValue(parent Context, key, val interface{})：创建一个新的上下文，包含了一个键值对。这个函数一般用来传递请求特定的值 包含了以下几个方法： Deadline() (deadline time.Time, ok bool)：返回上下文的截止时间，如果不存在截止时间，则 ok 为 false Done() &lt;-chan struct{}：返回一个通道，当上下文被取消或超时时，该通道会被关闭 Err() error：返回上下文的错误信息，如果上下文被取消或超时，则返回相应的错误信息 Value(key interface{}) interface{}：返回上下文中指定键的值","link":"/BackEnd/go/go-grammar/"},{"title":"go memo","text":"安装 官网 12345678910# 解压sudo tar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz# 编辑 .bashrc 加入环境变量export GOROOT=/usr/local/go ##Golang安装目录export PATH=$GOPATH/bin:$PATHexport GOPATH=$HOME/go ##Golang项目目录# bash执行source .bashrc 换源 七牛：Goproxy 中国 https://goproxy.cn 阿里： mirrors.aliyun.com/goproxy/ 官方： &lt; 全球 CDN 加速 https://goproxy.io/&gt; 其他：jfrog 维护 https://gocenter.io 12345678910111213# 启用 Go Modules 功能go env -w GO111MODULE=on# 配置 GOPROXY 环境变量，以下三选一# 1. 七牛 CDNgo env -w GOPROXY=https://goproxy.cn,direct# 2. 阿里云go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct# 3. 官方go env -w GOPROXY=https://goproxy.io,direct 清除模块缓存 GO111MODULE=on 以后，下载的模块内容会缓存在 $GOPATH/pkg/mod 目录中 12# 清除缓存命令go clean --modcache 命令行 go test -race 运行 Go race detector。 -run 来过滤要由 regex 和 -run 标志运行的测试: go test -run=FunctionName -bench 去运行基准测试。 - -cpuprofile cpu.out 退出前将 CPU 配置文件写入指定的文件。 -memprofile mem.out 在所有测试通过后，将内存配置文件写入文件。 我总是用 -v. 它打印测试名称、状态 (失败或通过)、运行测试需要多少时间、测试用例中的任何日志等等。 -cover 度量在运行一组测试时执行的代码行的百分比。 go list 它列出了由导入路径命名的包，每行一个。 go fmt 他是在保存文件时运行的。它会根据 Go 的标准重新格式化你的代码。 还有基于 gofmt 的 goimports，它会更新你的 Go 导入行，添加缺失的行，删除未引用的行。 go generate 「在编译前自动运行生成源代码的工具」 Go 工具会扫描与当前包相关的文件，寻找带有表单 //go:generate command arguments「魔力注释」的行。此命令不需要执行任何与 Go 或代码生成相关的操作。例如： 1234567package project//go:generate echo Hello, Go Generate!func Add(x, y int) int { return x + y} 12$ go generateHello, Go Generate!","link":"/BackEnd/go/go-memo/"},{"title":"SQL 索引","text":"复合唯一索引 dbdiagram.io 例子： 123456789101112Table accounts as A { id bigserial [pk] // [pk] is primary key owner varchar [ref: &gt; U.username, not null] balance bigint [not null] currency varchar [not null] created_at timestamptz [not null, default: `now()`] indexes { owner (owner, currency) [unique] }} (owner, currency) [unique] 意思是一个 owner 可以有多个，currency 可以有多个，但是 owner+currency 存在同一表只能是唯一的 以下两种方式都可以实现效果 12-- ALTER TABLE &quot;accounts&quot; ADD FOREIGN KEY (&quot;owner&quot;) REFERENCES &quot;users&quot; (&quot;username&quot;);ALTER TABLE &quot;accounts&quot; ADD CONSTRAINT &quot;owner_currency_key&quot; UNIQUE (&quot;owner&quot;, &quot;currency&quot;);","link":"/BackEnd/sql/index/"},{"title":"SQL 隔离等级","text":"sql acid：原子性、一致性、隔离性、持久性 error A: 开启事务 B: 开启事务 A、B 修改和查询同一张表 mysql 默认：Repeatable read 隔离等级可以设置 global 或者当前整个 session postgres 默认：Read committed 可以设置 Read uncommitted 但是视为 Read committed，可以认为在 postgres 只存在三个隔离等级 只能为当前单个事务设置隔离等级 dirty read 脏读 A: 修改表尚未提交 B: 查询 A 表修改项，获取到已修改数据 解决方法：禁止读取未提交 Non-repeatable read 不可重复读 B: 查询 C 数据为 10 未提交 A: 修改 C 数据为 20 提交 B: 查询 C 数据为 20 主要针对改操作 解决方法：事务在读时，禁止任何事物写 Phantom Read 幻读 B: 查询表有三条数据，未提交 A: 往表插入数据至五条，提交 B: 查询表有五条数据 主要针对增删操作 解决方法：如果一个事物加上表级锁，只要有任何东西操作这个表，禁止任何操作并发 Read uncommitted 可读取未提交 写事务阻止其他写事务，避免更新遗失，但没有阻止读事务 Read committed 可读已提交 写事务阻止其他读写事务 读事务不会阻止其他任何事务 Repeatable read 可重复读 读事务阻止其他写事务，但不阻止其他读事务 different AB 一起开启事务 AB 一起查询：A: balance = 100 B: balance = 100 A: 修改表数据 balance = balance - 10，最终提交后 balance = 90 mysql：B: 修改表数据 balance = balance - 10，最终提交后 balance = 80，修改前后不一致 postgres：B: 修改表数据 balance = balance - 10，报错 序列化错误： AB 一起开启事务，表中只有一条数据 AB 都 insert 一条数据并 commit postgres：最终查询出现三条数据 Serializable 序列化 读取事务可并发 读写、写写必须互斥 different mysql： select 时默认设置为 SELECT FOR SHARE 有事务执行查询后，阻塞其他事务并发修改，直到事务提交后放行其他事务 其他事务被阻塞有超时报错机制 使用锁定机制实现效果 序列化错误： postgres： AB 一起开启事务，都执行查询和插入 A 成功提交，B 提交时报错 检查依赖条件检测错误并抛出实现效果 mysql A 开启事务进行插入查询 B 开启事务进行查询将会被阻塞 A 提交之后会释放锁，B 才会得到查询内容 当 A 事务执行查询，阻塞 B 事务更新，A 再执行查询会发生死锁","link":"/BackEnd/sql/isolation/"},{"title":"Linux 备忘基操","text":"用户 创建 1234567891011121314151617# 创建用户useradd 用户名# 设置密码passwd userName# 查看所有用户 cat /etc/passwd# 查看指定用户 cat /etc/passwd|grep userName# 删除用户 userdel userName# 彻底删除用户：userdel -rf userName 权限 12345678# 赋权chown -R 用户名:用户组 目录# 对目录赋权chmod -R 775 目录# 查看目录权限ls -la 目录 权限计算 1234567891011权限 数字 计算--- 0 0 + 0 + 0r-- 4 4 + 0 + 0-w- 2 0 + 2 + 0--x 1 0 + 0 + 1rw- 6 4 + 2 + 0-wx 3 0 + 2 + 1r-x 5 4 + 0 + 1rwx 7 4 + 2 + 1 r：读 w：写 x：执行 组 1234567891011121314151617181920212223242526# 添加组 groupadd groupName# 查看当前登录用户 whoami# 查看当前用户所在组 groups# 查看指定用户所在组 groups userName# 将用户添加到组 usermod -a -G groupName userName# 从组中删除用户 gpasswd groupName -d userName# 查看所有组 cat /etc/group# 查看指定组 cat /etc/group|grep groupName# 删除组groupdel groupName Linux 查看当前版本 1cat /etc/issue Debian 11 换源 12345678910cat &gt;&gt; /etc/apt/sources.list &lt;&lt; EOFdeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-freeEOF 版本不对头使用 aptitude install 端口 查看端口是否可达 1nc -zv localhost 8080 释放占用端口 12345# 假设要释放端口 1997netstat -tln | grep 1997 # 查找端口号网络连接情况lsof -i:1997 # 找到端口号对应的进程# 假设 1997 端口对应进程PID为 29999kill -9 29999 查看开机日志 dmesg 解决依赖缺失 apt-cache","link":"/Memo/linux/Linux/"},{"title":"wsl 备忘基操","text":"安装 WSL 123456789# 此方法安装默认使用wsl2 之后无需额外设置wsl --install -d Debian# 检查版本cat /etc/issue# 重装wsl --unregister Debianwsl --install -d Debian 修改 root 密码 powershell中输入 设置进入root用户 Debian config --default-user root 进入wsl系统 输入此命令按提示修改密码 passwd powershell 根据个人需求选择是否设置回普通用户 Debian config --default-user tomato 记得换源 迁移wsl位置到其他盘 12345678#导出系统wsl --export Debian E:\\Debian2.tar#取消挂载（删除debian系统）wsl --unregister Debian#重新挂载到E盘wsl2目录下wsl --import Debian E:\\wsl2\\Debian E:\\Debian2.tar WSL操作 高级系统配置官方文档 hosts问题 wsl会自动获取物理机hosts文件内容，如果要改善git速度问题，建议在物理机安装SwitchHosts 配置参考下面： Title: 随意 Type: Remote URL: https://raw.hellogithub.com/hosts Auto Refresh: 最好选 1 hour 在物理机资源管理器访问wsl文件 在wsl命令行输入 explorer.exe . 访问当前目录 资源管理器输入 \\\\wsl$\\{distro name}\\ 配置WSL性能 在文件 %USERPROFILE%\\.wslconfig 中配置 1234[wsl2]memory=8GB # 运存processors=3 # 处理器debugConsole=true # 启动时开启debug窗口 加速启动 配置wsl不自动挂载全部硬盘 在虚拟机/etc/wsl.conf中新增 123[automount]enabled=false # 关闭自动挂载mountFsTab = true # 如果需要单独挂载则开启FsTab配置挂载 配置/etc/fstab实现自动单独挂载 示例： C: /mnt/c drvfs rw,noatime,uid=1000,gid=1000,fmask=0027,dmask=0027,metadata 0 0 Wsl ping 不通主机问题 添加防火墙规则 1New-NetFirewallRule -DisplayName &quot;WSL&quot; -Direction Inbound -InterfaceAlias &quot;vEthernet (WSL)&quot; -Action Allow","link":"/Memo/linux/wsl/"},{"title":"imaegoo log","text":"去除评论 在themes/icarus/layout/common/scripts.jsx中注释第三十五行 设置归档格式 修改 _config.icarus.yml 1234# Where should the widget be placed, left sidebar or right sidebarposition: lefttype: archivesformat: YYYY年MM月DD日 修改头像下的关注按钮文字 修改 themes/icarus/languages/zh-CN.yml 12widget: follow: 'Github' 删除访客数量 themes/icarus/layout/common/article.jsx注释81-83行 添加主页自动折叠 /home/tomato/blog/themes/icarus/layout/common/article.jsx 108行 1234567{/* 改为主页文章全折叠 */}&lt;div class=&quot;content&quot; dangerouslySetInnerHTML={{ __html: index ? page.content.split('\\n').slice(0,config.auto_excerpt.lines).join('\\n') : page.content}}&gt;&lt;/div&gt;{/* 改为文章行数大于auto_excerpt.lines就加上按钮 */}{ page.content.split('\\n').length &gt; config.auto_excerpt.lines ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;{__('article.more')}&lt;/a&gt; : null} 123456# Excerpt ## Auto creat excerpt with not &lt;!--more--&gt;## Enable will truncate auto_excerpt.lines rows in post head to replace excerpt.auto_excerpt: enable: true lines: 5 自定义表格居中 在 themes/icarus/include/style/article.styl 中增加以下样式 123#align_table td text-align:center 自定义表格只需要 &lt;table id=&quot;align_table&quot;&gt; 就可以实现居中 修改主页卡片样式 themes/icarus/include/style/card.styl 添加样式 123.card article padding: 1.5rem 1.5rem 0.4rem 1.5rem","link":"/Memo/log/imaegoo-log/"},{"title":"MongoDB备忘","text":"安装 ubuntu 20.04 12345wget https://repo.mongodb.org/apt/ubuntu/dists/focal/mongodb-org/7.0/multiverse/binary-amd64/mongodb-org-server_7.0.2_amd64.debsudo dpkg -i mongodb-org-server_7.0.2_amd64.debsudo systemctl start mongod ## 开启服务sudo systemctl enable mongod ## 开机自启sudo systemctl status mongod ## 查看状态 配置 /etc/mongod.conf 123456789101112131415# mongod.confstorage: dbPath: /var/lib/mongodb# where to write logging data.systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log # bindIp默认是127.0.0.1，要设置为0.0.0.0才能被公网访问到net: port: 27017 bindIp: 0.0.0.0 开启认证 先连接数据库创建管理员用户 1mongo 123456use admindb.createUser({ user: &quot;adminUser&quot;, // 您的管理员用户名 pwd: &quot;adminPassword&quot;, // 您的管理员密码 roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]}) 编辑配置文件 /etc/mongod.conf 12security: authorization: enabled 重启服务 123sudo systemctl restart mongodorsudo service mongod restart 注销并使用管理员身份登录 1db.auth(&quot;adminUser&quot;, &quot;adminPassword&quot;) 创建其他用户 123456use yourDatabasedb.createUser({ user: &quot;appUser&quot;, pwd: &quot;appPassword&quot;, roles: [ { role: &quot;readWrite&quot;, db: &quot;yourDatabase&quot; } ]}) 连接数据库 1mongosh &quot;&lt;connectionString&gt;&quot; connectionString：mongodb://&lt;username&gt;:&lt;password&gt;@&lt;hostname&gt;:&lt;port&gt;/&lt;database&gt; 认证错误 panic: connection() error occurred during connection handshake: auth error: sasl conversation error: unable to authenticate using mechanism &quot;SCRAM-SHA-1&quot;: (AuthenticationFailed) Authentication failed. 在 connectString 后面加上: ?authSource=admin&amp;authMechanism=SCRAM-SHA-1&quot; 即可解决","link":"/Memo/tools/MongoDB-memo/"},{"title":"SSH","text":"创建 key 1ssh-keygen -t ed25519 -b 4096 Client .ssh/config 123456Host tomato HostName 192.168.6.153 User tomato Port 42343 IdentityFile C:\\Users\\10900\\.ssh\\id_ed25519 PreferredAuthentications publickey 以上的 IdentityFile 可以通过新生成的也可以通过使用已有的私钥文件 1ssh tomato Server .ssh/authorized_keys 中填入上面生成的 .pub 文件中的内容 1sudo vim /etc/ssh/sshd_config 写入 1PubkeyAuthentication yes 关闭密码连接 1sudo vim /etc/ssh/sshd_config 写入 1PasswordAuthentication no 常见问题 执行以下命令可以查看日志 1systemctl status ssh Authentication refused: bad ownership or modes for directory /home/tomato 123456chmod 700 /home/tomatochmod 700 ~/.sshchmod 400 ~/.ssh/id_ed25519 chmod 600 ~/.ssh/authorized_keyschown -R tomato:tomato /home/tomato","link":"/Memo/tools/SSH/"},{"title":"docker备忘","text":"Ubuntu 安装 前置操作 12345678# 创建用户组sudo groupadd docker# 添加用户sudo usermod -aG docker $USER# 激活newgrp docker 安装指令 12345678910111213141516# Add Docker's official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curlsudo install -m 0755 -d /etc/apt/keyringssudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.ascsudo chmod a+r /etc/apt/keyrings/docker.asc# Add the repository to Apt sources:echo \\ &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update# To install the latest versionsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 开启 IPV6 设置 daemon.json 开启 experimental 和 ip6tables ip6tables是指由 Docker 自动配置 IPv6 的防火墙规则 创建网络 首先获取本机 v6 地址 然后去 IPv6 Subnet Calculator 划分子网 123456789# docker-composenetworks: ip6net: enable_ipv6: true ipam: config: - subnet: 172.18.0.0/16 - subnet: 240e:3b4:d0e0:6a90:4000::/66 gateway: 240e:3b4:d0e0:6a90:4000::1 最后容器加上 network 即可 Dockerfile 1234567FROM node:18WORKDIR /dirCOPY package.json .RUN npm installCOPY . .EXPOSE 3000CMD [&quot;npx&quot;, &quot;hexo&quot;, &quot;server&quot;] EXPOSE 是说明对外暴露的端口 RUN 是在构建时执行的命令 CMD 是构建完毕启动之后执行的命令 使用的相对地址 缓存 docker 构建镜像时会使用缓存，从上到下执行，分两次 copy 可以让构建时的工作减少 .dockerignore copy 命令忽略的文件，.dockerignore 也要写进去 指令 docker + build . 在当前目录根据 Dockerfile 文件构建 images 查看所有镜像 image prune 删除残存的，额米有使用的临时镜像文件 -a 删除所有没有用的镜像，而不仅仅是临时文件 -f 强制执行，无需弹出确定提示 tag 用户名/镜像名: 版本 给镜像命名 rmi 镜像名 删除镜像 -f 强制删除 pull 镜像名 将镜像存在本地 run 运行镜像 -d 后台运行 -p 主机端口:容器端口 对外暴露端口 --name 自定义名 自定义容器名 -v 本地路径:容器文件夹路径:ro 动态绑定，动态更新文件 :ro 代表让本地文件夹变为 readonly，使得容器文件改变，本地不改变 这里要使用绝对路径，也可也使用环境变量 可以使用 nodemon 实现重启 npm i nodemon --save-dev 并修改 package.json 中 script 处，添加 &quot;dev&quot; : &quot;nodemon app.js&quot; 此时执行改为 CMD [&quot;npm&quot;, &quot;run&quot;, &quot;dev&quot;] -v 容器文件路径 表示该路径不同步 ps 查看所有容器 stop 容器 id 暂停运行 -a 暂停所有 rm -f 容器名 删除容器 -fv 同时删除 volume exec -it 容器名 /bin/sh 访问容器 -i 交互 -t 终端模式 /bin/sh 表示执行一个新的 bash shell docker-compose.yml 1234567891011121314151617181920212223242526272829303132333435363738version: &quot;3.8&quot;services: blog: # 容器名 build: . # 根据当前文件夹进行构建 ports: - &quot;3000:3000&quot; # 暴露端口，本地路径:容器文件夹路径 volumes: - ./:/blog:ro # 动态绑定，可以使用相对地址 - /blog/node_modules # 不绑定 - E:\\番剧:/Downloads # windows 可以写本地地址 - run:/var/run # 使用volumes network: - ip6net hostname: blog environment: # 环境变量 - QB_WEBUI_PORT=8080 - QB_TRACKERS_LIST_URL=https://cf.trackerslist.com/best.txt depends_on: # 启动顺序 qbittorrentEE: # 其他容器名 condition: service_healthy # 设置状态 healthcheck: # 自定义healthcheck test: echo 'stat' | nc localhost 3000 || exit 1 interval: 5s timeout: 5s retries: 6 command: -dsn &quot;postgres://metatube:metatube@/metatube?host=/var/run/postgresql&quot; -port 6778 -db-auto-migrate -db-prepared-stmt # 启动参数networks: ip6net: enable_ipv6: true ipam: config: - subnet: 172.18.0.0/16 - subnet: 2607:f0d0:1002:51:4000::/66 gateway: 2607:f0d0:1002:51:4000::1volumes: run: docker-compose up -d --build 执行 -d 后台运行 --build 如果镜像修改则重建 docker-compose down -v 清除 -v 删除 volume depends_on condition： serveice_started： 容器启动完成 service_healthy：容器处于healthy状态，healthy状态的检查依赖healthcheck service_completed_successfully：在启动依赖服务之前，需要确保依赖服务已经成功完成运行 123depends_on: # 启动顺序 qbittorrentEE: # 其他容器名 condition: service_healthy # 设置状态 healthcheck 有些服务未设置 healthcheck，需要自己手动添加 执行echo 'stat' | nc localhost 2181 || exit 1命令，命令返回 0 表示容器healthy，返回 1 表示unhealthy，healthy还能配置其他参数，如时间间隔、超时等，完整的配置如下 12345healthcheck: # 自定义healthcheck test: echo 'stat' | nc localhost 3000 || exit 1 interval: 5s timeout: 5s retries: 6 Docker Compose配置文件详解（V3） - 哈喽哈喽111111 - 博客园 (cnblogs.com)","link":"/Memo/tools/docker-memo/"},{"title":"git","text":"Linux配置 将 SSH 密钥添加到 ssh-agent 启动 SSH 代理 要允许 git 使用您的 SSH 密钥，需要在您的设备上运行 SSH 代理。 要检查它是否已运行，请运行 ps 命令。如果 ssh 代理已在运行，它应该出现在输出中，例如： 12$ ps -auxc | grep ssh-agenttomato 1317 0.0 0.0 7972 3316 ? Ss 15:03 0:00 ssh-agent 要启动代理，请运行： 1eval $(ssh-agent) 最后需要将此命令添加到 ~/.bashrc、~/.zshrc、~/.profile 或等效的 shell 配置文件中。将此命令添加到 shell 配置文件将确保打开终端时代理正在运行。 创建 SSH 密钥对 使用 ssh-keygen 生成 SSH 密钥对，例如： 12cd ~/.sshssh-keygen -t ed25519 -b 4096 -C &quot;{username@emaildomain.com}&quot; -f {ssh-key-name} 完成后，ssh-keygen 将输出两个文件： {ssh-key-name} — 私钥。 {ssh-key-name}.pub — 公钥。 bitbucket {username@emaildomain.com} 是与 Bitbucket Cloud 帐户关联的电子邮件地址，例如您的工作电子邮件帐户。 {ssh-key-name} 是键的输出文件名。我们建议使用可识别的名称，例如bitbucket_work。 github 默认情况下，GitHub 支持的公钥的文件名是以下之一： id_rsa.pub id_ecdsa.pub id_ed25519.pub 添加ssh密钥对给ssh-agent代理 12ssh-add /path/to/your/ssh-key1ssh-add /path/to/your/ssh-key2 每次重启都会导致ssh-agent的配置消失，所以需要将ssh-add命令添加到 ~/.bashrc、~/.zshrc、~/.profile 或等效的 shell 配置文件中，保证每次启动都自动代理ssh密钥对。 同时也建议配置 ssh-agent -k 到 ~/.bash_logout 文件中，用于离开时关闭代理。 github用户名邮箱设置 12345# --global 全局git config --global user.name &quot;username&quot; git config --global user.email &quot;email&quot;git config --replace-all user.name &quot;name&quot;git config --replace-all user.email &quot;email&quot; Windows 配置 安装 ssh 服务 打开“设置”，选择“应用”&gt;“应用和功能”，然后选择“可选功能” 。 安装 OpenSSH 客户端以及 OpenSSH 服务器 启动并配置 OpenSSH 服务器 管理员运行 PS 1234567891011121314# Start the sshd serviceStart-Service sshd# OPTIONAL but recommended:Set-Service -Name sshd -StartupType 'Automatic'Set-Service -Name ssh-agent -StartupType automatic# Confirm the Firewall rule is configured. It should be created automatically by setup. Run the following to verifyif (!(Get-NetFirewallRule -Name &quot;OpenSSH-Server-In-TCP&quot; -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) { Write-Output &quot;Firewall Rule 'OpenSSH-Server-In-TCP' does not exist, creating it...&quot; New-NetFirewallRule -Name 'OpenSSH-Server-In-TCP' -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22} else { Write-Output &quot;Firewall rule 'OpenSSH-Server-In-TCP' has been created and exists.&quot;} 配置开机自动 ssh-add 打开 git 根目录里的 etc 文件夹 编辑 bashrc 文件，添加一行 ssh-add 每次开机会自动执行这一行命令 测试 这一步添加 know_host 1ssh -T git@github.com 常用指令 git 代理 12git config --global http.proxy &quot; http://127.0.0.1:10811&quot; git config --global https.proxy &quot;http://127.0.0.1:10811&quot; 初始化 Git 初始化本地已有项目并推送到 Git 仓库 初始化 git init 创建仓库 设置远程仓库链接 git remote add origin 仓库链接 拉取分支 git pull origin main:brantest 将远程主机 origin 的 master 分支拉取过来并与本地的 brantest 分支合并 git pull origin main 省略冒号则是与当前分支合并 提交代码到远程分支 git push -u 远程仓库名 本地分支名 Push 项目 git add -A git commit -m '初始化git项目' git push --set-upstream 远程仓库名 本地分支名 切换远程仓库 git remote -v 查看远程仓库的地址 修改远程仓库地址 git remote set-url origin URL 更换远程仓库地址，URL为新地址。 先删除远程仓库地址，然后再添加 git remote rm origin 删除现有远程仓库 git remote add origin url 添加新远程仓库 clone 下来的项目脱离 git 管理 删除.git文件夹git rm --cached 解决“子项目错误”问题，会导致外层git也脱离 子项目 sort form 掘金 常用命令 1234567891011121314151617181920# 结果的 hash 前带 - 号说明该 module 未初始化# 结果的 hash 前带 + 号说明该 module 版本未同步git submodule status# 初始化 modules，重复初始化无影响，例子中后跟 名称 为指定初始化某个 module 的名称（下同）git submodule init [submodule 名称]# 添加 submodule，例子中后跟 目录 为该 module 名称与目录名git submodule add [submodule 地址] [目录]# 版本未同步时，检出 modules，保证检出的版本与主项目匹配，但子 module 会创建临时分支git submodule update [submodule 名称]# 如果 status 已存在子项目且最前面带个负号git submodule update --init [submodule 名称]# 遍历所有 submodule 执行指定命令# git submodule foreach 其他命令，如：git submodule foreach git pullgit submodule foreach ls -l 12345# pull 项目，并移除废弃 submodule# 建议重新 clone 项目# pull 项目，并重命名 submodule# 建议重新 clone 项目 删除子项目 废弃本地仓库的做法（推荐） 修改【.gitmodules】文件内容：去除被删除的 submodule 内容 提交修改并推送到远程仓库 重新 clone 仓库 不废弃本地仓库的做法（不推荐） 假设 submodule 名称为 subA 非必须步骤不做也行，但日后重复添加相同名称的 submodule 时，可能存在问题 如果想反悔（不删了）的话，git reset --hard HEAD 即可，再次强调所有修改都已提交再操作 1234567891. 缓存清理：`git rm -r --cached subA` - 执行前请保证所有修改都已提交 - 验证上述步骤是否成功：`git submodule` 的结果没有 subA - 这个必须第一个执行，后续的操作则无所谓顺序了2. 删除对应目录：`rm -rf subA/`3. 修改【.gitmodules】文件内容：去除被删除的 submodule 内容 - 修改后，就可以提交修改并推送远程仓库了4. 非必须，修改【.git/config】文件内容：去除被删除的 submodule 内容5. 非必须，删除【.git/modules】目录下对应 submodule 目录","link":"/Memo/tools/git-memo/"},{"title":"hexo-icarus","text":"数学公式插件 MathJax 语法 当使用TEX语法时，请使用$或\\(与\\)包裹行内公式，$$或\\[与\\]标签对包裹块状公式。 例如： 1这是一个行内公式：$ax^2+bx+c&gt;0$ 效果如下： 这是一个行内公式：$ax^2+bx+c&gt;0$","link":"/Memo/tools/hexo-icarus/"},{"title":"markdown","text":"基础语法 标题 以#号的数量代表标题级别，越少级别越高。 1234// 一定在井号后面留空格# 一级标题## 二级标题### 三级标题 段落 空白一行或多行进行分隔。 123第一行第二行 不要用空格（spaces）或制表符（ tabs）缩进段落。 换行 在一行的末尾添加两个或多个空格，然后按回车键，即可创建一个换行。 粗体和斜体 都是使用星号(*)包裹，下划线(_)也可 123456*斜体*_斜体_**粗体**__粗体__***又粗又斜***___又粗又斜___ 引用 12&gt; 代表引用&gt;&gt; 可嵌套 效果如下： 代表引用 可嵌套 列表 引用和列表可以相互嵌套 要打出|请用&amp;#124; 有序列表 123451. 2. 1. 2. 3. 无序列表 123- 1- 2- 3 效果如下： 1 2 3 代码 要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。 1At the command prompt, type `nano`. 效果如下： At the command prompt, type nano. 如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(``)中。 1``Use `code` in your Markdown file.`` 效果如下： Use `code` in your Markdown file. 一些样本 1234Shell: console, shell Bash: bash, sh, zsh Powershell: powershell, ps Dos: dos, bat, cmd 分割线 要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。 以上三个分隔线的渲染效果看起来都一样，效果： 记得在分割线上下添加空白行 12345Try to put a blank line before...---...and after a horizontal rule. 链接 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;) 1这是一个链接 [Markdown语法](https://markdown.com.cn)。 效果如下： 这是一个链接 Markdown语法。 图片 要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 插入图片Markdown语法代码：![图片alt](图片链接 &quot;图片title&quot;)。 给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。 例如： [![沙漠中的岩石图片](/assets/img/shiprock.jpg &quot;Shiprock&quot;)](https://markdown.com.cn) 表格 要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。 1234| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text | 效果如下： Syntax Description Header Title Paragraph Text html colspan: 合并单元格 style=&quot;text-align:center&quot;: 居中 x -x(u 4) 十六进制 十进制 十进制 十六进制 0 0 0 0 5 5 11 B 8 8 8 8 对齐 您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。 1234| Syntax | Description | Test Text || :--- | :----: | ---: || Header | Title | Here's this || Paragraph | Text | And more | 效果如下： Syntax Description Test Text Header Title Here’s this Paragraph Text And more 删除线 您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号~~。 1~~世界是平坦的。~~ 我们现在知道世界是圆的。 效果如下： 世界是平坦的。 我们现在知道世界是圆的。 任务列表 任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。 123- [x] Write the press release- [ ] Update the website- [ ] Contact the media 效果如下： [x] Write the press release [ ] Update the website [ ] Contact the media Markdown Support for Visual Studio Code Table of contents tab shift + ctrl + p and type “Create Table of Contents” to insert a new table of contents. Easily add/update/remove section numbering tab shift + ctrl + p and type “section” and find Add/Update section numbers tab shift + ctrl + [ or ] to change the title Table formatter tag alt + shift + f sort from Markdown语法","link":"/Memo/tools/markdown/"},{"title":"media-server build","text":"Docker-compose 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131version: &quot;3.8&quot;services: jellyseerr: image: fallenbagel/jellyseerr:latest container_name: jellyseerr environment: # - HTTP_PROXY=http://192.168.6.153:20171 # - HTTPS_PROXY=http://192.168.6.153:20171 # - no_proxy=&quot;localhost,127.0.0.1&quot; - LOG_LEVEL=debug - TZ=Asia/Shanghai # ports: # - 5055:5055 volumes: - ./jellyseerr_config:/app/config restart: unless-stopped network_mode: host sonarr: image: lscr.io/linuxserver/sonarr:latest container_name: sonarr environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai volumes: - ./sonarr_config:/config - /media:/Downloads ports: - 8989:8989 restart: unless-stopped network_mode: bridge radarr: image: lscr.io/linuxserver/radarr:latest container_name: radarr environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai volumes: - ./radarr_config:/config - /media:/Downloads ports: - 7878:7878 restart: unless-stopped network_mode: bridge jackett: image: lscr.io/linuxserver/jackett:latest container_name: jackett environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai - AUTO_UPDATE=true #optional # - RUN_OPTS= #optional volumes: - ./jackett_config:/config - /media:/Downloads ports: - 9117:9117 restart: unless-stopped network_mode: bridge metatube: image: metatube/metatube-server:latest container_name: metatube # ports: # - 6778:6778 restart: unless-stopped depends_on: - postgres environment: - HTTP_PROXY=http://192.168.6.153:20171 - HTTPS_PROXY=http://192.168.6.153:20171 volumes: - run:/var/run command: -dsn &quot;postgres://metatube:metatube@/metatube?host=/var/run/postgresql&quot; -port 6778 -db-auto-migrate -db-prepared-stmt network_mode: host postgres: image: postgres:15-alpine container_name: metatube-postgres restart: unless-stopped environment: - POSTGRES_USER=metatube - POSTGRES_PASSWORD=metatube - POSTGRES_DB=metatube volumes: - ./postgres/db:/var/lib/postgresql/data - run:/var/run command: &quot;-c TimeZone=Asia/Shanghai -c log_timezone=Asia/Shanghai -c listen_addresses='' -c unix_socket_permissions=0777&quot; network_mode: bridge AutoBangumi: image: &quot;ghcr.io/estrellaxd/auto_bangumi:latest&quot; container_name: AutoBangumi volumes: - ./autoBGM_config/config:/app/config - ./autoBGM_config/data:/app/data ports: - &quot;7892:7892&quot; restart: unless-stopped environment: - TZ=Asia/Shanghai - PGID=1000 - PUID=1000 - UMASK=022 network_mode: bridge qbittorrent: image: johngong/qbittorrent:latest container_name: qbittorrent volumes: - /media:/Downloads - ./qbittorrent:/config restart: unless-stopped environment: - TZ=Asia/Shanghai - PGID=1000 - PUID=1000 - UMASK=022 - QB_EE_BIN=true - QB_TRACKERS_LIST_URL=https://cf.trackerslist.com/best.txt - QB_WEBUI_PORT=8080 network_mode: hostvolumes: run:","link":"/Memo/tools/media-server/"},{"title":"Nginx备忘","text":"使用 nginx 解决跨域 分析前准备： 前端网站地址： http://localhost:3000 服务端网址： http://localhost:8080 响应头 跨域主要涉及4个响应头： Access-Control-Allow-Origin 用于设置允许跨域请求源地址 （预检请求和正式请求在跨域时候都会验证） Access-Control-Allow-Headers 跨域允许携带的特殊头信息字段 （只在预检请求验证） Access-Control-Allow-Methods 跨域允许的请求方法或者说 HTTP 动词 （只在预检请求验证） Access-Control-Allow-Credentials 是否允许跨域使用 cookies，如果要跨域使用 cookies，可以添加上此请求响应头，值设为 true（设置或者不设置，都不会影响请求发送，只会影响在跨域时候是否要携带 cookies，但是如果设置，预检请求和正式请求都需要设置）。不过不建议跨域使用（项目中用到过，不过不稳定，有些浏览器带不过去），除非必要，因为有很多方案可以代替。 什么是预检请求？：当发生跨域条件时候，览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错 nginx 配置 完整版：根据报错进行添加删除 123456789101112131415161718server { listen 22222; server_name localhost; location / { if ($request_method = 'OPTIONS') { add_header Access-Control-Allow-Origin 'http://localhost:3000'; add_header Access-Control-Allow-Headers '*'; add_header Access-Control-Allow-Methods '*'; add_header Access-Control-Allow-Credentials 'true'; return 204; # 解决 It does not have HTTP ok status. } if ($request_method != 'OPTIONS') { add_header Access-Control-Allow-Origin 'http://localhost:3000' always; add_header Access-Control-Allow-Credentials 'true'; } proxy_pass http://localhost:8080; } } 或者 1234567891011121314server { listen 22222; server_name localhost; location / { add_header Access-Control-Allow-Origin 'http://localhost:8080' always; add_header Access-Control-Allow-Headers '*'; add_header Access-Control-Allow-Methods '*'; add_header Access-Control-Allow-Credentials 'true'; if ($request_method = 'OPTIONS') { return 204; } proxy_pass http://localhost:59200; } } 个人精简版 1234567891011121314server { listen 22222; server_name localhost; # 可以根据实际情况更改 location / { add_header Access-Control-Allow-Origin 'http://localhost:3000' always; add_header Access-Control-Allow-Headers '*'; add_header Access-Control-Allow-Methods '*'; if ($request_method = 'OPTIONS') { return 204; } proxy_pass http://localhost:8080; }} 解决问题 add_header Access-Control-Allow-Origin ' http://localhost:3000 ' always;：解决Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. always; 解决每次响应信息都携带头字段信息 if ($request_method = 'OPTIONS') {return 204; } ：解决跨域浏览器默认行为的预请求（option 请求）没有收到 ok 状态码，此时再修改配置文件，当请求为 option 请求时候，给浏览器返回一个状态码（一般是204） add_header Access-Control-Allow-Headers '*'; ： 解决 Request header field authorization is not allowed by Access-Control-Allow-Headers in preflight response. add_header Access-Control-Allow-Methods '*';：比较早期的 API 可能只用到了 POST 和 GET 请求，而 Access-Control-Allow-Methods 这个请求响应头跨域默认只支持 POST 和 GET，当出现其他请求类型时候，同样会出现跨域异常。 原帖","link":"/Memo/tools/nginx/"},{"title":"webDAV","text":"windows 下启用webDAV windows 组件安装 控制面板-程序-程序和功能-启用或关闭 windows 功能 启用： Internet Information Service - Web管理工具 下的 IIS管理控制台 Internet Information Service - 万维网服务 - 安全性 下的 基本身份验证 和 Windows 身份验证 Internet Information Service - 万维网服务 - 常见 Http 功能 下的 WebDAV 发布 和 目录浏览 配置 WebDAV 服务 打开 IIS管理器 添加网站 - 填写网络名称 - 物理路径 - 端口号 WebDAV 创作规则 - 添加创作规则 - 允许所有用户 - 打开权限 - 启用 WebDAV 身份验证 - 只启用基本身份验证 目录浏览 - 启用目录浏览 重新启动站点","link":"/Memo/tools/webDAV/"},{"title":"娱乐至死","text":"元数据 [!abstract] 娱乐至死 书名： 娱乐至死 作者： [美]尼尔·波兹曼 高亮划线 第1章 媒介即隐喻 📌 我形象地使用“会话”这个词，并不仅仅指语言，同时也指一切使某个文化中的人民得以交流信息的技巧和技术。在这样的意义上，整个文化就是一次会话，或者更准确地说，是以不同象征方式展开的多次会话的组合。 ⏱ 2023-05-13 16:12:38 📌 我们可以了解来自世界各地对于各种事件的片断报道，因为我们拥有适用于报道这些片断的多种媒体。如果某种文化中没有具有闪电般速度的传媒工具，如果烟雾信号仍是最有效的传播途径，那么这种文化就不会拥有“今日新闻”。如果没有媒体为新闻提供传播的形式，那么“今日新闻”就不会存在。 ⏱ 2023-05-13 16:20:21 📌 深入一种文化的最有效途径是了解这种文化中用于会话的工具。 ⏱ 2023-05-13 16:30:08 📌 那些如今已经习惯于用图画、雕塑或其他具体形象表达思想的人，会发现他们无法像原来一样去膜拜一个抽象的神。犹太人的上帝存在于文字中，或者通过文字而存在，这需要人们进行最精妙的抽象思考。运用图像是亵渎神祇的表现，这样就防止了新的上帝进入某种文化。我们的文化正处于从以文字为中心向以形象为中心转换的过程中，思考一下摩西的训诫对我们也许是有益的。即使这些推想有不妥之处，我仍然认为它是明智而中肯的。我相信，某个文化中交流的媒介对于这个文化精神重心和物质重心的形成有着决定性的影响。 ⏱ 2023-05-13 16:47:42 📌 芒福德总结说：“钟表是一种动力机械，其产品是分和秒。”在制造分秒的时候，钟表把时间从人类的活动中分离开来，并且使人们相信时间是可以以精确而可计量的单位独立存在的。分分秒秒的存在不是上帝的意图，也不是大自然的产物，而是人类运用自己创造出来的机械和自己对话的结果。 ⏱ 2023-05-19 14:51:27 📌 钟表是怎样使人变成遵守时间的人、节约时间的人和现在拘役于时间的人。在这个过程中，我们学会了漠视日出日落和季节更替，因为在一个由分分秒秒组成的世界里，大自然的权威已经被取代了。 ⏱ 2023-05-19 14:56:39 📌 我这里想要指出的是，把诸如文字或钟表这样的技艺引入文化，不仅仅是人类对时间的约束力的延伸，而且是人类思维方式的转变，当然，也是文化内容的改变。 ⏱ 2023-05-19 15:03:12","link":"/Study/bookNote/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB/"},{"title":"Necessities","text":"取法乎上,得乎其中,取法乎中,得乎其下。 [ ] 算法 [ ] 剑指offer [ ] leetcode刷题 [ ] 数据结构 [ ] 链表、信息表烂熟 [ ] AVL、哈希表、堆等数据结构的实现 [ ] 计算机系统 [ ] 《深入理解计算机系统》 [ ] 配套试验 [ ] 内存分配、调度 [ ] 多线程 [ ] 调用操作系统的接口 [ ] 计算机网络 [ ] 《计算机网络 自顶向下方法》 [ ] 应用层、传输层原理 [ ] TCP协议的设计理念 [ ] 数据库 [ ] 编译原理 [ ] 动态、静态链接 [ ] 头文件 [ ] gcc [ ] makefile/cmake [ ] clang icc gcc 项目： [ ] Stanford CS144 计网 [ ] MIT 6.S081 操作系统 [ ] MIT 6.824 分布式系统 [ ] MIT 6.830/814 数据库系统 [ ] CMU 15-445 数据库系统","link":"/Study/career/Necessities/"},{"title":"cp2：信息的表示和处理","text":"信息存储 补码 补码的英文名称是 two's complement。 性质 ~x + 1 = -x 在补码表示法中，一个负数的补码等于它的绝对值的二进制表示取反再加上 1。也就是说，如果 x 是一个负数，则 ~x + 1 的结果就是 x 的绝对值的二进制表示。因此，~x + 1 就等于 -x 的补码表示。 举个例子，假设 x = -3，它的二进制表示是 11111101（8 位二进制）。那么 ~x 的结果就是 00000010，再加上 1 就是 00000011，这就是 -3 的补码表示。 这个等式在计算机中被广泛使用，因为它可以避免使用负号操作符，从而提高了运算速度和效率。 虚拟内存： 大多数计算机使用 8 位的块，或者字节(Byte)，作为最小的可寻址的内存单元，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual address space)。 内存的每个字节都有一个唯一的地址，所有可能地址的集合就称为虚拟地址空间。 字数据大小 unsigned 和 signed 之间的相互转换 unsigned 和 signed 建议不要混用 32位和64位系统中的字节大小差异 因为32位和64位系统，相同的数据类型会存在不同字节大小的差异。 于是ISO C99标准中出现了头文件stdint.h引入了intN_t和intN_t，对不同的N值指定N位有符号和无符号整数。 大多数编译器允许N为8、16、32和64 声明为uint16_t，表示一个16位无符号变量；声明为int32_t，表示一个32位有符号变量 使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。 用宏打印intN_t和intN_t 确定宽度类型的带格式打印需要使用宏，以与系统相关的方式扩展为格式串。因此，举个例子来说，变量x和y的类型是 int32_t和uint64_t，可以通过调用printf来打印它们的值，如下所示: 1printf(&quot;x=%&quot;PRId32“，y = %&quot;PRIu64&quot;\\n&quot;，x，y); 编译为64位程序时，宏PRId32展开成字符串“d”，宏PRIu64则展开成两个字符串“1”“u”。当C预处理器遇到仅用空格(或其他空白字符)分隔的一个字符串常量序列时，就把它们串联起来。因此，上面的 printf 调用就变成了: 1printf(&quot;x= %d,y= %lu\\n&quot;，x，y); 使用宏能保证:不论代码是如何被编译的，都能生成正确的格式字符串。 寻址和字节顺序 16进制浮点数的表示 相同的数字，用整数存储的和用浮点数存储的十六进制数不一样 整数中除了最高有效位1，其他都存在与浮点数中 算术右移（&gt;&gt;）与逻辑右移（&gt;&gt;&gt;） 逻辑右移就是不考虑符号位，右移一位，左边补零即可。 算术右移需要考虑符号位，右移一位，若符号位为1，就在左边补1,；否则，就补0。 移位 x x < 3> 2(逻辑的) x >> 2(算术的) 十六进制 二进制 二进制 十六进制 二进制 十六进制 二进制 十六进制 0xC3 11000011 00011000 0x18 00110000 0x30 11110000 0xF0 0x75 01110101 10101000 0xA8 00011101 0x1D 00011101 0x1D 0x87 10000111 00111000 0x38 00100001 0x21 11100001 0xE1 0x66 01100110 00110000 0x30 00011001 0x19 00011001 0x19 整数表示 show_bytes() 12345678910111213141516171819202122#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;void show_bytes(byte_pointer start, size_t len) { size_t i; for (i = 0; i &lt; len; i++) printf(&quot; %.2x&quot;, start[i]); printf(&quot;\\n&quot;);}void show_int(int x) { show_bytes((byte_pointer) &amp;x, sizeof(int));}void show_float(float x) { show_bytes((byte_pointer) &amp;x, sizeof(float));}void show_pointer(void *x) { show_bytes((byte_pointer) &amp;x, sizeof(void *));} C语言中的有符号数和无符号数 当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行运算。 升级规则 表达式 类型 求值 -2147483647-1 == 2147483648U 无符号 1 -2147483647-1 &lt; 2147483647 有符号 1 -2147483647-1U &lt; 2147483647 无符号 0 -2147483647-1 &lt; -2147483647 有符号 1 -2147483647-1U &lt; -2147483647 无符号 0 扩展一个数字的位表示 从一个较小的数据类型转换到一个较大的数据类型是可以的 零扩展(zero extension) 123456789101112short sx = -12345; /*-12345*/unsigned short usx = sx; /* 53191*/int x = sx; /* -12345*/unsigned ux = usx; /* 53191*/printf(&quot;sx = %d:\\t&quot;, sx);show_bytes((byte_pointer) &amp;sx, sizeof(short));printf(&quot;usx = %u:\\t&quot;, usx);show_bytes((byte_pointer) &amp;usx, sizeof(unsigned short));printf(&quot;x = %d:\\t&quot;, x);show_bytes((byte_pointer) &amp;x, sizeof(int));printf(&quot;ux = %u:\\t&quot;, ux);show_bytes((byte_pointer) &amp;ux, sizeof(unsigned)); 在采用补码表示的 32 位大端法机器上运行这段代码时，打印出如下输出： 1234sx = -12345: cf c7usx = 53191: cf c7x = -12345: ff ff cf c7ux = 53191: 00 00 cf c7 从一个较大的数据类型转换到一个较小的数据类型是不可以的 12345short sx = -12345; /*-12345*/unsigned uy = sx;printf(&quot;uy = %u:\\t&quot;, uy);show_bytes((byte_pointer) &amp;uy, sizeof(unsigned)); 在一台大端法机器上运行这段代码时，打印出如下输出： 1uy = 4294954951: ff ff cf c7 这表明当把short转换为unsigned时，我们应该先改变大小，之后再完成从有符号到无符号的转换。也就是说(unsigned)sx等价于(unsigned)(int)sx，求值得到4294954951，而不等价于(unsigned)(unsigned short)sx，后者求值得到53191。 C 函数 1234567int fun1(unsigned word) { return (int) ((word &lt;&lt; 24) &gt;&gt; 24);}int fun2(unsigned word) { return ((int) word &lt;&lt; 24) &gt;&gt; 24;} word func1 func2 0x00000076 0x00000076 0x00000076 0x87654321 0x00000021 0x00000021 0x000000C9 0x000000C9 0xFFFFFFC9 0xEDCBA987 0x00000087 0xFFFFFF87 func1 没有改变word的值 func2 当word倒数第二个字节位置处的数字大于等于8时，会输出一个负数 整数运算 加法 无符号加法 x -x(u 4) 十六进制 十进制 十进制 十六进制 0 0 0 0 5 5 11 B 8 8 8 8 D 13 3 3 F 15 1 1 2.28 代码 12345/* Determine whether arguments can be added without overflow */int uAdd_ok(unsigned x, unsigned y) { unsigned sum = x + y; return sum &gt;= x;} 补码加法 x y x + y x + y(t 5) 情况 [10100](-12) [10001](-15) [100101](-27) [00101](5) 1 [11000](-8) [11000](-8) [110000](-16) [10000](-16) 2 [10111](-9) [01000](8) [111111](-1) [11111](-1) 2 [00010](2) [00101](5) [000111](7) [00111](7) 3 [01100](12) [00100](4) [010000](16) [10000](-16) 4 2.29 代码 1234567/* Determine whether arguments can be added without overflow */int tAdd_ok(int x, int y) { int sum = x + y; int neg_over = x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; sum &gt;= 0; int pos_over = x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; sum &lt; 0; return !neg_over &amp;&amp; !pos_over;} 补码的非","link":"/Study/csapp/cp2/"},{"title":"cp3 程序的机器级表示","text":"名词 ISA：Instruction Set Architecture(指令集架构)的缩写，也叫指令集体系结构。它定义了机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 PC：程序计数器，在x86-64中称为%rip，表示下一条要执行的指令在内存中的地址。 scalar data types：标量数据类型，是计算机科学中的一个术语。标量是指一种基本的数据类型，它表示单个值，并且不可拆分为更小的部分。标量数据类型在程序设计中非常常见，包括整数、浮点数、字符和布尔型等。 vector：向量，表示一种被用于向量数据计算或是多媒体处理等运算的指令集或硬件加速器。这些指令集和硬件加速器通常用于执行一些对于大规模数据和向量的加速运算，如矩阵乘法、卷积等。 gcc 参数 优化等级 -Og：告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级 使用较高的优化级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系难以理解。 实际上，从得到的程序的性能考虑，较高级别的优化被认为是较好的选择 例如，以选项 -O1 或 -O2 指定 汇编代码 C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏。 -S：能看到C语言编译器产生的汇编代码。 生成 *.s 汇编文件，但是不做其他进一步的工作。 目标代码 汇编器将 *.s 文件的汇编代码转换为二进制的目标代码文件。并生成目标代码文件 *.o。 包含所有指令的二进制表示，但还没填入全局的地址 -c：GCC会编译并汇编该代码，生成 *.o 文件 它是二进制格式的，无法直接查看 可执行代码 -o：链接器将目标代码文件 *.o 与实现库函数的代码合并，并产生最终的可执行代码文件。 文件名由 -o 文件名 指定 反汇编器 objdump -d 文件名：根据机器代码产生一种类似于汇编代码的格式。针对*.o文件。 数据格式 C declaration Intel data type Assembly-code suffix Size (bytes) char Byte b 1 short Word w 2 int Double word l 4 long Quad word q 8 char * Quad word q 8 float Single precision s 4 double Double precision l 8 访问信息 最初的8086中有 8 个 16 位的寄存器，即下表中 %ax ~ %sp IA32中寄存器扩展为32位，标号有 %eax ~ %esp X86-64中寄存器扩展成64位，编号有 %rax ~ %rsp，还增加了 8 个寄存器 63 ~ 31 31 ~ 15 15 ~ 7 7 ~ 0 usage %rax %eax %ax %al return value %rbx %ebx %bx %bl Callee saved %rcx %ecx %cx %cl 4th argument %rdx %edx %dx %dl 3rd argument %rsi %esi %si %sil 2nd argument %rdi %edi %di %dil 1st argument %rbp %ebp %bp %bpl Callee saved %rsp %esp %sp %spl Stack pointer %r8 %r8d %r8w %r8b 5th argument %r9 %r9d %r9w %r9b 6th argument %r10 %r10d %r10w %r10b Callee saved %r11 %r11d %r11w %r11b Callee saved %r12 %r12d %r12w %r12b Callee saved %r13 %r13d %r13w %r13b Callee saved %r14 %r14d %r14w %r14b Callee saved %r15 %r15d %r15w %r15b Callee saved 字节级操作可以访问最低的字节 16位操作可以访问最低的两个字节 32位操作可以访问最低的四个字节 64位操作可以访问整个寄存器 操作数指示符 立即数(immediate): 在ATT格式的汇编代码中，立即数的书写方式是 $ 后面跟一个用标准 C 表示法表示的整数，例如$-577、$0x1F。 寄存器(register): ra 表示任意寄存器a，用引用 R[ra] 来代表它的值 内存引用：根据地址访问内存位置。用符号 Mb[Addr] 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。通常省略 b 最下面的表示是最常用的形式 数据传送指令 S：源操作数（source operand） D：目标操作数（destination operand） I：立即数操作数（immediate operand） R：寄存器操作数（register operand） 简单的数据传送指令 根据源操作数选择指令 使用到操作数格式寻址时，必须为64位寄存器 两个操作数不能都为内存地址，进行mov其中一个必须为寄存器 不能以立即数作为目标操作数 Instruction Effect Description mov S, D D ← S Move movb Move byte movw Move word movl Move double word movq Move quad word movabsq I, R R ← I Move absolute quad word movl 指令以寄存器作为目标时，会把该寄存器的高位4字节设置为0 x86-64采用的惯例，即任何为寄存器生成32位值的指令都会将该寄存器的高位部分设置为0 零扩展数据传送指令 Instruction Effect Description movz S,R R ← ZeroExtend(S) Move with zero extension movzbw Move zero-extended byte to word movzbl Move zero-extended byte to double word movzwl Move zero-extended word to double word movzbq Move zero-extended byte to quad word movzwq Move zero-extended word to quad word 以寄存器或内存为源，以寄存器作为目的 MOVZ 类指令把目的中的剩余的字节填充为0 符号扩展数据传送指令 Instruction Effect Description movs S,R R ← SignExtend(S) Move with sign extension movsbw Move sign-extended byte to word movsbl Move sign-extended byte to double word movswl Move sign-extended word to double word movsbq Move sign-extended byte to quad word movswq Move sign-extended word to quad word movslq Move sign-extended double word to quad word cltq %rax ← SignExtend(%eax) Sign-extend %eax to %rax 以寄存器或内存为源，以寄存器作为目的 cltq 指令它没有操作数，总是以 %eax 为源，以 %rax 为符号扩展结果的目的。它的效果和 movslq %eax, %rax 完全一致 MOVZ 类指令通过符号扩展来填充，把源操作的最高位进行复制 压入和弹出栈数据 Instruction Effect Description pushq S R[%rsp] ← R[%rsp] –8;M[R[%rsp]] ← S Push quad word popq D D ← M[R[%rsp]];R[%rsp] ← R[%rsp] + 8 Pop quad word pushq 等价 12subq $8,%rspmovq %rbp,(%rsp) popq 等价 12movq (%rsp),%raxaddq $8,$rsp 虽然等价，但是 pushq 和 popq 的指令编码仅为一个字节，而上面两条指令一共需要八个字节 栈和程序代码以及其它形式的程序数据都放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内任何位置 算数和逻辑操作 Instruction Effect Description leaq S, D D ← &amp;S Load effective address inc D D ← D + 1 Increment dec D D ← D - 1 Decrement neg D D ← -D Negate not D D ← ~D Complement add S, D D ← D + S Add sub S, D D ← D - S Subtract imul S, D D ← D * S Multiply xor S, D D ← D ^ S Exclusive-or or S, D D ← D | S Or and S, D D ← D &amp; S And sal k, D D ← D &lt;&lt; k Left shift shl k, D D ← D &lt;&lt; k Left shift (same as sal) sar k, D D ← D &gt;&gt;A k Arithmetic right shift shr k, D D ← D &gt;&gt;L k Logical right shift 加载有效地址(leaq)指令通常用来执行简单的算术操作 ATT格式的汇编代码中操作数的顺序与一般的直觉相反 加载有效地址(leaq) 实际上是movq指令的变形，指令形式是从内存读数据到寄存器，但实际上根本没有引用内存 该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数 它可以简洁的描述普通的算术操作 如果寄存器 %rdx 的值为 x，那么指令 leaq 7(%rdx, %rdx, 4)，%rax 将设置寄存器 %rax 的值为 5x + 7 目的数必须为一个寄存器 例如： c程序 1234long scale(long x, long y, long z) { long t = x + 4 * y + 12 * z; return t;} 编译时，算术运算将以三条 leaq 指令实现： 1234567 // long scale(long x, long y, long z) // x in %rdi, y in %rsi, z in %rdxscale: leaq (%rdi,%rsi,4), %rax // x + 4*y leaq (%rdx,%rdx,2), %rdx // z + 2*z = 3*z leaq (%rax,%rdx,4), %rax // (x+4*y) + 4*(3*z) = x + 4*y + 12*z ret 它能执行加法和有限形式的乘法 二元操作 源操作数是第一个，目的操作数是第二个 subq %rax,%rdx 可以解读为：从%rdx中减去%rax 第一个操作数可以是立即数、寄存器或是内存位置 第二个操作数可以是寄存器或是内存地址。 当第二个数位内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存 移位操作 SA SAL 移位量, 移位的数 移位量可以是一个立即数，或者放在单字节寄存器 %cl 中(能且只能放在这个特定寄存器) 当寄存器 %cl 的十六进制值为 0xFF 时，salb 会移 7 位，salw 会移 15 位，sall 会移 31 位，salq 会移 63 位 左移指令有两个名字：SAL 和 SHL 两者效果一致，都是将右边填上0 右移指令不同 SAR执行算术移位(填上符号位) SHR执行逻辑以为(填上0) xorq %rdx,%rdx 这个指令用来将寄存器设置为0 最直接的方法是 movq $0,%rdx xorq版本只需要三个字节，movq版本则需要七个字节 特殊的算术操作 x86-64 指令集对 128 位(16 字节)数的操作提供有限的支持。 延续字(2字节)、双字(4字节)和四字(8字节)的命名惯例，Intel 把16字节的数称为八字(oct word)。 Instruction Effect Description imulq S R[%rdx]:R[%rax] ← S × R[%rax] Signed full multiply mulq S R[%rdx]:R[%rax] ← S × R[%rax] Unsigned full multiply cqto R[%rdx]:R[%rax] ← SignExtend(R[%rax]) Convert to oct word idivq S R[%rdx] ← R[%rdx]:R[%rax] mod S;R[%rax] ← R[%rdx]:R[%rax] ÷ S Signed divide divq S R[%rdx] ← R[%rdx]:R[%rax] mod S;R[%rax] ← R[%rdx]:R[%rax] ÷ S Unsigned divide 控制 条件码 cf: 进位标志：最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。 (unsigned) t &lt; (unsigned) a Unsigned overflow zf: 零标志：最近的操作得出的结果为 0，如果两个操作数相等，零标志设置为 1 (t == 0) Zero sf: 符号标志：最近的操作得到的结果为负数 (t &lt; 0) Negative of: 溢出标志：最近的操作导致一个补码溢出–正溢出或负溢出 (a &lt; 0 == b &lt; 0) &amp;&amp; (t &lt; 0 ! = a &lt; 0) Signed overflow 访问条件码 条件码通常不会直接读取，常见使用方式： 可以根据条件码的某种组合，将一个字节设置为 0 或 1 可以条件跳转到程序的某个其他的部分 可以有条件地传送数据 跳转指令 12345678 movq %rdi, %rax jmp .L2.L3: sarq %rax.L2: testq %rax, %rax jg .L3 rep; ret 汇编器产生的“. o”格式的反汇编版本如下： 1234560: 48 89 f8 mov %rdi,%rax3: eb 03 jmp 8 &lt;loop+0x8&gt;5: 48 d1 f8 sar %rax8: 48 85 c0 test %rax,%raxb: 7f f8 jg 5 &lt;loop+0x5&gt;d: f3 c3 repz retq 链接后的程序反汇编版本： 1234564004d0: 48 89 f8 mov %rdi,%rax4004d3: eb 03 jmp 4004d8 &lt;loop+0x8&gt;4004d5: 48 d1 f8 sar %rax4004d8: 48 85 c0 test %rax,%rax4004db: 7f f8 jg 4004d5 &lt;loop+0x5&gt;4004dd: f3 c3 repz retq 条件控制实现条件分支 goto 风格代码与汇编代码实现条件控制时非常相似 c 语言中 if-else 语句的通用形式： 1234if (test-expr) then-statementelse else-statement Goto 风格代码块： 12345678 t = text-expr; if (!t) goto false; then-statement goto done;false: else-statementdone: 其中的 goto 在汇编中为 jmp 指令 练习 1234567891011long test(long x, long y, long z) { long val = x + y + z; if (x &lt; -3) { if (y &lt; z) val = x * y; else val = y * z; } else if (x &gt; 2) val = x * z; return val;} gcc 产生如下汇编代码 123456789101112131415161718192021222324long test(long x, long y, long z)x in %rdi, y in %rsi, z in %rdxtest:leaq (%rdi,%rsi), %raxaddq %rdx, %raxcmpq $-3, %rdijge .L2cmpq %rdx, %rsijge .L3movq %rdi, %raximulq %rsi, %raxret.L3:movq %rsi, %raximulq %rdx, %raxret.L2:cmpq $2, %rdijle .L4movq %rdi, %raximulq %rdx, %rax.L4:rep; ret 条件传送实现条件分支 条件操作的传统方式简单而通用，但在现代处理器上可能会非常低效。 条件传送指令。当传送条件满足时，指令把源值 S 复制到目的 R 同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。但不是所有情况下都可以使用条件传送。 1v = test-expr ? then-expr : else-expr 用条件控制转移的标准方法编译： 1234567 if (!test-expr) goto false; v = then-expr; goto done;false: v = else-expr;done: 基于条件传送代码会对两数都求值，可以用下面的抽象代码描述： 1234v = then-expr;ve = else-expr;t = test-expr;if (!t) v = ve; GCC 只有在两个表达式都很容易计算时，例如表达式分别都是一条加法指令，它才会使用条件传送。 即使许多分支预测错误的开销会超过更复杂的计算，GCC 还是会使用条件控制转移。 条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的情况。 循环 while 循环 C 123456789long fact_while(long n){ long result = 1; while (n &gt; 1) { result *= n; n = n-1; } return result;} Goto version 123456789101112long fact_while_jm_goto(long n){ long result = 1; goto test;loop: result *= n; n = n-1;test: if (n &gt; 1) goto loop; return result;} assembly-language code 12345678910111213long fact_while(long n)n in %rdifact_while: movl $1, %eax Set result = 1 jmp .L5 Goto test.L6: loop: imulq %rdi, %rax Compute result *= n subq $1, %rdi Decrement n.L5: test: cmpq $1, %rdi Compare n:1 jg .L6 If &gt;, goto loop rep; ret Return Guarded-do 翻译方法 首先使用条件分支 如果初始条件不成立就跳过循环，把代码变换为 do-while 循环。 当使用较高优化等级时，例如使用命令行选项 -O1 时，GCC 会采用这种策略。 1234567t = test-expr;if (!t) goto done;do body-statement while (test-expr);done: Goto version 123456789t = test-expr;if (!t) goto done;loop: body-statement t = test-expr; if (t) goto loop;done: 过程 运行时栈 通用的栈帧结构 栈用来传递参数、存储返回信息、保持寄存器，以及局部存储 为了提高空间和时间效率，x86-64 过程只分配自己所需要的栈帧部分 许多过程有 6 个或者更少的参数，那么所有的参数都可以通过寄存器传递 实际上，许多函数甚至根本不需要栈帧 当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，就可以这样处理。 练习 汇编代码： 1234567891011121314151617 Disassembly of leaf(long y) y in %rdi1 0000000000400540 &lt;leaf&gt;:2 400540: 48 8d 47 02 lea 0x2(%rdi),%rax L1: z+23 400544: c3 retq L2: Return4 0000000000400545 &lt;top&gt;: Disassembly of top(long x) x in %rdi5 400545: 48 83 ef 05 sub $0x5,%rdi T1: x-56 400549: e8 f2 ff ff ff callq 400540 &lt;leaf&gt; T2: Call leaf(x-5)7 40054e: 4801c0 add %rax,%rax T3: Double result8 400551:c3 retq T4: Return ... Call to top from function main9 40055b: e8 e5 ff ff ff callq 400545 &lt;top&gt; M1: Call top(100)10 400560: 4889c2 mov %rax,%rdx M2: Resume 代码执行过程表： 数据传送 函数传参少于等于六个时的寄存器： 大于六个的部分使用栈传递 7~n 放到栈上，而参数 7 位于栈顶 例如 C code 12345678910void proc(long a1, long *a1p, int a2, int *a2p, short a3, short *a3p, char a4, char *a4p){ *a1p += a1; *a2p += a2; *a3p += a3; *a4p += a4;} Assembly code 123456789101112131415161718 void proc(a1, a1p, a2, a2p, a3, a3p, a4, a4p) Arguments passed as follows: a1 in %rdi (64 bits) a1p in %rsi (64 bits) a2 in %edx (32 bits) a2p in %rcx (64 bits) a3 in %r8w (16 bits) a3p in %r9 (64 bits) a4 at %rsp+8 ( 8 bits) a4p at %rsp+16 (64 bits)1 proc:2 movq 16(%rsp), %rax Fetch a4p (64 bits)3 addq %rdi, (%rsi) *a1p += a1 (64 bits)4 addl %edx, (%rcx) *a2p += a2 (32 bits)5 addw %r8w, (%r9) *a3p += a3 (16 bits)6 movl 8(%rsp), %edx Fetch a4 (8 bits)7 addb %dl, (%rax) *a4p += a4 (8 bits)8 ret Return 超出六个部分的栈帧结构： 寄存器中的局部存储空间 x86-64采用统一的寄存器使用管理： 寄存器 %rbx、%rbp 和 %r12 ~ %r15 被划分为被调用者保存寄存器 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证他们的值在 Q 返回到 P 时与 Q 被调用时是一样的 Q 为了保存一个寄存器的值不变 要么不改变它 要么把原始的值压入栈中，改变寄存器的值，在返回前从栈中弹出旧值 压入寄存器的值会在栈帧中创建标号为“被保存的寄存器”的一部分 所有其他的寄存器，除了栈指针 %rsp ，都分类为调用者保存寄存器 这意味着任何函数都能修改他们 调用之前首先保存好这个数据是调用者 (P) 的责任 数组分配和访问 嵌套的数组 int A[5][3] 等价于 typedef int row3_t[3]; row3_t A[5]; 将数组 A[i][j] 复制到寄存器 %eax 中： 1234 A in %rdi, i in %rsi, and j in %rdx1 leaq (%rsi,%rsi,2), %rax Compute 3i2 leaq (%rdi,%rax,4), %rax Compute xA + 12i3 movl (%rax,%rdx,4), %eax Read from M[xA + 12i + 4] 练习 C code 123456/* Set all diagonal elements to val */void fix_set_diag(fix_matrix A, int val) { long i; for (i = 0; i &lt; N; i++) A[i][i] = val;} Optimization assembly code 1234567891011fix_set_diag:void fix_set_diag(fix_matrix A, int val)A in %rdi, val in %rsi movl $0, %eax.L13: movl %esi, (%rdi,%rax) addq $68, %rax cmpq $1088, %rax jne .L13 rep; ret Optimization c code 1234567891011/* Set all diagonal elements to val */void fix_set_diag_opt(fix_matrix A, int val) { int *Abase = &amp;A[0][0]; long i = 0; long iend = N * (N + 1); do { Abase[i] = val; i += (N + 1); } while (i != iend);} 达到下一个对角线元素的地址恰好为 i += (N + 1) 变长数组 在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算。 如果允许使用优化，GCC 能够识别出程序访问多维数组的元素的步长。 生成的代码会避免直接应用规律等式会导致的乘法。 无论生成基于指针的代码还是基于数组的代码，这些优化都能显著提高程序的性能。 异质的数据结构 结构 struct 123456struct rec { int i; int j; int a[2]; int *p;}; 对应在内存中为： 联合 union 12345678910struct S3 { char c; int i[2]; double v;};union U3 { char c; int i[2]; double v;}; 对应在内存中为： 一个 union 的总的大小等于它最大字段的大小 它会绕过 C 语言类型系统提供的安全措施 已知一个数据结构中两个不同字段的使用是互斥的，若将这两个字段声明为 union 的一部分，而不作为 struct 的一部分，会减少分配空间的总量 例一 二叉树数据结构： 12345struct node_s { struct node_s *left; struct node_s *right; double data[2];}; 一个节点需要 32 个字节 改为 union： 1234567union node_u { struct { union node_u *left; union node_u *right; } internal; double data[2];}; 一个节点只需要 16 个字节 但这样编码没法确定一个给定的节点是叶子节点还是内部节点 可以通过引入一个枚举类型，定义这个 union 中可能的不同选择，然后再创建一个结构 123456789101112typedef enum { N_LEAF, N_INTERNAL } nodetype_t;struct node_t { nodetype_t type; union { struct { struct node_t *left; struct node_t *right; } internal; double data[2]; } info;}; 这个结构总共需要 24 个字节 type 是 4 个字节 info.internal.left 和 info.internal.right 各要 8 个字节 info.data 要 16 个字节 在字段 type 和 union 的元素之间需要 4 个字节的填充 过于麻烦带来的收益较小，但是对于较多字段的数据结构还是很吸引人的 数据对齐 许多系统对基本数据类型的合法地址作出限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4 或 8)的倍数 目的是提高内存系统的性能 假设一个处理器总是从内存中取 8 个字节，则地址必须是 8 的倍数 如果我们能保证将所有的 double 类型数据的地址都对齐成 8 的倍数，那么就可以只用一个内存操作来读或写值了 否则可能需要执行两次内存访问，因为对象被分放在两个 8 字节内存块中 汇编命令 .align 8 代表后面每个元素都会遵守 8 字节对齐的限制 例如考虑下列 struct 声明： 12345struct S1 { int i; char c; int j;}; 假设用最小的 9 字节分配： 对齐之后： 向后补齐的例子： 在机器级程序中将控制与数据结合起来 内存越界引用和缓冲区溢出 库函数 gets 的一个实现： 1234567891011121314151617181920/* Implementation of library function gets() */char *gets(char *s){ int c; char *dest = s; while ((c = getchar()) != `n' &amp;&amp; c != EOF) *dest++ = c; if (c == EOF &amp;&amp; dest == s) /* No characters read */ return NULL; *dest++ = `0'; /* Terminate string */ return s;}/* Read input line and write it back */void echo(){ char buf[8]; /* Way too small! */ gets(buf); puts(buf);} 汇编代码： 123456789void echo()echo:subq $24, %rsp Allocate 24 bytes on stackmovq %rsp, %rdi Compute buf as %rspcall gets Call getsmovq %rsp, %rdi Compute buf as %rspcall puts Call putsaddq $24, %rsp Deallocate stack spaceret Return echo 函数的栈组织： 存在以下问题： Characters typed Additional corrupted state 0–7 None 9–23 Unused stack space 24–31 Return address 32+ Saved state in caller 对抗缓冲区溢出攻击 栈随机化 使得栈的位置在程序每次运行时都有变化，即使不同的机器运行相同的代码，栈地址都是不同的 在 linux 系统中，有一个技术：地址空间布局随机化，简称 ASLR 每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域 空操作雪橇 (nop sled) 执着的攻击者用蛮力克服随机化，反复的用不同的地址进行攻击 在实际攻击代码之前插入很长一段 nop 指令，不停的对程序计数器加一，直到找到序列中的某个地址，程序就会经过这个序列到达攻击代码。 但是在 64 位系统的出现，进行攻击需要尝试枚举更多更长的地址，大大降低了病毒或者蠕虫的传播速度 栈破坏检测 金丝雀 在栈帧中的任何局部缓冲区与栈状态之间存储一个特殊的值 在程序每次运行时随机产生 限制可执行代码区域 浮点代码 媒体 (media) 指令 这些指令的本意是允许多个操作以并行模式执行，称为单指令多数据或 SIMD 这种模式中，对多个不同的数据并行执行同一个操作 最早出现的是 MMX ，然后从 MMX 到 SSE (streaming SIMD extensions 流式 SIMD 扩展)，以及最新的 AVX (advanced vector extensions 高级向量扩展) 每个扩展都是管理寄存器组中的数据 MMX 中称为 “MM” 寄存器 (64 位) SSE 中称为 “XMM” 寄存器 (128 位) AVX 中称为 “YMM” 寄存器 (256 位) 所以每个 YMM 寄存器可以存放 8 个 32 位值，或 4 个 64 位值，这些值可以是整数或者浮点数 当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位 (对于 float) 或 64 位 (对于 double) 浮点传送和转换操作 引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作 建议 32 位内存数据满足 4 字节对齐，64 位满足 8 字节对齐 浮点传送指令。X: XMM 寄存器，M32: 32-bit memory range; M64: 64-bit memory range 对于在两个 XMM 寄存器之间传送数据，GCC 会使用上图倒数两种指令之一 这种情况，程序复制整个寄存器还是只复制低位值既不会影响程序功能也不会影响执行速度 所以使用这些指令还是针对标量数据的指令没有实质上的差别 字母 a 表示 “aligned (对齐的)” 当用于读写内存时，如果地址不满足 16 字节对齐，它们会导致异常 但在两个寄存器之间传送数据，绝对不会出现错误对齐的情况 这些操作将浮点数转换成整数 第一个源的数据类型转换成目的的数据类型，它读自内存或一个通用的目的寄存器 第二个源值只会影响结果的高位字节，可以忽略 目标必须是 XMM 寄存器 最常见的使用场景中，第二个源和目的操作数都是一样的 例如：vcvtsi2sdq %rax, %xmm1, %xmm1 它从 %rax 中读出一个长整数，转换为数据类型 double，最后把结果放进 XMM 寄存器 %xmm1 的低字节中 vunpcklps 指令通常用来交叉放置来自两个 XMM 寄存器的值，把他们存储到第三个寄存器中。若一个源寄存器的内容为字 [s3, s2, s1, s0] ，另一个源寄存器的内容 [d3, d2, d1, d0]，那么目的寄存器的值会是 [s1, d1, s0, d0] 。 例子 c code 12345678double fcvt(int i, float *fp, double *dp, long *lp){ float f = *fp; double d = *dp; long l = *lp; *lp = (long) d; *fp = (float) i; *dp = (double) l; return (double) f;} x86-64 assembly code 123456789101112131415double fcvt(int i, float *fp, double *dp, long *lp) i in %edi, fp in %rsi, dp in %rdx, lp in %rcxfcvt: vmovss (%rsi), %xmm0 Get f = *fp movq (%rcx), %rax Get l = *lp vcvttsd2siq (%rdx), %r8 Get d = *dp and convert to long movq %r8, (%rcx) Store at lp vcvtsi2ss %edi, %xmm1, %xmm1 Convert i to float vmovss %xmm1, (%rsi) Store at fp vcvtsi2sdq %rax, %xmm1, %xmm1 Convert l to double vmovsd %xmm1, (%rdx) Store at dpThe following two instructions convert f to double vunpcklps %xmm0, %xmm0, %xmm0 vcvtps2pd %xmm0, %xmm0 ret Return f 浮点数操作 S1 可以是一个 XMM 寄存器或一个内存位置 S2 和 D 必须都是 XMM 寄存器 例子 assembly code 123456789101112double funct2(double w, int x, float y, long z)w in %xmm0, x in %edi, y in %xmm1, z in %rsifunct2: vcvtsi2ss %edi, %xmm2, %xmm2 vmulss %xmm1, %xmm2, %xmm1 vunpcklps %xmm1, %xmm1, %xmm1 vcvtps2pd %xmm1, %xmm2 vcvtsi2sdq %rsi, %xmm1, %xmm1 vdivsd %xmm1, %xmm0, %xmm0 vsubsd %xmm0, %xmm2, %xmm0 ret 转换以上汇编代码为 c 语言版本：y * x - w / z 定义和使用浮点常数 和整数运算操作不同，AVX 浮点操作不能以立即数值作为操作数 编译器必须为所有的常量值分配和初始化存储空间，然后代码再把这些值从内存读入 例子 c code 1234double cel2fahr(double temp){ return 1.8 * temp + 32.0;} assembly code 1234567891011double cel2fahr(double temp) temp in %xmm0cel2fahr: vmulsd .LC2(%rip), %xmm0, %xmm0 Multiply by 1.8 vaddsd .LC3(%rip), %xmm0, %xmm0 Add 32.0 ret.LC2: .long 3435973837 Low-order 4 bytes of 1.8 .long 1073532108 High-order 4 bytes of 1.8.LC3: .long 0 Low-order 4 bytes of 32.0 .long 1077936128 High-order 4 bytes of 32.0 位级操作 比较操作 S1 可以在 XMM 寄存器中也可以在内存中 S2 必须在 XMM 寄存器中 浮点比较指令会设置三个条件码： 零标志位 ZF 进位标志位 CF 奇偶标志位 PF 当两个操作数中人一个是 NaN 时就会设置该位 当任意操作数为 NaN，就会出现 Unordered 情况","link":"/Study/csapp/cp3/"},{"title":"cp4 处理器体系结构","text":"Y86-64 指令集体系结构 程序员可见状态 省略了 %r15 以简化指令的编码 三个一体的条件码：ZF、SF 和 OF Stat：状态码，表明程序执行的总体状态 Y86-64 指令 Y86-64 指令集基本上是 x86-64 指令集的一个子集，它只包括 8 字节整数操作，寻址方式较少，操作也较少。下面是一些细节： 左边是指令的汇编码表示，右边是字节编码 X 86-64 的 movq 指令分成了 4 个不同的指令：irmovq、rrmovq、mrmovq 和 rmmovq 分别显式地指明源和目的的格式 源可以是立即数（i）、寄存器（r）或内存（m），指令名字第一个字母就表明了源的类型 目的可以是寄存器（r）和内存（m），指令名字第二个字母指明了目的的类型 和 x 86-64 一样，不允许从一个内存地址直接传送到另一个内存地址。 另外，也不允许将立即数传送到内存 有 4 个整数操作指令，如 OPg，它们是 addq、subq、andq 和 xorq 只会对寄存器数据进行操作，而 x86-64 还允许对内存数据进行这些操作 它们会设置三个条件码 halt 指令停止指令的执行。x86-64 中有一个与之相当的 hlt x86-64 的应用程序不允许使用这条指令，它会导致整个系统暂停运行 对于 Y86-64 来说，执行 halt 指令会导致处理停止运行，并将状态码设置为 HLT 指令编码长度从 1 个字节到 10 个字节不等 一条指令含有一个单字节的指令指示符，可能含有一个单字节的寄存器指示符，还可能含有一个 8 字节的常数字 fn 指明是某个整数操作（OPg）、数据传送条件（cmovXX）或是分支条件（jXX） 所有的数值均用十六进制表示 指令编码 每条指令需要 1~ 10 个字节不等，每条指令的第一个字节表明指令的类型 这个字节分为两个部分 高四位是代码部分 第四位是功能部分 如图 4.2 所示，代码值为 0~0xB Y86-64 中的寄存器编号和 x86-64 相同，当需要指明不应访问任何寄存器时，就用 ID 值 0xF 来表示 Y86-64 异常 逻辑设计和硬件控制语言 HCL 逻辑门 HCL 用 HCL 来表达： 12345word Min3 = [ A &lt;= B &amp;&amp; A &lt;= C : A; B &lt;= A &amp;&amp; B &lt;= C : B; 1 : C;]; ALU 存储器和时钟 寄存器操作 寄存器输出会一直保持在当前寄存器状态上，直到时钟信号上升 当时钟上升时，寄存器输入上的值会成为新的寄存器状态 读端口：A 和 B 写端口：W 这样一个多端口随机访问存储器允许同时进行多个读和写操作 当 srcA 或 srcB 被设置成某个寄存器 ID 时，在一段延迟之后，寄存器中的值就会出现在 valA 或 valB 上 例如：srcA = 3，就会读出 %rbx 的值，然后出现在输出 valA 上 每次时钟上升时，输入 valW 上的值会被写入输入 dstW 上的寄存器 ID 指示的程序寄存器 当 dstW 设为特殊 ID 值为 0xF 时，不会写入 Y86-64 的顺序实现 将处理器组织成阶段 fetch：从内存读取指令字节，地址为程序计数器 (PC) 的值。有两个四字节部分：icode 和 ifun。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符 rA 和 rB。它还可能取出一个 8 字节常数字 valC。也就是说，valP 等于 PC 的值加上已取出指令的长度。 decode：从寄存器文件读入最多两个操作数，得到值 valA 和/或 valB。通常它读入指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器 %rsp 的。 execute：算术逻辑单元要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值称为 valE。在此，也可能设置条件码，对一条条件传送指令来说，这个阶段会检查条件码和传送条件（由 ifun 给出），如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。 memory：可以将数据写入内存，或者从内存读出数据。读出的值为 valM Write back：最多可以写两个结果到寄存器文件 PC update： 将 PC 设置成下一条指令的地址 处理器无限循环执行这些阶段。发生任何异常时，处理器就会停止：执行 halt 指令或非法指令，或它试图读或写非法地址。在更完整的个设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。 icode:ifun 表明指令字节的两个组成部分 rA:rB 表明寄存器指示符字节的两个组成部分 M1[x] 表示访问(读或写)内存位置 x 处的一个字节，而 M8[x] 表示访问八个字节 SEQ SEQ 是能执行 fetch, decode, execute, memory, write back, and PC update 这些计算的硬件结构的抽象表示 硬件结构 SEQ 的抽象视图，一种顺序实现 白色方框表示时钟寄存器。PC 是 SEQ 中唯一的时钟寄存器 浅蓝色方框表示硬件单元。不必关心它们的细节设计 线路名字在白色圆圈中说明 宽度为字长的数据连接用中等粗度的线表示。每条这样的线实际上都代表一簇 64 根线并列连在一起将数据传送到硬件的另一部分 宽度为字节或更窄的数据连接用细线表示。根据线上要携带的值的类型，实际上都代表一簇 4 根或 8 根线 单个位的连接用虚线表示。代表芯片上单元与块之间传递的控制值 时序 从不回读：Y86-64 指令集的原则，处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态 SEQ 的实现包括组合逻辑和两种存储设备： 组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播 时钟寄存器：程序计数器和条件码寄存器 随机访问存储器：寄存器文件、指令内存和数据内存 有四个单元需要对它们的时序进行明确的控制：程序计数器、条件码寄存器、数据内存和寄存器文件 它们都通过一个时钟信号来控制，它触发将新值装载到寄存器以及将值写到随机访问寄存器 每个时钟周期，程序计数器都会装载新的指令地址 只有执行整数运算指令时，才会写数据内存 寄存器文件的两个写端口允许每个时钟周期更新两个程序寄存器，不过我们可以用特殊的寄存器 ID 0xF 作为端口地址，来表明在此端口不应该执行写操作 例子 1234561 0x000: irmovq $0x100, %rbx # %rbx &lt;-- 0x1002 0x00a: irmovq $0x200,%rdx # %rdx &lt;-- 0x2003 0x014: addq %rdx, %rbx # %rbx &lt;-- 0x300 CC &lt;-- 0004 0x016: je dest # Not taken5 0x0lf: rmmovq %rbx,0(%rdx) # M[0x200] &lt;-- 0x3006 0x029: dest: halt SEQ阶段的实现 fetch 阶段 根据 icode 值可以计算三个一位的信号： instr_valid：这个字节对应于一个合法的 Y86-64 指令吗？这个信号用来发现不合法的指令 need_regids：这个指令包括一个寄存器指示符字节吗？ need_valC：这个指令包括一个常数字吗？ (当指令地址越界时会产生的)信号 instr_valid 和 imem_error 在访存阶段被用来产生状态码 12345bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ };bool need_valC = icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL }; Align 对剩下 9 个字节的处理： 当计算出来的信号 need_regids 为 1 时，字节 1 被分开装入寄存器指示符 rA 和 rB 中 否则，这两个字段会被设为 0xF (RNONE) 表明这条指令没有指明寄存器 因此，可以将信号 rA 和 rB 看成，要么放着我们想要访问的寄存器，要么表明不需要访问任何寄存器 根据 need_valC 的值，要么根据字节 1~8 来产生 valC ，要么根据字节 2~9 产生 PC 增加器硬件单元根据当前的 PC 以及以上两个信号的值产生 valP PC 值为 p、need_regids 值 r 以及 need_valC 值 i 增加器产生值 p + 1 + r + 8i Decode 和 Write-Back 阶段 1234567891011word srcA = [ icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ } : rA; icode in { IPOPQ, IRET } : RRSP; 1 : RNONE; # Don't need register];word srcB = [ icode in { IRMMOVQ, IOPQ, IMRMOVQ } : rB; icode in { IPOPQ, IPUSHQ, IRET, ICALL } : RRSP; 1 : RNONE; # Don't need register]; 12345678910111213# WARNING: Conditional move not implemented correctly here worddstE = [ icode in { IRRMOVQ } : rB; icode in { IIRMOVQ, IOPQ} : rB; icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don't write any register];dstM = [ icode in { IMRMOVQ, IPOPQ } : rA; 1 : RNONE; # Don't write any register]; Execute 阶段 12345678910111213word aluA = [ icode in { IRRMOVQ, IOPQ } : valA; icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : valC; icode in { ICALL, IPUSHQ } : -8; icode in { IRET, IPOPQ } : 8; # Other instructions don't need ALU];word aluB = [ icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ } : valB; icode in { IRRMOVQ, IIRMOVQ } : 0; # Other instructions don't need ALU]; 123456word alufun = [ icode == IOPQ : ifun; 1 : ALUADD;];bool set_cc = icode in { IOPQ }; Memory 阶段 12345678910111213word mem_addr = [ icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ } : valE; icode in { IPOPQ, IRET } : valA; # Other instructions don't need address];word mem_data = [ # Value from register icode in { IRMMOVQ, IPUSHQ } : valA; # Return PC icode == ICALL : valP; # Default: Don't write anything]; 12bool mem_write = icode in { IRMMOVQ, IPUSHQ, ICALL };bool mem_read = icode in { IMRMOVQ, IPOPQ, IRET }; 1234567## Determine instruction statusword Stat = [ imem_error | | dmem_error : SADR; !instr_valid: SINS; icode == IHALT : SHLT; 1 : SAOK;]; PC Update 阶段 12345678910word new_pc = [ # Call. Use instruction constant icode == ICALL : valC; # Taken branch. Use instruction constant icode == IJXX &amp;&amp; Cnd : valC; # Completion of RET instruction. Use value from stack icode == IRET : valM; # Default: Use incremented PC 1 : valP;];","link":"/Study/csapp/cp4/"},{"title":"cp5 优化程序性能","text":"优化编译器的能力和局限性 一种有用的策略是只重写程序，使其达到编译器可以生成高效代码的程度。 减少读取指针的次数来优化程序 如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这样会限制编译器的优化策略 内联函数替换 程序优化实例 12345/* Create abstract data type for vector */typedef struct { long len; data_t *data;} vec_rec, *vec_ptr; 向量的抽象数据类型 123456789101112131415161718192021222324252627282930313233343536373839/* Create vector of specified length */vec_ptr new_vec(long len){ /* Allocate header structure */ vec_ptr result = (vec_ptr) malloc(sizeof(vec_rec)); data_t *data = NULL; if (!result) return NULL; /* Couldn't allocate storage */ result-&gt;len = len; /* Allocate array */ if (len &gt; 0) { data = (data_t *)calloc(len, sizeof(data_t)); if (!data) { free((void *) result); return NULL; /* Couldn't allocate storage */ } } /* Data will either be NULL or allocated array */ result-&gt;data = data; return result;}/** Retrieve vector element and store at dest.* Return 0 (out of bounds) or 1 (successful)*/int get_vec_element(vec_ptr v, long index, data_t *dest){ if (index &lt; 0 | | index &gt;= v-&gt;len) return 0; *dest = v-&gt;data [index]; return 1 ;}/* Return length of vector */long vec_length(vec_ptr v){ return v-&gt;len;} 向量抽象数据类型的实现 123456789101112/* Implementation with maximum use of data abstraction */void combinel(vec_ptr v, data_t *dest){ long i; *dest = IDENT; for (i = 0; i &lt; vec_length(v); i++) { data_t val; get_vec_element(v, i, &amp;val); *dest = *dest OP val; }} 合并运算的初始实现 求和声明： 12#define IDENT 0#define OP + 乘积声明： 12#define IDENT 1#define OP * 消除循环的低效率 12345678910111213/* Move call to vec_length out of loop */void combine2(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); *dest = IDENT; for (i = 0; i &lt; length; i++) { data_t val; get_vec_element(v, i, &amp;val); *dest = *dest OP val; }} 多次调用 vec_length 方法来获取长度实现循环会降低效率 低效率极端例子 识别要执行多次，但是计算结果不会改变的计算，可以将计算移动到代码前面不会被多次求值的部分 1234567891011121314151617181920212223242526272829303132/* Convert string to lowercase: slow */void lower1(char *s){ long i; for (i = 0; i &lt; strlen(s); i++) if (s[i] &gt;= `A' &amp;&amp; s[i] &lt;= `Z') s[i] -= (`A' - `a');}/* Convert string to lowercase: faster */void lower2(char *s){ long i; long len = strlen(s); for (i = 0; i &lt; len; i++) if (s[i] &gt;= `A' &amp;&amp; s[i] &lt;= `Z') s[i] -= (`A' - `a');}/* Sample implementation of library function strlen *//* Compute length of string */size_t strlen(const char *s){ long length = 0; while (*s != `\\0') { s++; length++; } return length;} 减少过程调用 combine 2 的代码每次循环都会调用 get_vec_element 来获取下一个向量元素。 对每个向量引用，这个函数都要把向量索引 i 与循环边界作比较，这会造成低效率 1234data_t *get_vec_start(vec_ptr v){ return v-&gt;data;} 123456789101112/* Direct access to vector data */void combine3(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); data_t *data = get_vec_start(v); *dest = IDENT; for (i = 0; i &lt; length; i++) { *dest = *dest OP data[i]; }} 这并没有立刻得到明显的提升，显然还有其他瓶颈 消除不必要的内存引用 分析 combine3 循环代码生成的汇编代码： 123456789Inner loop of combine3. data_t = double, OP = *dest in %rbx, data+i in %rdx, data+length in %rax. L17: loop: vmovsd (%rbx), %xmm0 Read product from dest vmulsd (%rdx), %xmm0, %xmm0 Multiply product by data[i] vmovsd %xmm0, (%rbx) Store product at dest addq $8, %rdx Increment data+i cmpq %rax, %rdx Compare to data+length jne .L17 If !=, goto loop 它将代码改变为：在寄存器 %rdx 中维护一个指向第 i 个数据元素的指针，在注释中显示为 data+i。 该指针在每次迭代中增加8。通过将该指针与存储在寄存器 %rax 中的指针进行比较来检测循环终止。 每次迭代都会从内存中读取和写入累积的值。这种读写是浪费的，因为每次迭代开始时从 dest 读取的值应该只是前一次迭代结束时写入的值。 1234567Inner loop of combine4. data_t = double, OP = *acc in %xmm0, data+i in %rdx, data+length in %rax.L25: loop: vmulsd (%rdx), %xmm0, %xmm0 Multiply acc by data[i] addq $8, %rdx Increment data+i cmpq %rax, %rdx Compare to data+length jne .L25 If !=, goto loop 123456789101112131 /* Accumulate result in local variable */2 void combine4(vec_ptr v, data_t *dest)3 {4 long i;5 long length = vec_length(v);6 data_t *data = get_vec_start(v);7 data_t acc = IDENT;8 9 for (i = 0; i &lt; length; i++) {10 acc = acc OP data[i];11 }12 *dest = acc;13 } 我们引入了一个临时变量 acc，用于在循环中累积计算出的值，只有在循环完成后，结果才存储在 dest 中。 如上面的汇编代码所示，编译器现在可以使用寄存器%xmm0来保存累积值。 与 combine3中的循环相比，我们将每次迭代的内存操作从两次读一次写减少到只需要一次读。 循环展开 12345678910111213141516171819/* 2 x 1 loop unrolling */void combine5(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); long limit = length-1; data_t *data = get_vec_start(v); data_t acc = IDENT; 9 /* Combine 2 elements at a time */ for (i = 0; i &lt; limit; i+=2) { acc = (acc OP data[i]) OP data[i+1]; } /* Finish any remaining elements */ for (;i &lt; length; i++) { acc = acc OP data[i]; } *dest = acc;} 确保第一次循环不会超出数组的界限 12345678 Inner loop of combine5. data_t = double, OP = * i in %rdx, data %rax, limit in %rbx, acc in %xmm01 .L35: loop:2 vmulsd (%rax,%rdx,8), %xmm0, %xmm0 Multiply acc by data[i]3 vmulsd 8(%rax,%rdx,8), %xmm0, %xmm0 Multiply acc by data[i+1]4 addq $2, %rdx Increment i by 25 cmpq %rdx, %rbp Compare to limit:i6 jg .L35 If &gt;, goto loop 整数加法的一个周期的延迟称为限制性能的因素 提高并行性 12345678910111213141516171819202122/* 2 x 2 loop unrolling */void combine6(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); long limit = length-1; data_t *data = get_vec_start(v); data_t acc0 = IDENT; data_t acc1 = IDENT; /* Combine 2 elements at a time */ for (i = 0; i &lt; limit; i+=2) { acc0 = acc0 OP data[i]; acc1 = acc1 OP data[i+1]; } /* Finish any remaining elements */ for (;i &lt; length; i++) { acc0 = acc0 OP data[i]; } *dest = acc0 OP acc1;} 2 x 2 循环展开 打破了由延迟界限设下的限制。处理器不再需要延迟一个加法或乘法操作以待前一个操作完成 重新结合变换 12345678910111213141516171819/* 2 x 1a loop unrolling */void combine7(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); long limit = length-1; data_t *data = get_vec_start(v); data_t acc = IDENT; 9 /* Combine 2 elements at a time */ for (i = 0; i &lt; limit; i+=2) { acc = acc OP (data[i] OP data[i+1]); } /* Finish any remaining elements */ for (;i &lt; length; i++) { acc = acc OP data[i]; } *dest = acc;} 与 combine 5 不同的之处于第 11 行 性能提升很大，几乎与 combine6 相同 修改之后，每次迭代内的第一个乘法都不需要等待前一次迭代的累计值就可以执行 限制因素 寄存器溢出 循环并行的好处受到汇编代码描述计算的能力限制。 如果并行度超过可用寄存器的数量，编译器会诉诸溢出。 上图可以发现，循环展开并没有改善，有些甚至还变差了 分支预测 分支预测失败的惩罚是很严重的，所以我们需要控制编写程序的方法 1234567891011/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */void minmax1(long a[], long b[], long n) { long i; for (i = 0; i &lt; n; i++) { if (a[i] &gt; b[i]) { long t = a[i]; a[i] = b[i]; b[i] = t; } }} 命令式风格代码⬆ CPE 大约为 13.5，但对于可预测的数据，CPE 仅为 2.5~3.5，预测错误惩罚约为 20 个周期 12345678910/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */void minmax2(long a[], long b[], long n) { long i; for (i = 0; i &lt; n; i++) { long min = a[i] &lt; b[i] ? a[i] : b[i]; long max = a[i] &lt; b[i] ? b[i] : a[i]; a[i] = min; b[i] = max; }} 功能式风格代码⬆ 无论数据是可预测还是不可预测，CPE 都大约为 4.0 这样写可以引导产生条件传送代码，提高性能","link":"/Study/csapp/cp5/"},{"title":"cp6 存储器层次结构","text":"高速缓存存储器 直接映射高速缓存 组选择 行匹配 字抽取 综合 (举例) 假设我们有一个直接映射高速缓存，描述如下： （S，E，B，m） = （4,1,2,4） 高速缓存有四个组，每个组一行，每个块两个字节，地址是四位 标记位和索引位连起来唯一的标识了内存中的每个块。 例如：块 0 是由地址 0 和 1 组成的，块 1 是由地址 2 和 3 组成的，块 2 是由地址 4 和 5 组成的，以此类推。 由八个内存块，但只有四个高速缓存组，所以多个块会映射到同一个高速缓存组（即它们有相同的组索引） 例如：块 0 和 4 都映射到组 0，块 1 和 5 都映射到组 1 映射到同一个高速缓存组的块由标记位唯一地标识。 例如：块 0 的标记位为 0，而块 4 的标记位为 1，块 1 的标记位为 0，而块 5 的标记位为 1，以此类推 初始时的高速缓存 （空的）： 读地址 0 的字 组 0 的有效位是 0，缓存不命中 高速缓存从内存去除块 0，并把这个块存储在组 0 中（或从第一位的高速缓存取出） 高速缓存返回新取出的高速缓存行的块[0] 的 m[0]（内存位置 0 的内容） 读地址 1 的字 缓存命中，立即返回，高速缓存的状态没有变化 读地址 13 的字 组 2 中的高速缓存行不是有效的，缓存不命中 把块 6 加载到组 2 中 然后返回新的高速缓存行块[1] 的 m[13] 读地址 8 的字 缓存不命中 高速缓存将块 4 加载到组 0 中 返回新的高速缓存行块[0] 的 m[8] 读地址 0 的字 组 0 的有效位是 0，缓存再次不命中 w 我们拥有足够的高速缓存空间，但却交替的引用映射到同一个组的块 解决方法 上述的情况被称为 抖动 当程序范围大小为 2 的幂的数组时，直接映射高速缓存中通常会发生冲突不命中 例如： 123456789float dotprod(float x [8], float y [8]){ float sum = 0.0; int i; for (i = 0; i &lt; 8; i++) sum += x [i] * y [i]; return sum;} 它拥有良好的空间局部性，因此我们期望它的命中率会比较高，实际上，并非如此 假设浮点数是 4 个字节，x 被加载到从地址 0 开始的 32 字节连续内存中，y 紧跟在 x 之后，从地址 32 开始 假设一个块是 16 个字节，足够容纳四个浮点数，高速缓存由两个组构成，高速缓存的整个大小为 32 字节 假设变量 sum 实际上存放在一个 CPU 寄存器中，因此不需要内存引用 根据以上假设每个 x[i] 和 y[i] 会映射到相同的高速缓存组 运行时： 循环的第一次迭代引用 x[0]，缓存不命中会导致包含 x[0] ~ x[3] 的块被加载到组 0 下一次是对 y[0] 的引用，又一次缓存不命中会导致包含 y[0] ~ y[3] 的块被加载到组 0 这将会覆盖前一次引用复制进来的 x 的值 在下一次迭代中，对 x[1] 的引用不命中，导致包含 x[0] ~ x[3] 的块被加载到组 0 这将会覆盖前一次引用复制进来的 y 的值 以上情况也被称为抖动，即使有良好的空间局部性和高速缓存的足够空间，每次引用还是会导致冲突不命中，这是因为这些块被映射到了同一个高速缓存组。 修正： 在每个数组的结尾放 B 字节的填充 将 x 定义为 float x[12] 假设在内存中 y 紧跟在 x 后面，于是出现了以下映射 在 x 结尾加了填充，x[i] 和 y[i] 现在就映射到了不同的组，消除了抖动冲突不命中 编写高速缓存友好的代码 让最常见的情况运行的快 程序大部分运行时间都花在少量核心函数上，而这些函数把大部分时间花在少量循环上。所以要把注意力集中在核心函数的循环上，而忽略其他部分 尽量减少每个循环内部的缓存不命中数量 在其他条件都相同的情况下，不命中率较低的循环运行的更快，例如加载和存储的总次数 对局部变量的重复引用是好的，因为编译器能够将它们缓存在寄存器文件中（时间局部性） 步长为 1 的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据数据存储为连续的块（空间局部性） 在对多维数组进行操作的程序中，空间局部性尤为重要 高速缓存对程序性能的影响 存储器山 图 6-41 stride=8 时的一个片段（图 6-41 的山脊） 一个空间局部性的斜坡。图 6-41 大小=4mb 的片段 我们要利用时间局部性，使得频繁使用的字从 L1 中取出，还要利用空间局部性，使尽可能多的字从一个 L1高速缓存行中访问到。 在程序中利用局部性 将注意力集中在内循环上，大部分计算和内存访问都发生在这里 通过按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得你程序中的空间局部性最大 一旦从存储器中读入了一个数据对象，就尽可能多使用，从而是的程序中的时间局部性最大","link":"/Study/csapp/cp6/"},{"title":"cp7 链接","text":"123456789int sum(int *a, int n);int array[2] = {1, 2};int main(){ int val = sum(array, 2); return val;} main.c 123456789int sum(int *a, int n){ int i, s = 0; for (i = 0; i &lt; n; i++) { s += a[i]; } return s;} sum.c 编译器驱动程序 静态链接。链接器将可重定位目标文件组合起来，形成一个可执行目标文件 prog linux&gt; gcc -Og -o prog main.c sum.c 驱动程序首先运行 C 预处理器 (cpp)，它将 C 的源程序 mian.c 翻译成一个 ASCII 码的中间文件 main.i : cpp [other arguments] main.c /tmp/main.i 驱动程序运行 C 编译器 (cc 1)，它将 main.i 翻译成一个 ASCII 编译语言文件 main.s : cc1 /tmp/main.i -0g [other arguments] -o /tmp/main.s 驱动程序运行汇编器 (as)，它将 main.s 翻译成一个可重定位目标文件 main.o : as [other arguments] -o /tmp/main.o /tmp/main.s 驱动程序结果相同的过程生成 sum.o ，最后，它运行链接器程序 ld，将 main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件 prog : ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o 最后，执行：linux&gt; ./prog，shell 调用操作系统中一个叫做加载器 (loader) 的函数，它将可执行文件 prog 中的代码和数据复制到内存，然后控制转移到这个程序的开头","link":"/Study/csapp/cp7/"},{"title":"Hash Table","text":"哈希表 哈希表 是一种使用 哈希函数 组织数据，以支持快速插入和搜索的数据结构。 哈希表通过哈希函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。 有两种不同类型的哈希表：哈希集合 和 哈希映射： 哈希集合 是集合数据结构的实现之一，用于存储非重复值。 哈希映射 是映射 数据结构的实现之一，用于存储 (key, value) 键值对。 散列函数( hash(key) ) 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中； 当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。 散列函数设计的基本要求： 散列函数计算得到的散列值是一个非负整数； 如果 key1 = key2，那 hash (key1) == hash (key2)； 如果 key1 ≠ key2，那 hash (key1) ≠ hash (key2)。 散列冲突 无法避免，常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。 装载因子 为了尽可能保证哈希表的操作效率，一般情况下，我们会尽可能保证哈希表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。 哈希表的装载因子 = 填入表中的元素个数 / 哈希表的长度 装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。 扩容 当装载因子过大时，就需要对哈希表扩容。 新申请一个更大的哈希表，将数据搬移到这个新哈希表中。 针对数组的扩容，数据搬移操作比较简单。 针对哈希表的扩容，数据搬移操作要复杂很多。 哈希表的大小变了，数据的存储位置也变了。 需要通过散列函数重新计算每个数据的存储位置。 装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。 开放寻址法 如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。 当数据量比较小、装载因子小的时候，适合采用开放寻址法。 这也是Java中的 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。 线性探测（Linear Probing）： 当我们往哈希表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。 删除问题 对于使用线性探测法解决冲突的哈希表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？ 我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。 链表法（chaining） 在哈希表中，每个 “桶（bucket）” 或者 “槽（slot）” 会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的哈希表。 比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。 对比 开放寻址法适用于数据量比较小、装载因子小的场景。 链表法适用于存储大对象、大数据量的哈希表。 sort from 腾讯开发者社区","link":"/Study/dataStruct/Hash-Table/"},{"title":"coffee magic","text":"磨豆机 刀片形状 颗粒形状，平刀片状，萃取率更高，溶解的一致性更好。 鬼齿锥刀块状，萃取率相对低。 需要根据形状调整参数 粒径分布 分布越集中一致性更好，分布宽泛一点会有差异性味道。 哪个更好取决于个人，没有绝对好坏 细粉 增加层次感丰富性 堵滤纸底增加萃取率 到底细粉好不好需要根据豆子等具体判断 刀片直径 刀片直径，影响研磨速度，越大越快。 发热家用可以基本忽略，商用发热越少越好 焖蒸 不存在绝对普适的优化方法。 方法只能带来不同；至于优劣，还与豆子有关系。 作用及其原理 作用 提高萃取率。 原理 排气，便于后续水流接触咖啡粉； 加热风味物质，使之更容易随水流被萃取出来。 如果不焖蒸 风味物质一开始不活跃，前期萃取率偏低。 前期水流不能充分浸润咖啡粉，前期萃取率偏低。 MaxTips：焖蒸总结来看就是提高萃取率。要不要提高萃取率，可以自由选择。 玄学 延长焖蒸时间能加强甜感 对浅烘豆 成立，因为焖蒸提高萃取率，浅烘豆中被多萃取的物质就是甜味物质。 对深烘豆 会加强苦味，同理。 合理地选择焖蒸时间 焖蒸后期会降温。 降温使加强萃取的效应渐渐不明显，所以存在一个最合理的时间（不是时间越长效果越明显）。 延长几十秒是有可能的，需要实验。 粉包破裂 粉包破裂只能说明，后续排气量不足以支撑整个表面，只是说明需要加速注水。不代表有负面影响。 from Maxpresso 摩卡壶 刚开始使用时，建议从一比十的粉水比作为起点进行磨合 尽量防止整个壶温度过高，导致过热的蒸汽经过咖啡，带来更多的苦味 加热锅，直到液体开始流过咖啡，出液，然后尝试保持压力 咖啡液流出时，关火或者将锅移至边缘，利用余温保持压力 咖啡液加速流出时，将锅提起，远离热源一定高度，或者直接离火 出液量理想值为达到三分之二 布粉针，防止粉结块 为了干净的杯子可以考虑添加滤纸 (会加大一定压力)，记得用水浸湿 (固定) 最后喷射的尾段可能会过苦，可以截断 粉越细，阻力越大，水温越高，咖啡越热，萃取的越多。 烘焙程度相对较轻 目的是提取更多，苦味物质和甜味物质会较晚溶解 需要较细的研磨度，水会更晚冲泡，整体冲泡温度更高 会产生更多的酸，可以通过水槽加热水中和，建议水量更多 如果希望使用热水，建议水槽加入九十度左右的热水冲煮，不建议使用刚沸腾的水 在咖啡开始溅射之前让尽可能多的水通过咖啡 烘焙程度相对较深 提取过多容易带出更多苦味物质 需要较粗的研磨度，水会更早冲泡，整体冲泡温度更低 苦味物质会更早溶解，可以通过水槽加冷水中和，建议水量更少 更早的停止冲泡，防止过萃 美式 加入的水量 = 两倍液重 特调 椰乳200+两份浓缩=生椰拿铁 西瓜100g碾碎+厚乳50ml搅拌+两份浓缩=抓马西瓜拿铁 冰博客100g+抹茶6g+巧克力30g+冰块320g 打碎成沙冰=抹茶星冰乐 黄柠檬：南非柠檬/新奇士柠檬 抹茶：青岚，五十铃或者直接二合一 椰乳：越王头/菲诺 厚乳：塞尚(冰滴厚奶)/索非蜜斯/必如冰博客 厚乳=牛奶X3","link":"/Study/live/coffee-magic/"},{"title":"How to live longer","text":"术语 ACM: All-Cause Mortality / 全因死亡率 行动 输入 固体 尽量吃白肉（-11%~-3% ACM） 蔬果为主（-26%~-17% ACM） 多吃辣（-23% ACM） 多吃坚果（-27%~-4% ACM） 少吃蛋黄（否则+7% ACM/0.5颗/天）（存在争议） 中量碳水、多吃植物蛋白（-10% ACM） 少吃超加工食物（-62%~-18%） 黄酮类物质 黄酮类物质一种多酚类化合物，是植物的次级代谢产物，根据化学结构可分为六大亚类:黄酮醇、黄烷酮、黄酮、黄烷醇、花青素和异黄酮，在植物性食品和饮料如水果、蔬菜、黑巧克力、茶和红酒中大量存在。 这类化合物具有多种生物活性，如免疫激活、抗氧化、抑制特异性关键酶、调节神经递质释放等作用。(可能) 吃含黄酮类食物与死亡风险降低20%相关 胖子好像不能多吃 Bondonno博士说道“吃不同蔬菜、水果补充，不同种类的黄酮类化合物是很重要的，这很容易通过饮食实现：一杯茶、一个苹果、一个橘子、100克蓝莓，或100克西兰花，就能提供各种黄酮类化合物，并且总含量超过500毫克。 出处：Flavonoid intake is associated with lower mortality in the Danish Diet Cancer and Health Cohort 辣椒 2017年Plos One的另一项来自美国的研究以16179名，年龄在18岁以上的人群为对象，并对其进行了高达19年的随访，发现在4946例死亡患者中，食用辣椒的参与者的全因死亡率为21.6％，而未食用辣椒的参与者的全因死亡率为33.6％。相较于不吃辣或很少吃（少于每周两次）的人群，每周吃辣＞4次的人群总死亡风险降低23%，心血管死亡风险降低34%。 出处1：Chili pepper consumption and mortality in Italian adults 出处2：The Association of Hot Red Chili Pepper Consumption and Mortality: A Large Population-Based Cohort Study 热量限制 限制卡路里动物实验：CR（热量限制，即少吃）延迟了恒河猴的多种疾病发病和死亡率，与CR动物相比，正常喂养的猴子的各种疾病患病风险增加2.9倍，死亡风险增加3.0倍。 液体 喝咖啡（-22%~-12% ACM） 喝牛奶（-17%~-10% ACM） 喝茶（-15%~-8% ACM） 少喝或不喝甜味饮料（否则每天一杯+7% ACM，+多巴胺） 百分百纯果汁比含糖饮料更危险 戒酒或每周100g（纯酒精量(g)=饮酒量(ml)×酒精浓度(%)×酒精密度0.8g/ml）内（否则+~50% ACM，无上限） 乳制品 与完全不摄入乳制品的人相比，每日超过两份乳制品的人群，整体死亡风险下降16%，心血管死亡风险下降23%，中风风险下降33%，但是心梗的发作风险没有明显差异。 对只摄入全脂乳制品的人来说，两份以上的群体，比起半份以下的人群，主要风险降低了29%，如果全脂和脱脂产品都摄入，这一数字反而会降到16%，所以不需要脱脂。 出处：Association of dairy intake with cardiovascular disease and mortality in 21 countries from five continents (PURE): a prospective cohort study 茶 纳入分析的438 443例研究对象随访11.1年共发生死亡34 661例。与从不饮茶者相比，当前非每日饮茶者和每日饮茶者全因死亡HR值（95%CI）依次为0.89（0.86-0.91）和0.92（0.88-0.95）。分性别分析显示，饮茶对全因死亡风险的保护作用主要见于男性（交互P&lt;0.05） 饮茶者的全因死亡和部分死因别死亡的风险降低；但饮茶与恶性肿瘤的死亡风险不存在关联，反而在同时伴有吸烟或过量饮酒习惯者中表现出增加的死亡风险。 出处：Tea consumption and the risk of atherosclerotic cardiovascular disease and all-cause mortality: The China-PAR project 咖啡 在最近的荟萃分析中，该研究包括来自不同国家的40项研究和3,852,651名受试者。在这项荟萃分析显示，咖啡摄入量与各种原因的死亡率，CVD和癌症死亡率之间存在非线性关系，每天摄入两杯咖啡的癌症死亡率最低(RR = 0.96)，CVD最低的死亡率，每天2.5杯(RR= 0.83)，全天最低死亡率为每天3.5杯(RR= 0.85)，并且随着咖啡消费量的增加，死亡率没有进一步降低或增加 气体 不吸烟（否则+~50% ACM，-12~-11年寿命） 光照 晒太阳（-~40% ACM） 紫外线根据波长不同，被分为UVA、UVB和UVC，大多数UVA可以轻松穿过臭氧层，到达地面，相比较而言，大部分的UVB在到达地面之前，会被臭氧层削弱，而UVC基本不用担心，会被臭氧层隔离。 从总体上来看，患有皮肤恶性黑色毒瘤，并没有非常大的影响一个人的寿命。 平均来说，非黑色毒瘤型皮肤癌患者，比没有任何皮肤癌的患者，寿命还更长。间接表明阳光照射可能对健康产生有益影响。 UVB和晒伤or皮肤癌关联较大，但却刺激身体合成维生素D，每天从食物中获取的维生素D，一般只占5%-10%，对维生素D影响最大的是阳光。 UVA增加黑色素沉积or皱纹，但却可能让你长寿。它也能促进皮肤释放一氧化氮，从而带给你丰富的健康益处。 出处An Unexpected Role: UVA-Induced Release of Nitric Oxide from Skin May Have Unexpected Health Benefits 如何安全的晒太阳 一天当中上午6:00到10:00之间，下午14:00-18:00之间，UVA的量比UVB要多，更安全有益的阳光暴露，应该在紫外线指数较低，并且UVA比UVB较高的情况下。 当你的影子是你身高的2倍，甚至更多的时候，紫外线指数最安全，可以不需要任何防护，好好晒一晒。 当你的影子处于身高和身高的2倍之间长度时，安全晒太阳的时长可以控制在20分钟左右。 而当影子开始短于身高的时候，紫外线可能在短短30分钟内就对你的皮肤造成伤害，再进一步，当影子长度不到你身高一半的时候，紫外线就可能在短短15分钟内，伤及你的皮肤。 一氧化氮 通过在大脑中的神经细胞之间传递信息，来帮助记忆和行为 协助免疫系统抵抗细菌和防御肿瘤 通过扩张动脉调节血压 减少炎症 增加胰岛素敏感性 改善睡眠质量 增加你对感觉的认识（即气味） 增加耐力和力量 协助胃动力 一氧化氮有增加整体寿命的巨大作用。 出处：Nitric oxide: A little molecule’s remarkable feat – prolonging life, worm study shows 药物 二甲双胍（糖尿病人相比正常人可以+3年）、复合维生素（-8%癌症风险）、亚精胺（-60%~-30% ACM）、葡萄糖胺（-39% ACM） 亚精胺 食物 每克含量（毫克） 小麦胚芽 29.8 豆类（大豆、绿豆等） 2.2-13.8 菇类（香菇、金针菇等） 1.1-9.2 肉类（鸡肉、鸭肉等） 1.1-3.0 鱼类（鲑鱼、鲤鱼等） 1.2-2.5 大蒜 1.5 芝麻 0.8 蛋类（鸡蛋、鸭蛋等） 0.5-0.6 亚精胺的主要来源是全谷物（占13.4%）、苹果和梨（占13.3%）、沙拉（占9.8%）、芽菜（占7.3%）和马铃薯（占6.4%）。 亚精胺是最容易从人体肠道吸收的多胺。许多的食物中都含有大量的亚精胺，例如新鲜的青椒、小麦胚芽、花椰菜、西兰花、蘑菇和各种奶酪，尤其在纳豆等大豆制品、香菇和榴莲中含量更高。 需要注意的是，不同的食物中Spermidine的含量可能会因多种因素（如产地、品种、处理方式等）而有所差异。此外，尽管Spermidine有益于健康，但过量摄入可能会带来不良影响，因此建议在饮食中适量摄入。 出处：Science：科学背书！从精液中发现的亚精胺，竟然有着抗衰老、抗癌、保护心血管和神经、改善肥胖和2型糖尿病等逆天神效 葡萄糖胺 美国西弗吉尼亚大学最新研究发现 氨糖（软骨素） 可以降低心血管死亡率65%，降低总体死亡率39%，效果与坚持定期运动相对 该研究使用1999年至2010年，16,686名成年人的国家健康和营养检查(NHANES)数据，参与者的中位追踪时间为107个月，而其中有648位参与者定期且每服用日500-1000毫克的葡萄糖胺/软骨素一年以上。 综合临床研究报道，每日氨糖的摄入量要适中，过少不起作用，过多对人体有害，最佳补充量为每日800-1500mg的氨糖。 大多数研究结果提示持续应用氨糖8周以上才能显示一定的疗效，使用1年以上疗效更为稳定。 对于体重不超重或偏瘦的人在初期服用1500mg氨糖1-2个月，以后的维持剂量减到三分之二，即1000mg氨糖维持服用。 对于体重偏重的人则持续应用1500mg氨糖。 出处：氨糖降低心血管死亡率65%，与定期运动效果相当 输出 运动：每周3次45分钟挥拍运动（-47% ACM） 日常：刷牙（-25% ACM） 睡眠：每天睡7小时全因死亡率最低；且22-24点间最好，早睡+43% ACM，晚睡+15% ACM（存在争议） 运动 一周三次，每次45-60分钟，挥拍运动，降低~47%全因死亡率 羽毛球、乒乓球、网球等都算挥拍运动，但由于西化研究背景，可能指网球更多。这隐式的表达了全身锻炼更为重要 网球、羽毛球对打，有氧体操，每次45-60分钟，一周3-5天，收益最高。 出处：哪种运动性价比最高？权威医学杂志“柳叶刀”给出答案了 睡眠 在男性中，与睡眠时长为7小时相比：睡眠持续时间≥10小时与全因死亡风险增加34%相关； 在女性中，与睡眠持续时间7小时相比：睡眠持续时间≥10小时与全因死亡风险增加48%相关； 上下文 体重：减肥（-54% ACM） sort from Github","link":"/Study/live/live-longer/"},{"title":"40 search","text":"丰富的经历是否等于更大的大脑？ 通过对实验室老鼠的研究，根据是否拥有更加优渥、丰富的生活环境，大脑中的神经突触的大小拥有百分之五十的差距 时常充满好奇的使用大脑(刺激)可以有效防止老化，失明的人视觉皮层发育不良，营养不良会限制大脑发育 “莫扎特效应” 人的本性是&quot;天生的&quot;吗？ 家庭环境对孩子的影响与孩子所继承的基因相比，作用微乎其微 智商70%归于先天 人的遗传倾向塑造着周围环境 如果孩子从父母的基因继承了更丰富的情感，那么与其他孩子相比，使其更能够对父母的爱作出更主动的反应，也就是对父母的正向激励 人们在外倾-内倾、神经质和自觉性等特性上的变异可以更多地(65%)以遗传差异而非环境因素来解释。 外倾-内倾：开朗大方或腼腆内向 神经质：承受高度焦虑或具有偏激的感情反应的倾向 自觉性：个人的干练、负责任和考虑问题的全面程度","link":"/Study/psychology/40-search/"},{"title":"build hexo","text":"环境配置 安装nodejs 安装hexo以及初始化博客 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server hexo的使用 目录结构 12345678910tree -L 1.├── _config.landscape.yml├── _config.yml├── node_modules├── package-lock.json├── package.json├── scaffolds├── source└── themes _config.yml 为全局配置文件，网站的很多信息都在这里配置，比如说网站名称，副标题，描述，作者，语言，主题等等。具体可以参考官方文档：https://hexo.io/zh-cn/docs/configuration.html。 scaffolds 骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当hexo生成新博客的时候，会用这里面的模版进行初始化。 source 这个文件夹下面存放的是网站的markdown源文件，里面有一个_post文件夹，所有的.md博客文件都会存放在这个文件夹下。现在，你应该能看到里面有一个hello-world.md文件。 themes 网站主题目录，hexo有非常丰富的主题支持，主题目录会存放在这个目录下面。 更多的主题参见：hexo主题 生成文章 123hexo new post &quot;test&quot; # 会在 source/_posts/ 目录下生成文件 ‘test.md’，打开编辑hexo generate # 生成静态HTML文件到 /public 文件夹中hexo server # 本地运行server服务预览，打开 http://localhost:4000 即可预览你的博客 hexo更多命令 建站脚本 为了后续netlify建站方便，我们可以在博客根目录的package.json里面添加一个命令： 1234567891011{ // ...... &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot;, &quot;netlify&quot;: &quot;npm run clean &amp;&amp; npm run build&quot; // 这一行为新加 }, // ......} _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Sitetitle: Hexo # 网站标题subtitle: # 网站副标题description: # 网站描述author: John Doe # 作者language: # 语言timezone: # 网站时区, Hexo默认使用您电脑的时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child'## and root as '/child/'url: http://yoursite.com # 你的站点Urlroot: / # 站点的根目录permalink: :year/:month/:day/:title/ # 文章的 永久链接 格式 permalink_defaults: # 永久链接中各部分的默认值# Directory source_dir: source # 资源文件夹，这个文件夹用来存放内容public_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹 archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 国际化（i18n）文件夹skip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post # 预设布局titlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false # 是否显示草稿post_asset_folder: false # 是否启动 Asset 文件夹relative_link: false # 把链接改为与根目录的相对位址 future: true # 显示未来的文章highlight: # 内容中代码块的设置 enable: true # 开启代码块高亮 line_number: true # 显示行数 auto_detect: false # 如果未指定语言，则启用自动检测 tab_replace: # 用 n 个空格替换 tabs；如果值为空，则不会替换 tabs# Category &amp; Tagdefault_category: uncategorizedcategory_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式 # Pagination## Set per_page to 0 to disable paginationper_page: 10 # 分页数量pagination_dir: page # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 主题名称# Deployment## Docs: https://hexo.io/docs/deployment.html# 部署部分的设置deploy: type: '' # 类型，常用的git 将文件夹上传至github托管 部署至Netlify 进行无脑授权以及选择刚刚的项目仓库 一切默认，除了构建命令(build command)改成我们之前设置的npm run netlify sort from https://blog.cuijiacai.com/blog-building/","link":"/Tutorial/hexo/build-hexo/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment Already change markdown to markdown-it Learn from Lamirs ☆ Blog Use toc: true to turn on category tags notes: about books toolkit: about program language’s tool class","link":"/Tutorial/hexo/hello-world/"},{"title":"VSCode memo","text":"使用vscode快捷键解决hexo的updated时间插入问题 新建快捷方法 ctrl + shift + p，输入snippets 找到configura user snippets new global或工作区都可以 输入名字 在花括号内输入 1234&quot;insertDate&quot;:{ &quot;prefix&quot;:&quot;insert date&quot;, &quot;body&quot;:&quot;$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;} 使用 点击需要插入的地方 ctrl + shift + p，找到insert snippet 选择insert date","link":"/Tutorial/hexo/vscode/"},{"title":"weread插件","text":"笔记模板 123456789101112131415161718192021222324252627282930313233343536373839---isbn: {{metaData.isbn}}category: {{metaData.category}}---# 元数据&gt; [!abstract] {{metaData.title}}&gt; - ![ {{metaData.title}}|200]({{metaData.cover}})&gt; - 书名： {{metaData.title}}&gt; - 作者： {{metaData.author}}&gt; - 简介： {{metaData.intro}}&gt; - 出版时间 {{metaData.publishTime}}&gt; - ISBN： {{metaData.isbn}}&gt; - 分类： {{metaData.category}}&gt; - 出版社： {{metaData.publisher}}# 高亮划线{% for chapter in chapterHighlights %}## {{chapter.chapterTitle}}{% for highlight in chapter.highlights %}{% if highlight.reviewContent %}{% else %}- 📌 {{ highlight.markText |trim }} ^{{highlight.chapterUid}}-{{highlight.range}} - ⏱ {{highlight.createTime}}{% endif %} {% endfor %}{% endfor %}# 读书笔记{% for chapter in bookReview.chapterReviews %}{% if chapter.reviews or chapter.chapterReview %}## {{chapter.chapterTitle}}{% if chapter.chapterReviews %}{% for chapterReview in chapter.chapterReviews %}### 章节评论 No.{{loop.index}}- {{chapterReview.content}} ^{{chapterReview.reviewId}} - ⏱ {{chapterReview.createTime}} {% endfor%}{%endif %}{% if chapter.reviews %}{%for review in chapter.reviews %}### 划线评论- 📌 {{review.abstract |trim }} ^{{review.reviewId}} - 💭 {{review.content}} - ⏱ {{review.createTime}}{% endfor %} {%endif %} {% endif %} {% endfor %}# 本书评论{% if bookReview.bookReviews %}{% for bookReview in bookReview.bookReviews %}## 书评 No.{{loop.index}} {{bookReview.mdContent}} ^{{bookReview.reviewId}}⏱ {{bookReview.createTime}}{% endfor%}{% endif %} 自用模板 添加了 reverse 过滤器，使得评论按照文章位置排序（划线评论上方最后一个|reverse）。 123456789101112131415161718192021222324252627---title: {{metaData.title}}date: updated: {{metaData.lastReadDate}}categories: - Studytags: - bookNotetoc: true---# 元数据&gt; [!abstract] {{metaData.title}}&gt; - ![ {{metaData.title}}|200]({{metaData.cover}})&gt; - 书名： {{metaData.title}}&gt; - 作者： {{metaData.author}}# 读书笔记{% for chapter in bookReview.chapterReviews %}{% if chapter.reviews or chapter.chapterReview %}## {{chapter.chapterTitle}}{% if chapter.chapterReviews %}{% for chapterReview in chapter.chapterReviews %}### 章节评论 No.{{loop.index}}- {{chapterReview.content}} ^{{chapterReview.reviewId}} - ⏱ {{chapterReview.createTime}} {% endfor%}{%endif %}{% if chapter.reviews %}{%for review in chapter.reviews|reverse %}### 划线评论- 📌 {{review.abstract |trim }} - 💭 {{review.content}}{% endfor %} {%endif %} {% endif %} {% endfor %}","link":"/Tutorial/obsidian/weread/"},{"title":"GeeRPC 框架","text":"Server 使用 encoding/gob 实现消息的编解码(序列化与反序列化) 一个典型的 RPC 调用如下： 1err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply) 客户端发送的请求包括服务名 Arith，方法名 Multiply，参数 args 三个，服务端的响应包括错误 error，返回值 reply 2 个。 消息发送 客户端固定采用 JSON 编码 Option，后续的 header 和 body 的编码方式由 Option 中的 CodeType 指定，服务端首先使用 JSON 解码 Option，然后通过 Option 的 CodeType 解码剩余的内容。即报文将以这样的形式发送： 12| Option{MagicNumber: xxx, CodecType: xxx} | Header{ServiceMethod ...} | Body interface{} | | &lt;------ 固定 JSON 编码 ------&gt; | &lt;------- 编码方式由 CodeType 决定 -------&gt;| 在一次连接中，Option 固定在报文的最开始，Header 和 Body 可以有多个，即报文可能是这样的。 1| Option | Header1 | Body1 | Header2 | Body2 | ... 服务注册 对 net/rpc 而言，一个函数需要能够被远程调用，需要满足如下五个条件： the method’s type is exported. – 方法所属类型是导出的。 the method is exported. – 方式是导出的。 the method has two arguments, both exported (or builtin) types. – 两个入参，均为导出或内置类型。 the method’s second argument is a pointer. – 第二个入参必须是一个指针。 the method has return type error. – 返回值为 error 类型。 1func (t *T) MethodName(argType T1, replyType *T2) error 为了解决服务端每暴露一个方法就要编写新的代码，服务端使用反射来将这个映射过程自动化。 例如： 123456789101112131415161718192021func main() { var wg sync.WaitGroup typ := reflect.TypeOf(&amp;wg) for i := 0; i &lt; typ.NumMethod(); i++ { method := typ.Method(i) argv := make([]string, 0, method.Type.NumIn()) returns := make([]string, 0, method.Type.NumOut()) // j 从 1 开始，第 0 个入参是 wg 自己。 for j := 1; j &lt; method.Type.NumIn(); j++ { argv = append(argv, method.Type.In(j).Name()) } for j := 0; j &lt; method.Type.NumOut(); j++ { returns = append(returns, method.Type.Out(j).Name()) } log.Printf(&quot;func (w *%s) %s(%s) %s&quot;, typ.Elem().Name(), method.Name, strings.Join(argv, &quot;,&quot;), strings.Join(returns, &quot;,&quot;)) } } Client 对 net/rpc 而言，一个函数需要能够被远程调用，需要满足如下五个条件： the method’s type is exported. the method is exported. the method has two arguments, both exported (or builtin) types. the method’s second argument is a pointer. the method has return type error. 1func (t *T) MethodName(argType T1, replyType *T2) error 超时处理 纵观整个远程调用的过程，需要客户端处理超时的地方有： 与服务端建立连接，导致的超时 发送请求到服务端，写报文导致的超时 等待服务端处理时，等待处理导致的超时（比如服务端已挂死，迟迟不响应） 从服务端接收响应时，读报文导致的超时 需要服务端处理超时的地方有： 读取客户端请求报文时，读报文导致的超时 发送响应报文时，写报文导致的超时 调用映射服务的方法时，处理报文导致的超时 GeeRPC 在 3 个地方添加了超时处理机制。分别是： 客户端创建连接时 客户端 Client.Call() 整个过程导致的超时（包含发送报文，等待处理，接收报文所有阶段） 服务端处理报文，即 Server.handleRequest 超时。 HTTP 支持 HTTP 协议的 CONNECT 方法提供了 RPC 和 HTTP 协议转换的能力，CONNECT 一般用于代理服务。 我们先参考通过代理服务器将 HTTP 协议转换为 HTTPS 协议的过程： 浏览器通过 HTTP 明文形式向代理服务器发送一个 CONNECT 请求告诉代理服务器目标地址和端口 代理服务器接收到这个请求后，会在对应端口与目标站点建立一个 TCP 连接，连接建立成功后返回 HTTP 200 状态码告诉浏览器与该站点的加密通道已经完成 接下来代理服务器仅需透传浏览器和服务器之间的加密数据包即可，代理服务器无需解析 HTTPS 报文 例子： 1234567# 1. 浏览器向代理服务器发送 CONNECT 请求。CONNECT geektutu.com:443 HTTP/1.0# 2. 代理服务器返回 HTTP 200 状态码表示连接已经建立。HTTP/1.0 200 Connection Established# 3. 之后浏览器和服务器开始 HTTPS 握手并交换加密数据，代理服务器只负责传输彼此的数据包，并不能读取具体数据内容（代理服务器也可以选择安装可信根证书解密 HTTPS 报文）。 结论： 对 RPC 服务端来，需要做的是将 HTTP 协议转换为 RPC 协议 对客户端来说，需要新增通过 HTTP CONNECT 请求创建连接的逻辑 好处： RPC 服务仅仅使用了监听端口的 /_geerpc 路径，在其他路径上我们可以提供诸如日志、统计等更为丰富的功能。 服务端 服务端通信过程应该是这样的： 1234567# 1. 客户端向 RPC 服务器发送 CONNECT 请求CONNECT 10.0.0.1:9999/_geerpc_ HTTP/1.0# 2. RPC 服务器返回 HTTP 200 状态码表示连接建立。HTTP/1.0 200 Connected to Gee RPC# 3. 客户端使用创建好的连接发送 RPC 报文，先发送 Option，再发送 N 个请求报文，服务端处理 RPC 请求并响应。 http.Handle 源码 123456789package http // Handle registers the handler for the given pattern // in the DefaultServeMux. // The documentation for ServeMux explains how patterns are matched. func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }type Handler interface { ServeHTTP(w ResponseWriter, r *Request) } 只需要实现接口 Handler 即可作为一个 HTTP Handler 处理 HTTP 请求。接口 Handler 只定义了一个方法 ServeHTTP，实现该方法即可。 负载均衡 随机选择策略 - 从服务列表中随机选择一个。 轮询算法(Round Robin) - 依次调度不同的服务器，每次调度执行 i = (i + 1) mode n。 加权轮询(Weight Round Robin) - 在轮询算法的基础上，为每个服务实例设置一个权重，高性能的机器赋予更高的权重，也可以根据服务实例的当前的负载情况做动态的调整，例如考虑最近5分钟部署服务器的 CPU、内存消耗情况。 哈希/一致性哈希策略 - 依据请求的某些特征，计算一个 hash 值，根据 hash 值将请求发送到对应的机器。一致性 hash 还可以解决服务实例动态添加情况下，调度抖动的问题。一致性哈希的一个典型应用场景是分布式缓存服务。 简单起见，GeeRPC 仅实现 Random 和 RoundRobin 两种策略。 注册中心 客户端和服务端都只需要感知注册中心的存在，而不需要感知对方的存在。 服务端启动后，向注册中心发送注册消息，注册中心得知该服务已经启动，处于可用状态。一般来说，服务端还需要定期向注册中心发送心跳，证明自己还活着。 客户端向注册中心询问，当前哪天服务是可用的，注册中心将可用的服务列表返回客户端。 客户端根据注册中心得到的服务列表，选择其中一个发起调用。 比较常用的注册中心有 etcd、zookeeper、consul，一般比较出名的微服务或者 RPC 框架，这些主流的注册中心都是支持的。","link":"/BackEnd/go/project/GeeRPC/"},{"title":"lab1 Unix 实用工具","text":"sleep 12345678910111213#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char **argv) { if(argc != 2){ fprintf(2, &quot;Usage: sleep number\\n&quot;); exit(1); } sleep(atoi(argv[1])); exit(0);} pingpong pipe函数介绍 123456789101112131415161718192021222324252627282930313233#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]) { int pp2c[2], pc2p[2]; pipe(pp2c); pipe(pc2p); // parent send in pp2c[1] // child send in pc2p[1] int pid = fork(); if (pid != 0) { // parent close(pp2c[0]); close(pc2p[1]); write(pp2c[1], &quot;o&quot;, 1); // 首先发出 char buf; read(pc2p[0], &amp;buf, 1); // 等待回复 printf(&quot;%d: received pong\\n&quot;, getpid()); wait(0); } else { // child char buf; close(pp2c[1]); close(pc2p[0]); read(pp2c[0], &amp;buf, 1); // 收到数据 printf(&quot;%d: received ping\\n&quot;, getpid()); write(pc2p[1], &amp;buf, 1); // 送回数据 exit(0); } exit(0);} prime 输出 2~35 之间的素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;void sieve(int pleft[2]) { int p; int bytesRead = read(pleft[0], &amp;p, sizeof(p)); // 读出来的第一个数一定是素数 if (bytesRead == 0) { // 读不出东西时，read函数返回0，代表读取完毕，退出程序 exit(0); } printf(&quot;prime %d\\n&quot;, p); // 创建下一个 subprocess 用的管道 int pright[2]; pipe(pright); if (fork() == 0) { // next subprocess close(pright[1]); // 只需要读取，不需要输入 close(pleft[0]); // 父进程管道使用完毕，关掉 sieve(pright); exit(0); } else { // current subprocess close(pright[0]); // 只需要输入，不需要读取 int buf; while (1) { bytesRead = read(pleft[0], &amp;buf, sizeof(buf)); if (bytesRead == 0) { // 读到0时，代表管道清空，退出循环 break; } if (buf % p != 0) { // 筛掉非素数 write(pright[1], &amp;buf, sizeof(buf)); } } close(pleft[0]); // 关闭管道 close(pright[1]); // 关闭管道 wait(0); exit(0); }}int main(int argc, char *argv[]) { // main int p[2]; pipe(p); if (fork() == 0) { // subprocess // 第一个子进程 close(p[1]); // 不需要插入，关闭插入管道 sieve(p); exit(0); } else { // main close(p[0]); // 主进程只需要输入，不需要读取 int i; for (i = 2; i &lt;= 35; i++) { write(p[1], &amp;i, sizeof(i)); } i = 0; // 用0作为结束标识 write(p[1], &amp;i, sizeof(i)); close(p[1]); // 关闭管道 } wait(0); exit(0);} find de.inum==0 表示这是一块已经初始化并且可以用来创建文件或者文件夹的位置，所以在读取的过程中应当无视这一块空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;intfind(char *path, char *fName){ char buf[512], *p; int fd; struct dirent de; // xv6文件系统中的目录层结构 struct stat st; int findSuccess = 0; // 打开文件 if((fd = open(path, 0)) &lt; 0){ fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return -1; } // 读取状态 if(fstat(fd, &amp;st) &lt; 0){ fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); close(fd); return -1; } // 读取目录并且将其放入到buf中，用一个活动的指针p去对buf中的内容进行拼接和修饰操作 strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; // 循环，判断条件为是否成功从句柄fd中读取dirent结构（目录层），使用read()函数将读取到的dirent存储到de中 while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; if(!strcmp(de.name, &quot;.&quot;) || !strcmp(de.name, &quot;..&quot;)) continue; // 拼接de.name到buf末尾，获得fd指向的目录下的一个文件完整路径 memcpy(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, &amp;st) &lt; 0){ printf(&quot;find: cannot stat %s\\n&quot;, buf); continue; } switch(st.type){ case T_FILE: if (strcmp(de.name, fName) == 0) { printf(&quot;%s\\n&quot;, buf); findSuccess = 1; } break; case T_DIR: findSuccess = find(buf, fName); break; } } close(fd); return findSuccess;}int main(int argc, char *argv[]) { int findSuccess = 0; if (argc &lt; 2 || argc &gt; 3) { fprintf(2, &quot;find: Wrong usage... \\n&quot;); exit(0); } if (argc == 2) findSuccess = find(&quot;.&quot;, argv[1]); if (argc == 3) findSuccess = find(argv[1], argv[2]); if (findSuccess == 0) printf(&quot;Cannot find the target...\\n&quot;); exit(0);} xargs 用 read 或者 get 读取管道传来的输入流 传来的输入流末尾会带一个换行 '\\n' 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;kernel/param.h&quot;#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;void run(char *program, char **args) { if (fork() == 0) { exec(program, args); exit(0); } return;}intmain (int argc, char *argv[]){ // buf缓冲区，用来读取管道传来的输入流 // xargs数组用来保存xargs命令之后的参数 // index指向xargs下一个参数写入下标 char *xargs[MAXARG], buf[2048]; int index = argc - 1; // 优先填入xargs自带参数 for (int i = 1; i &lt; argc; i++) xargs[i - 1] = argv[i]; // 从标准输入0读取到缓冲区中 char *p = buf; xargs[index] = buf; while (read(0, p, 1) != 0) { // 将空格或者\\n设置为0，代表结尾 if (*p == ' ' || *p == '\\n') { *p = 0; // 设置下一个参数从空格后开始 xargs[++index] = p + 1; if (*p == '\\n') { // 创建子进程开始执行，并重置下标，开始第二个指令 run(argv[1], xargs); index = argc - 1; } } p++; } run(argv[1], xargs); wait(0); exit(0);}","link":"/Study/curriculum/MIT6.S081/lab1/"},{"title":"LINUX 基础IO","text":"OPEN 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);pathname: 要打开或创建的目标文件flags: 打开文件时，可以传入多个参数选项，用下面的一个或者多个常量进行“或”运算，构成flags。参数:O_RDONLY: 只读打开O_WRONLY: 只写打开O_RDWR : 读，写打开这三个常量，必须指定一个且只能指定一个O_CREAT : 若文件不存在，则创建它。需要使用mode选项，来指明新文件的访问权限O_APPEND: 追加写返回值：成功：新打开的文件描述符失败：-1 0 &amp; 1 &amp; 2 Linux进程默认情况下会有3个缺省打开的文件描述符，分别是标准输入0，标准输出1，标准错误2. 0,1,2对应的物理设备一般是：键盘，显示器，显示器 123STDIN_FILENO：接收键盘的输入STDOUT_FILENO：向屏幕输出 重定向 fd 分配规则 1234567891011121314int main(){ close(1); int fd = open(&quot;myfile&quot;, O_WRONLY|O_CREAT, 00644); if(fd &lt; 0){ perror(&quot;open&quot;); return 1; } printf(&quot;fd: %d\\n&quot;, fd); fflush(stdout); close(fd); exit(0);} 以上第三行 close 执行后，write 往 fd 中写数据，显示器上不会显示，而回写入到文件中 分配规则： 系统会将012分配给标准输入，标准输出，标准错误。（因为底层要和硬件进行交互） 当我们提前关闭其中的一个时候会发现，fd 会选择下标小的进行分配。 这样也就引入了重定向 close(1) 执行之后，1就是最小的下标，open 一个文件通过文件描述符 fd 来描述，此时 fd 的值就为1，而后边向显示器中输入就会重定向到文件里。 例子 redirect 123456789101112131415161718int main() { int pid; pid = fork(); if(pid == 0) { close(1); open(&quot;output.txt&quot;, 0_WRONLY|0_CREATE); char *argv[] = { &quot;echo&quot;, &quot;this&quot;, &quot;is&quot;, &quot;redirected&quot;, &quot;echo&quot;, 0 }; // 0 表示到达结尾 exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(1); } else { wait((int *) 0); } exit(0);} 123$ redirect$ cat output.txtthis is redirected echo dup 函数 有时候我们需要把标准输入重定向到一个文件，或者把标准输出重定向到网络连接（比如 CGI 编程），就可以通过 dup() 和 dup2() 来实现。 12int dup(int oldfd);int dup(int oldfd, int newfd) dup() 示例 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;int main(){ int oldfd = open(&quot;wyg.txt&quot;,O_RDWR | O_CREAT,664); if(oldfd &lt; 0) { perror(&quot;open&quot;); } printf(&quot;oldfd is : %d\\n&quot;,oldfd); int newfd = dup(oldfd); if(newfd &lt; 0) { perror(&quot;dup&quot;); } printf(&quot;newfd is : %d\\n&quot;,newfd); char *data = &quot;this is new data&quot;; write(newfd,data,strlen(data)); return 0;} 由结果可看出 oldfd 文件描述符为 3，newfd 文件描述符为 4，而 oldfd 和 newfd 都可以对 wyg.txt 文件进行操作。 复制文件描述符，实质应该理解为: oldfd 句柄原本指向 wyg.txt 的文件描述结构体，dup() 指向完毕后，newfd 句柄也会指向 wyg.txt 文件描述结构体。所以说对 newfd 句柄所指的文件操作，等价于操作 wyg.txt 文件。 dup2() 示例 dup2() 与 dup() 的区别在于可以用 newfd 来指定新描述符数值，若 newfd 指向的文件已经被打开，会先将其关闭。若 newfd 等于 oldfd，就不关闭 newfd，newfd 和 oldfd 共同指向一份文件。 12//int fd = open(&quot;./README.TXT&quot;,O_RDWR|O_APPEND,0777);dup2(fd,STDIN_FILENO); 实际上通过调用 dup2(fd,STDIN_FILENO);fd 和 STDIN_FILENO 之间建立了一种关系。本来所有函数的输出都要往终端输出哪里走，但是通过调用 dup2函数，终端输出关闭了（也就是若 newfd 原来已经打开了一个文件，则先关闭这个文件），那么终端输出关闭后这些输出往哪里去呢？当然是往我们新复制的文件描述符这里了。所有相当于是把 newfd 重定向至了 oldfd Pipe 函数 12#include&lt;unistd.h&gt;int pipe(int fd[2]); pipe 函数定义中的 fd 参数是一个大小为 2 的一个数组类型的指针。 该函数成功时返回 0，并将一对打开的文件描述符值填入 fd 参数指向的数组。 失败时返回 -1并设置 errno。 通过 pipe 函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0] 一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。 如果管道的写端文件描述符 fd[1] 的引用计数减少至 0，即没有任何进程需要往管道中写入数据，则对该管道的读端文件描述符 fd[0] 的 read 操作将返回 0 (管道内不存在数据的情况)，即读到了文件结束标记 (EOF，End Of File)；反之，如果管道的读端文件描述符 fd[0] 的引用计数减少至 0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符 fd[1] 的 write 操作将失败，并引发 SIGPIPE 信号 (往读端被关闭的管道或 socket 连接中写数据)。 管道内部传输的数据是字节流，这和 TCP 字节流的概念相同。但它们又存在细微的差别。应用层程序能往一个 TCP 连接中写入多少字节的数据，取决于对方接受窗口的大小和本端的拥塞窗口的大小。而管道的话本身拥有一个容量限制，它规定如果管道的写端应用程序不将管道中数据读走的话，该管道最多还能被写入多少字节的数据。管道容量的大小默认是 65536 字节。我们也可以使用 fcntl 函数来修改管道容量。","link":"/Study/curriculum/MIT6.S081/%E5%9F%BA%E7%A1%80IO/"}],"tags":[{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"datastruct","slug":"datastruct","link":"/tags/datastruct/"},{"name":"distributed","slug":"distributed","link":"/tags/distributed/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"simpleBank","slug":"simpleBank","link":"/tags/simpleBank/"},{"name":"Bash","slug":"Bash","link":"/tags/Bash/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"cs","slug":"cs","link":"/tags/cs/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"log","slug":"log","link":"/tags/log/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"bookNote","slug":"bookNote","link":"/tags/bookNote/"},{"name":"career","slug":"career","link":"/tags/career/"},{"name":"csapp","slug":"csapp","link":"/tags/csapp/"},{"name":"dataStruct","slug":"dataStruct","link":"/tags/dataStruct/"},{"name":"live","slug":"live","link":"/tags/live/"},{"name":"psychology","slug":"psychology","link":"/tags/psychology/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"obsidian","slug":"obsidian","link":"/tags/obsidian/"},{"name":"memo","slug":"memo","link":"/tags/memo/"},{"name":"project","slug":"project","link":"/tags/project/"},{"name":"curriculum","slug":"curriculum","link":"/tags/curriculum/"},{"name":"MIT6.S081","slug":"MIT6-S081","link":"/tags/MIT6-S081/"}],"categories":[{"name":"FrontEnd","slug":"FrontEnd","link":"/categories/FrontEnd/"},{"name":"Interview","slug":"Interview","link":"/categories/Interview/"},{"name":"Memo","slug":"Memo","link":"/categories/Memo/"},{"name":"Project","slug":"Project","link":"/categories/Project/"},{"name":"Tutorial","slug":"Tutorial","link":"/categories/Tutorial/"},{"name":"BackEnd","slug":"BackEnd","link":"/categories/BackEnd/"},{"name":"Study","slug":"Study","link":"/categories/Study/"}],"pages":[]}